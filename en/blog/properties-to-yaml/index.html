<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Properties to YAML Conversion Tool User Manual\rðŸ“‹ Overview\rThis is a powerful Python script tool for converting Java .properties configuration files to YAML format. The tool not only supports basic format conversion, but also features intelligent comment preservation, type inference, and structure maintenance functions.\nðŸ“œ Script\r#!/usr/bin/env python3 # -*- coding: utf-8 -*- &#34;&#34;&#34; Properties file to YAML file tool (fixed version) Fixed the issue of values being forcibly converted to strings &#34;&#34;&#34; import sys import argparse from pathlib import Path from collections import OrderedDict import yaml import re def infer_value_type(value_str): &#34;&#34;&#34; Infer the type of value and return the appropriate Python object &#34;&#34;&#34; if not isinstance(value_str, str): return value_str value_str = value_str.strip() # Null value processing if value_str == '' or value_str.lower() in ['null', 'nil']: return None # Boolean values if value_str.lower() in ['true', 'false']: return value_str.lower() == 'true' # Numbers (integers) try: if '.' not in value_str and re.match(r'^-?\\d+$', value_str): return int(value_str) except ValueError: pass # Numbers (floating point) try: if re.match(r'^-?\\d+\\.?\\d*$', value_str): return float(value_str) except ValueError: pass # Remove possible quotes if (value_str.startswith('&#34;') and value_str.endswith('&#34;')) or \\ (value_str.startswith(&#34;'&#34;) and value_str.endswith(&#34;'&#34;)): return value_str[1:-1] return value_str def parse_properties_content(content): &#34;&#34;&#34; Parse properties file content, strictly maintaining the original order and structure &#34;&#34;&#34; result = OrderedDict() result['_structure'] = [] lines = content.splitlines() i = 0 while i < len(lines): line = lines[i] stripped_line = line.strip() if stripped_line.startswith('#') or stripped_line.startswith('!'): comment_content = stripped_line[1:].strip() result['_structure'].append({ 'type': 'comment', 'content': comment_content, 'original_line': line }) i += 1 continue if not stripped_line: result['_structure'].append({ 'type': 'empty_line', 'original_line': line }) i += 1 continue if '=' in stripped_line or ':' in stripped_line: if '=' in stripped_line: separator = '=' else: separator = ':' key, value = stripped_line.split(separator, 1) key = key.strip() value = value.strip() # Infer value type typed_value = infer_value_type(value) struct_entry = { 'type': 'property', 'key': key, 'value': value, # Original string value 'typed_value': typed_value, # Type-inferred value 'original_line': line } result['_structure'].append(struct_entry) if '.' in key: keys = key.split('.') current_dict = result for j, k in enumerate(keys[:-1]): if k not in current_dict: current_dict[k] = OrderedDict() elif not isinstance(current_dict[k], OrderedDict): current_dict[k] = OrderedDict([('_value', current_dict[k])]) current_dict = current_dict[k] current_dict[keys[-1]] = typed_value else: result[key] = typed_value else: print(f&#34;Warning: Line {i + 1} format is incorrect, skipping: {stripped_line}&#34;) i += 1 return result def dump_yaml_with_structure(data, stream=None): &#34;&#34;&#34; Fixed version: Correctly handle value types, avoid forced stringification &#34;&#34;&#34; # Build nested structure (using type-inferred values) ordered_nested = OrderedDict() for i, item in enumerate(data['_structure']): if item['type'] == 'property': key = item['key'] typed_value = item.get('typed_value', item['value']) if '.' in key: top_level_key = key.split('.')[0] if top_level_key not in ordered_nested: ordered_nested[top_level_key] = OrderedDict() parts = key.split('.') current = ordered_nested for part in parts[:-1]: if part not in current: current[part] = OrderedDict() elif not isinstance(current[part], OrderedDict): current[part] = OrderedDict([('_value', current[part])]) current = current[part] current[parts[-1]] = typed_value else: ordered_nested[key] = typed_value # Generate YAML (using standard yaml.dump, which automatically handles types) class OrderedDumper(yaml.SafeDumper): pass def represent_ordereddict(dumper, data): return dumper.represent_dict(data.items()) OrderedDumper.add_representer(OrderedDict, represent_ordereddict) # Process comments and structure output_lines = [] processed_groups = set() # Comment processing logic: Identify independent and associated comment blocks # Independent comment blocks: Surrounded by empty lines or file boundaries # Associated comment blocks: Next line is a property item # Sticky processing: Independent comment blocks prefer upward search, downward if not found comment_mapping = {} # First pass scan: Identify comment block types and positions scan_index = 0 while scan_index < len(data['_structure']): if data['_structure'][scan_index]['type'] == 'comment': # Find the start and end of comment block comment_block_start = scan_index comment_contents = [] # Collect consecutive comments while scan_index < len(data['_structure']) and data['_structure'][scan_index]['type'] == 'comment': comment_contents.append(data['_structure'][scan_index]['content']) scan_index += 1 comment_block_end = scan_index - 1 # Determine comment block type and sticky processing target_property = None target_position = None comment_type = None # Check context environment prev_is_empty_or_start = (comment_block_start == 0 or data['_structure'][comment_block_start - 1]['type'] == 'empty_line') next_is_empty_or_end = (comment_block_end == len(data['_structure']) - 1 or data['_structure'][comment_block_end + 1]['type'] == 'empty_line') next_is_property = (comment_block_end < len(data['_structure']) - 1 and data['_structure'][comment_block_end + 1]['type'] == 'property') # Sticky processing logic if prev_is_empty_or_start and next_is_empty_or_end: # Sticky processing for independent comment blocks # First try to search upward for property items found_upward_property = None for j in range(comment_block_start - 1, -1, -1): if data['_structure'][j]['type'] == 'property': found_upward_property = data['_structure'][j]['key'] break if found_upward_property: # Found property item above, set as below independent comment block target_property = found_upward_property target_position = 'below' comment_type = 'isolated_below' else: # Not found above, sticky search downward for first property item for j in range(comment_block_end + 1, len(data['_structure'])): if data['_structure'][j]['type'] == 'property': target_property = data['_structure'][j]['key'] break if target_property: target_position = 'above' comment_type = 'isolated_above' elif next_is_property: # Associated comment block: Sticky search downward for first property item target_property = data['_structure'][comment_block_end + 1]['key'] target_position = 'above' comment_type = 'associated' # If target property is found, add comment block if target_property and target_position and comment_type: if target_property not in comment_mapping: comment_mapping[target_property] = [] # Add comment block to list, maintaining order comment_mapping[target_property].append({ 'comments': comment_contents.copy(), 'type': comment_type, 'position': target_position }) else: scan_index += 1 # Debug information for comment mapping results has been removed # Structure processing: Process by property groups, preserve comment positions i = 0 while i < len(data['_structure']): item = data['_structure'][i] if item['type'] == 'property': key = item['key'] if '.' in key: top_level_key = key.split('.')[0] # Only process unprocessed groups if top_level_key not in processed_groups: # Before processing group, check if there are above comments to insert # For group-level comments, check comments of first property in group first_group_property = None # Find the first property of this group for j in range(i, len(data['_structure'])): if data['_structure'][j]['type'] == 'property': prop_key = data['_structure'][j]['key'] if prop_key.split('.')[0] == top_level_key: first_group_property = prop_key break if first_group_property and first_group_property in comment_mapping: for comment_block in comment_mapping[first_group_property]: if comment_block['position'] == 'above': for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) # Collect all properties of this group (find all same-group properties in entire structure) group_properties = [] # Traverse entire structure, collect all properties belonging to this group for j in range(len(data['_structure'])): if data['_structure'][j]['type'] == 'property': prop_key = data['_structure'][j]['key'] if prop_key.split('.')[0] == top_level_key: group_properties.append({ 'key': prop_key, 'typed_value': data['_structure'][j].get('typed_value', data['_structure'][j]['value']) }) # Output group start output_lines.append(f&#34;{top_level_key}:&#34;) # Process group properties one by one current_nested_path = [] # Track current nested path for idx, prop_info in enumerate(group_properties): prop_key = prop_info['key'] typed_value = prop_info['typed_value'] # Process above comments (exclude group-level comments of first property) if prop_key in comment_mapping: for comment_block in comment_mapping[prop_key]: if comment_block['position'] == 'above': # If it's the first property (idx=0), and this property is the group's first property, skip # Because its comments have already been processed at group level if not (idx == 0 and prop_key == first_group_property): for comment in comment_block['comments']: output_lines.append(f&#34; # {comment}&#34;) # Output property (optimized nested structure processing) if '.' in prop_key: # Nested properties nested_parts = prop_key.split('.')[1:] # Remove top-level key if len(nested_parts) == 1: # Second-level properties temp_dict = {nested_parts[0]: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() # Add appropriate indentation indented_line = ' ' + formatted_line output_lines.append(indented_line) else: # Deeper nesting - need to build correct hierarchical structure # First output parent structure for level in range(len(nested_parts) - 1): current_part = nested_parts[level] indent_spaces = ' ' * (level + 1) # Check if this level has already been output path_so_far = nested_parts[:level+1] if path_so_far != current_nested_path[:len(path_so_far)]: output_lines.append(f&#34;{indent_spaces}{current_part}:&#34;) # Update current path if len(current_nested_path) <= level: current_nested_path.extend(path_so_far[len(current_nested_path):]) else: current_nested_path = path_so_far[:] # Output last-level property final_level = len(nested_parts) - 1 final_indent = ' ' * (final_level + 1) final_key = nested_parts[final_level] temp_dict = {final_key: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() # Remove key name, keep only value if ':' in formatted_line: value_part = formatted_line.split(':', 1)[1].strip() else: value_part = str(typed_value) output_lines.append(f&#34;{final_indent}{final_key}: {value_part}&#34;) else: # Simple properties (shouldn't appear in groups theoretically, but for safety) temp_dict = {prop_key: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() output_lines.append(f&#34; {formatted_line}&#34;) # Process below comments if prop_key in comment_mapping: has_below_comments = False for comment_block in comment_mapping[prop_key]: if comment_block['position'] == 'below': if not has_below_comments: output_lines.append(&#34;&#34;) # Add separator empty line has_below_comments = True for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) output_lines.append(&#34;&#34;) # Add empty line separately processed_groups.add(top_level_key) # Skip processed properties while i < len(data['_structure']) and data['_structure'][i]['type'] == 'property': if data['_structure'][i]['key'].split('.')[0] == top_level_key: i += 1 else: break continue # Skip all properties of this group while i < len(data['_structure']) and data['_structure'][i]['type'] == 'property': next_key = data['_structure'][i]['key'] if next_key.split('.')[0] == top_level_key: i += 1 else: break else: # Process comments and output for simple properties if key in comment_mapping: # Process above comments for comment_block in comment_mapping[key]: if comment_block['position'] == 'above': for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) # Output property value = item['value'] output_lines.append(f&#34;{key}: '{value}'&#34;) # Process below comments if key in comment_mapping: has_below_comments = False for comment_block in comment_mapping[key]: if comment_block['position'] == 'below': if not has_below_comments: output_lines.append(&#34;&#34;) # Separator empty line has_below_comments = True for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) output_lines.append(&#34;&#34;) # Empty line after comments i += 1 else: i += 1 # Remove trailing empty lines while output_lines and output_lines[-1] == &#34;&#34;: output_lines.pop() result = '\\n'.join(output_lines) if stream: stream.write(result) return result def properties_to_yaml(properties_file_path): &#34;&#34;&#34;Convert properties file to YAML format&#34;&#34;&#34; try: prop_path = Path(properties_file_path) if not prop_path.exists(): print(f&#34;Error: File does not exist - {properties_file_path}&#34;) return False if not prop_path.is_file(): print(f&#34;Error: Path is not a file - {properties_file_path}&#34;) return False with open(prop_path, 'r', encoding='utf-8') as f: content = f.read() properties_dict = parse_properties_content(content) yaml_file_path = prop_path.with_suffix('.yaml') result = dump_yaml_with_structure(properties_dict) # Final content check debug information has been removed with open(yaml_file_path, 'w', encoding='utf-8') as f: f.write(result) print(f&#34;Successfully converted: {properties_file_path} -> {yaml_file_path}&#34;) return True except Exception as e: print(f&#34;Conversion failed: {properties_file_path}&#34;) print(f&#34;Error message: {str(e)}&#34;) import traceback traceback.print_exc() return False def main(): &#34;&#34;&#34;Main function: Process command line arguments and execute conversion&#34;&#34;&#34; parser = argparse.ArgumentParser(description='Convert properties files to yaml files') parser.add_argument('files', nargs='+', help='Paths of properties files to convert') args = parser.parse_args() success_count = 0 fail_count = 0 print(&#34;Starting conversion of properties files to yaml format...&#34;) print(&#34;=&#34; * 50) for file_path in args.files: if properties_to_yaml(file_path): success_count += 1 else: fail_count += 1 print(&#34;=&#34; * 50) print(f&#34;Conversion completed! Success: {success_count}, Failed: {fail_count}&#34;) return 1 if fail_count > 0 else 0 if __name__ == '__main__': sys.exit(main()) ðŸš€ Main Features\râœ… Core Functions\rMulti-file batch conversion - Support simultaneous conversion of multiple configuration files Intelligent type inference - Automatically identify boolean values, numbers, strings and other data types Complete comment preservation - Preserve all original comments and their positional relationships Structure order maintenance - Strictly maintain the key-value pair order of the original file Nested property handling - Intelligent processing of dot-separated hierarchical configurations ðŸŽ¯ Advanced Features\rComment intelligent positioning - Support precise position maintenance of above and below comments Independent comment processing - Intelligent processing of independent comment blocks in files UTF-8 encoding support - Perfect support for Chinese and other multilingual characters Error handling mechanism - Comprehensive error prompts and conversion statistics ðŸ“¦ Installation Requirements\rSystem Environment\rPython version: 3.6 or higher Operating system: Windows, Linux, macOS all supported Dependencies\rNeed to install PyYAML library:\n"><title>Properties to YAML Conversion Tool</title><link rel=canonical href=https://zg-dd.github.io/en/blog/properties-to-yaml/><link rel=stylesheet href=/scss/style.min.ff560f1cad7a040e336f2dd6880b9ee1ad344d6e3d8f5411e5a1aaa8b23bbdd0.css><meta property='og:title' content="Properties to YAML Conversion Tool"><meta property='og:description' content="Properties to YAML Conversion Tool User Manual\rðŸ“‹ Overview\rThis is a powerful Python script tool for converting Java .properties configuration files to YAML format. The tool not only supports basic format conversion, but also features intelligent comment preservation, type inference, and structure maintenance functions.\nðŸ“œ Script\r#!/usr/bin/env python3 # -*- coding: utf-8 -*- &#34;&#34;&#34; Properties file to YAML file tool (fixed version) Fixed the issue of values being forcibly converted to strings &#34;&#34;&#34; import sys import argparse from pathlib import Path from collections import OrderedDict import yaml import re def infer_value_type(value_str): &#34;&#34;&#34; Infer the type of value and return the appropriate Python object &#34;&#34;&#34; if not isinstance(value_str, str): return value_str value_str = value_str.strip() # Null value processing if value_str == '' or value_str.lower() in ['null', 'nil']: return None # Boolean values if value_str.lower() in ['true', 'false']: return value_str.lower() == 'true' # Numbers (integers) try: if '.' not in value_str and re.match(r'^-?\\d+$', value_str): return int(value_str) except ValueError: pass # Numbers (floating point) try: if re.match(r'^-?\\d+\\.?\\d*$', value_str): return float(value_str) except ValueError: pass # Remove possible quotes if (value_str.startswith('&#34;') and value_str.endswith('&#34;')) or \\ (value_str.startswith(&#34;'&#34;) and value_str.endswith(&#34;'&#34;)): return value_str[1:-1] return value_str def parse_properties_content(content): &#34;&#34;&#34; Parse properties file content, strictly maintaining the original order and structure &#34;&#34;&#34; result = OrderedDict() result['_structure'] = [] lines = content.splitlines() i = 0 while i < len(lines): line = lines[i] stripped_line = line.strip() if stripped_line.startswith('#') or stripped_line.startswith('!'): comment_content = stripped_line[1:].strip() result['_structure'].append({ 'type': 'comment', 'content': comment_content, 'original_line': line }) i += 1 continue if not stripped_line: result['_structure'].append({ 'type': 'empty_line', 'original_line': line }) i += 1 continue if '=' in stripped_line or ':' in stripped_line: if '=' in stripped_line: separator = '=' else: separator = ':' key, value = stripped_line.split(separator, 1) key = key.strip() value = value.strip() # Infer value type typed_value = infer_value_type(value) struct_entry = { 'type': 'property', 'key': key, 'value': value, # Original string value 'typed_value': typed_value, # Type-inferred value 'original_line': line } result['_structure'].append(struct_entry) if '.' in key: keys = key.split('.') current_dict = result for j, k in enumerate(keys[:-1]): if k not in current_dict: current_dict[k] = OrderedDict() elif not isinstance(current_dict[k], OrderedDict): current_dict[k] = OrderedDict([('_value', current_dict[k])]) current_dict = current_dict[k] current_dict[keys[-1]] = typed_value else: result[key] = typed_value else: print(f&#34;Warning: Line {i + 1} format is incorrect, skipping: {stripped_line}&#34;) i += 1 return result def dump_yaml_with_structure(data, stream=None): &#34;&#34;&#34; Fixed version: Correctly handle value types, avoid forced stringification &#34;&#34;&#34; # Build nested structure (using type-inferred values) ordered_nested = OrderedDict() for i, item in enumerate(data['_structure']): if item['type'] == 'property': key = item['key'] typed_value = item.get('typed_value', item['value']) if '.' in key: top_level_key = key.split('.')[0] if top_level_key not in ordered_nested: ordered_nested[top_level_key] = OrderedDict() parts = key.split('.') current = ordered_nested for part in parts[:-1]: if part not in current: current[part] = OrderedDict() elif not isinstance(current[part], OrderedDict): current[part] = OrderedDict([('_value', current[part])]) current = current[part] current[parts[-1]] = typed_value else: ordered_nested[key] = typed_value # Generate YAML (using standard yaml.dump, which automatically handles types) class OrderedDumper(yaml.SafeDumper): pass def represent_ordereddict(dumper, data): return dumper.represent_dict(data.items()) OrderedDumper.add_representer(OrderedDict, represent_ordereddict) # Process comments and structure output_lines = [] processed_groups = set() # Comment processing logic: Identify independent and associated comment blocks # Independent comment blocks: Surrounded by empty lines or file boundaries # Associated comment blocks: Next line is a property item # Sticky processing: Independent comment blocks prefer upward search, downward if not found comment_mapping = {} # First pass scan: Identify comment block types and positions scan_index = 0 while scan_index < len(data['_structure']): if data['_structure'][scan_index]['type'] == 'comment': # Find the start and end of comment block comment_block_start = scan_index comment_contents = [] # Collect consecutive comments while scan_index < len(data['_structure']) and data['_structure'][scan_index]['type'] == 'comment': comment_contents.append(data['_structure'][scan_index]['content']) scan_index += 1 comment_block_end = scan_index - 1 # Determine comment block type and sticky processing target_property = None target_position = None comment_type = None # Check context environment prev_is_empty_or_start = (comment_block_start == 0 or data['_structure'][comment_block_start - 1]['type'] == 'empty_line') next_is_empty_or_end = (comment_block_end == len(data['_structure']) - 1 or data['_structure'][comment_block_end + 1]['type'] == 'empty_line') next_is_property = (comment_block_end < len(data['_structure']) - 1 and data['_structure'][comment_block_end + 1]['type'] == 'property') # Sticky processing logic if prev_is_empty_or_start and next_is_empty_or_end: # Sticky processing for independent comment blocks # First try to search upward for property items found_upward_property = None for j in range(comment_block_start - 1, -1, -1): if data['_structure'][j]['type'] == 'property': found_upward_property = data['_structure'][j]['key'] break if found_upward_property: # Found property item above, set as below independent comment block target_property = found_upward_property target_position = 'below' comment_type = 'isolated_below' else: # Not found above, sticky search downward for first property item for j in range(comment_block_end + 1, len(data['_structure'])): if data['_structure'][j]['type'] == 'property': target_property = data['_structure'][j]['key'] break if target_property: target_position = 'above' comment_type = 'isolated_above' elif next_is_property: # Associated comment block: Sticky search downward for first property item target_property = data['_structure'][comment_block_end + 1]['key'] target_position = 'above' comment_type = 'associated' # If target property is found, add comment block if target_property and target_position and comment_type: if target_property not in comment_mapping: comment_mapping[target_property] = [] # Add comment block to list, maintaining order comment_mapping[target_property].append({ 'comments': comment_contents.copy(), 'type': comment_type, 'position': target_position }) else: scan_index += 1 # Debug information for comment mapping results has been removed # Structure processing: Process by property groups, preserve comment positions i = 0 while i < len(data['_structure']): item = data['_structure'][i] if item['type'] == 'property': key = item['key'] if '.' in key: top_level_key = key.split('.')[0] # Only process unprocessed groups if top_level_key not in processed_groups: # Before processing group, check if there are above comments to insert # For group-level comments, check comments of first property in group first_group_property = None # Find the first property of this group for j in range(i, len(data['_structure'])): if data['_structure'][j]['type'] == 'property': prop_key = data['_structure'][j]['key'] if prop_key.split('.')[0] == top_level_key: first_group_property = prop_key break if first_group_property and first_group_property in comment_mapping: for comment_block in comment_mapping[first_group_property]: if comment_block['position'] == 'above': for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) # Collect all properties of this group (find all same-group properties in entire structure) group_properties = [] # Traverse entire structure, collect all properties belonging to this group for j in range(len(data['_structure'])): if data['_structure'][j]['type'] == 'property': prop_key = data['_structure'][j]['key'] if prop_key.split('.')[0] == top_level_key: group_properties.append({ 'key': prop_key, 'typed_value': data['_structure'][j].get('typed_value', data['_structure'][j]['value']) }) # Output group start output_lines.append(f&#34;{top_level_key}:&#34;) # Process group properties one by one current_nested_path = [] # Track current nested path for idx, prop_info in enumerate(group_properties): prop_key = prop_info['key'] typed_value = prop_info['typed_value'] # Process above comments (exclude group-level comments of first property) if prop_key in comment_mapping: for comment_block in comment_mapping[prop_key]: if comment_block['position'] == 'above': # If it's the first property (idx=0), and this property is the group's first property, skip # Because its comments have already been processed at group level if not (idx == 0 and prop_key == first_group_property): for comment in comment_block['comments']: output_lines.append(f&#34; # {comment}&#34;) # Output property (optimized nested structure processing) if '.' in prop_key: # Nested properties nested_parts = prop_key.split('.')[1:] # Remove top-level key if len(nested_parts) == 1: # Second-level properties temp_dict = {nested_parts[0]: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() # Add appropriate indentation indented_line = ' ' + formatted_line output_lines.append(indented_line) else: # Deeper nesting - need to build correct hierarchical structure # First output parent structure for level in range(len(nested_parts) - 1): current_part = nested_parts[level] indent_spaces = ' ' * (level + 1) # Check if this level has already been output path_so_far = nested_parts[:level+1] if path_so_far != current_nested_path[:len(path_so_far)]: output_lines.append(f&#34;{indent_spaces}{current_part}:&#34;) # Update current path if len(current_nested_path) <= level: current_nested_path.extend(path_so_far[len(current_nested_path):]) else: current_nested_path = path_so_far[:] # Output last-level property final_level = len(nested_parts) - 1 final_indent = ' ' * (final_level + 1) final_key = nested_parts[final_level] temp_dict = {final_key: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() # Remove key name, keep only value if ':' in formatted_line: value_part = formatted_line.split(':', 1)[1].strip() else: value_part = str(typed_value) output_lines.append(f&#34;{final_indent}{final_key}: {value_part}&#34;) else: # Simple properties (shouldn't appear in groups theoretically, but for safety) temp_dict = {prop_key: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() output_lines.append(f&#34; {formatted_line}&#34;) # Process below comments if prop_key in comment_mapping: has_below_comments = False for comment_block in comment_mapping[prop_key]: if comment_block['position'] == 'below': if not has_below_comments: output_lines.append(&#34;&#34;) # Add separator empty line has_below_comments = True for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) output_lines.append(&#34;&#34;) # Add empty line separately processed_groups.add(top_level_key) # Skip processed properties while i < len(data['_structure']) and data['_structure'][i]['type'] == 'property': if data['_structure'][i]['key'].split('.')[0] == top_level_key: i += 1 else: break continue # Skip all properties of this group while i < len(data['_structure']) and data['_structure'][i]['type'] == 'property': next_key = data['_structure'][i]['key'] if next_key.split('.')[0] == top_level_key: i += 1 else: break else: # Process comments and output for simple properties if key in comment_mapping: # Process above comments for comment_block in comment_mapping[key]: if comment_block['position'] == 'above': for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) # Output property value = item['value'] output_lines.append(f&#34;{key}: '{value}'&#34;) # Process below comments if key in comment_mapping: has_below_comments = False for comment_block in comment_mapping[key]: if comment_block['position'] == 'below': if not has_below_comments: output_lines.append(&#34;&#34;) # Separator empty line has_below_comments = True for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) output_lines.append(&#34;&#34;) # Empty line after comments i += 1 else: i += 1 # Remove trailing empty lines while output_lines and output_lines[-1] == &#34;&#34;: output_lines.pop() result = '\\n'.join(output_lines) if stream: stream.write(result) return result def properties_to_yaml(properties_file_path): &#34;&#34;&#34;Convert properties file to YAML format&#34;&#34;&#34; try: prop_path = Path(properties_file_path) if not prop_path.exists(): print(f&#34;Error: File does not exist - {properties_file_path}&#34;) return False if not prop_path.is_file(): print(f&#34;Error: Path is not a file - {properties_file_path}&#34;) return False with open(prop_path, 'r', encoding='utf-8') as f: content = f.read() properties_dict = parse_properties_content(content) yaml_file_path = prop_path.with_suffix('.yaml') result = dump_yaml_with_structure(properties_dict) # Final content check debug information has been removed with open(yaml_file_path, 'w', encoding='utf-8') as f: f.write(result) print(f&#34;Successfully converted: {properties_file_path} -> {yaml_file_path}&#34;) return True except Exception as e: print(f&#34;Conversion failed: {properties_file_path}&#34;) print(f&#34;Error message: {str(e)}&#34;) import traceback traceback.print_exc() return False def main(): &#34;&#34;&#34;Main function: Process command line arguments and execute conversion&#34;&#34;&#34; parser = argparse.ArgumentParser(description='Convert properties files to yaml files') parser.add_argument('files', nargs='+', help='Paths of properties files to convert') args = parser.parse_args() success_count = 0 fail_count = 0 print(&#34;Starting conversion of properties files to yaml format...&#34;) print(&#34;=&#34; * 50) for file_path in args.files: if properties_to_yaml(file_path): success_count += 1 else: fail_count += 1 print(&#34;=&#34; * 50) print(f&#34;Conversion completed! Success: {success_count}, Failed: {fail_count}&#34;) return 1 if fail_count > 0 else 0 if __name__ == '__main__': sys.exit(main()) ðŸš€ Main Features\râœ… Core Functions\rMulti-file batch conversion - Support simultaneous conversion of multiple configuration files Intelligent type inference - Automatically identify boolean values, numbers, strings and other data types Complete comment preservation - Preserve all original comments and their positional relationships Structure order maintenance - Strictly maintain the key-value pair order of the original file Nested property handling - Intelligent processing of dot-separated hierarchical configurations ðŸŽ¯ Advanced Features\rComment intelligent positioning - Support precise position maintenance of above and below comments Independent comment processing - Intelligent processing of independent comment blocks in files UTF-8 encoding support - Perfect support for Chinese and other multilingual characters Error handling mechanism - Comprehensive error prompts and conversion statistics ðŸ“¦ Installation Requirements\rSystem Environment\rPython version: 3.6 or higher Operating system: Windows, Linux, macOS all supported Dependencies\rNeed to install PyYAML library:\n"><meta property='og:url' content='https://zg-dd.github.io/en/blog/properties-to-yaml/'><meta property='og:site_name' content='å°å·· Blog'><meta property='og:type' content='article'><meta property='article:section' content='Blog'><meta property='article:tag' content='Properties'><meta property='article:tag' content='YAML'><meta property='article:published_time' content='2026-02-09T00:32:40+08:00'><meta property='article:modified_time' content='2026-02-09T00:32:40+08:00'><meta name=twitter:title content="Properties to YAML Conversion Tool"><meta name=twitter:description content="Properties to YAML Conversion Tool User Manual\rðŸ“‹ Overview\rThis is a powerful Python script tool for converting Java .properties configuration files to YAML format. The tool not only supports basic format conversion, but also features intelligent comment preservation, type inference, and structure maintenance functions.\nðŸ“œ Script\r#!/usr/bin/env python3 # -*- coding: utf-8 -*- &#34;&#34;&#34; Properties file to YAML file tool (fixed version) Fixed the issue of values being forcibly converted to strings &#34;&#34;&#34; import sys import argparse from pathlib import Path from collections import OrderedDict import yaml import re def infer_value_type(value_str): &#34;&#34;&#34; Infer the type of value and return the appropriate Python object &#34;&#34;&#34; if not isinstance(value_str, str): return value_str value_str = value_str.strip() # Null value processing if value_str == '' or value_str.lower() in ['null', 'nil']: return None # Boolean values if value_str.lower() in ['true', 'false']: return value_str.lower() == 'true' # Numbers (integers) try: if '.' not in value_str and re.match(r'^-?\\d+$', value_str): return int(value_str) except ValueError: pass # Numbers (floating point) try: if re.match(r'^-?\\d+\\.?\\d*$', value_str): return float(value_str) except ValueError: pass # Remove possible quotes if (value_str.startswith('&#34;') and value_str.endswith('&#34;')) or \\ (value_str.startswith(&#34;'&#34;) and value_str.endswith(&#34;'&#34;)): return value_str[1:-1] return value_str def parse_properties_content(content): &#34;&#34;&#34; Parse properties file content, strictly maintaining the original order and structure &#34;&#34;&#34; result = OrderedDict() result['_structure'] = [] lines = content.splitlines() i = 0 while i < len(lines): line = lines[i] stripped_line = line.strip() if stripped_line.startswith('#') or stripped_line.startswith('!'): comment_content = stripped_line[1:].strip() result['_structure'].append({ 'type': 'comment', 'content': comment_content, 'original_line': line }) i += 1 continue if not stripped_line: result['_structure'].append({ 'type': 'empty_line', 'original_line': line }) i += 1 continue if '=' in stripped_line or ':' in stripped_line: if '=' in stripped_line: separator = '=' else: separator = ':' key, value = stripped_line.split(separator, 1) key = key.strip() value = value.strip() # Infer value type typed_value = infer_value_type(value) struct_entry = { 'type': 'property', 'key': key, 'value': value, # Original string value 'typed_value': typed_value, # Type-inferred value 'original_line': line } result['_structure'].append(struct_entry) if '.' in key: keys = key.split('.') current_dict = result for j, k in enumerate(keys[:-1]): if k not in current_dict: current_dict[k] = OrderedDict() elif not isinstance(current_dict[k], OrderedDict): current_dict[k] = OrderedDict([('_value', current_dict[k])]) current_dict = current_dict[k] current_dict[keys[-1]] = typed_value else: result[key] = typed_value else: print(f&#34;Warning: Line {i + 1} format is incorrect, skipping: {stripped_line}&#34;) i += 1 return result def dump_yaml_with_structure(data, stream=None): &#34;&#34;&#34; Fixed version: Correctly handle value types, avoid forced stringification &#34;&#34;&#34; # Build nested structure (using type-inferred values) ordered_nested = OrderedDict() for i, item in enumerate(data['_structure']): if item['type'] == 'property': key = item['key'] typed_value = item.get('typed_value', item['value']) if '.' in key: top_level_key = key.split('.')[0] if top_level_key not in ordered_nested: ordered_nested[top_level_key] = OrderedDict() parts = key.split('.') current = ordered_nested for part in parts[:-1]: if part not in current: current[part] = OrderedDict() elif not isinstance(current[part], OrderedDict): current[part] = OrderedDict([('_value', current[part])]) current = current[part] current[parts[-1]] = typed_value else: ordered_nested[key] = typed_value # Generate YAML (using standard yaml.dump, which automatically handles types) class OrderedDumper(yaml.SafeDumper): pass def represent_ordereddict(dumper, data): return dumper.represent_dict(data.items()) OrderedDumper.add_representer(OrderedDict, represent_ordereddict) # Process comments and structure output_lines = [] processed_groups = set() # Comment processing logic: Identify independent and associated comment blocks # Independent comment blocks: Surrounded by empty lines or file boundaries # Associated comment blocks: Next line is a property item # Sticky processing: Independent comment blocks prefer upward search, downward if not found comment_mapping = {} # First pass scan: Identify comment block types and positions scan_index = 0 while scan_index < len(data['_structure']): if data['_structure'][scan_index]['type'] == 'comment': # Find the start and end of comment block comment_block_start = scan_index comment_contents = [] # Collect consecutive comments while scan_index < len(data['_structure']) and data['_structure'][scan_index]['type'] == 'comment': comment_contents.append(data['_structure'][scan_index]['content']) scan_index += 1 comment_block_end = scan_index - 1 # Determine comment block type and sticky processing target_property = None target_position = None comment_type = None # Check context environment prev_is_empty_or_start = (comment_block_start == 0 or data['_structure'][comment_block_start - 1]['type'] == 'empty_line') next_is_empty_or_end = (comment_block_end == len(data['_structure']) - 1 or data['_structure'][comment_block_end + 1]['type'] == 'empty_line') next_is_property = (comment_block_end < len(data['_structure']) - 1 and data['_structure'][comment_block_end + 1]['type'] == 'property') # Sticky processing logic if prev_is_empty_or_start and next_is_empty_or_end: # Sticky processing for independent comment blocks # First try to search upward for property items found_upward_property = None for j in range(comment_block_start - 1, -1, -1): if data['_structure'][j]['type'] == 'property': found_upward_property = data['_structure'][j]['key'] break if found_upward_property: # Found property item above, set as below independent comment block target_property = found_upward_property target_position = 'below' comment_type = 'isolated_below' else: # Not found above, sticky search downward for first property item for j in range(comment_block_end + 1, len(data['_structure'])): if data['_structure'][j]['type'] == 'property': target_property = data['_structure'][j]['key'] break if target_property: target_position = 'above' comment_type = 'isolated_above' elif next_is_property: # Associated comment block: Sticky search downward for first property item target_property = data['_structure'][comment_block_end + 1]['key'] target_position = 'above' comment_type = 'associated' # If target property is found, add comment block if target_property and target_position and comment_type: if target_property not in comment_mapping: comment_mapping[target_property] = [] # Add comment block to list, maintaining order comment_mapping[target_property].append({ 'comments': comment_contents.copy(), 'type': comment_type, 'position': target_position }) else: scan_index += 1 # Debug information for comment mapping results has been removed # Structure processing: Process by property groups, preserve comment positions i = 0 while i < len(data['_structure']): item = data['_structure'][i] if item['type'] == 'property': key = item['key'] if '.' in key: top_level_key = key.split('.')[0] # Only process unprocessed groups if top_level_key not in processed_groups: # Before processing group, check if there are above comments to insert # For group-level comments, check comments of first property in group first_group_property = None # Find the first property of this group for j in range(i, len(data['_structure'])): if data['_structure'][j]['type'] == 'property': prop_key = data['_structure'][j]['key'] if prop_key.split('.')[0] == top_level_key: first_group_property = prop_key break if first_group_property and first_group_property in comment_mapping: for comment_block in comment_mapping[first_group_property]: if comment_block['position'] == 'above': for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) # Collect all properties of this group (find all same-group properties in entire structure) group_properties = [] # Traverse entire structure, collect all properties belonging to this group for j in range(len(data['_structure'])): if data['_structure'][j]['type'] == 'property': prop_key = data['_structure'][j]['key'] if prop_key.split('.')[0] == top_level_key: group_properties.append({ 'key': prop_key, 'typed_value': data['_structure'][j].get('typed_value', data['_structure'][j]['value']) }) # Output group start output_lines.append(f&#34;{top_level_key}:&#34;) # Process group properties one by one current_nested_path = [] # Track current nested path for idx, prop_info in enumerate(group_properties): prop_key = prop_info['key'] typed_value = prop_info['typed_value'] # Process above comments (exclude group-level comments of first property) if prop_key in comment_mapping: for comment_block in comment_mapping[prop_key]: if comment_block['position'] == 'above': # If it's the first property (idx=0), and this property is the group's first property, skip # Because its comments have already been processed at group level if not (idx == 0 and prop_key == first_group_property): for comment in comment_block['comments']: output_lines.append(f&#34; # {comment}&#34;) # Output property (optimized nested structure processing) if '.' in prop_key: # Nested properties nested_parts = prop_key.split('.')[1:] # Remove top-level key if len(nested_parts) == 1: # Second-level properties temp_dict = {nested_parts[0]: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() # Add appropriate indentation indented_line = ' ' + formatted_line output_lines.append(indented_line) else: # Deeper nesting - need to build correct hierarchical structure # First output parent structure for level in range(len(nested_parts) - 1): current_part = nested_parts[level] indent_spaces = ' ' * (level + 1) # Check if this level has already been output path_so_far = nested_parts[:level+1] if path_so_far != current_nested_path[:len(path_so_far)]: output_lines.append(f&#34;{indent_spaces}{current_part}:&#34;) # Update current path if len(current_nested_path) <= level: current_nested_path.extend(path_so_far[len(current_nested_path):]) else: current_nested_path = path_so_far[:] # Output last-level property final_level = len(nested_parts) - 1 final_indent = ' ' * (final_level + 1) final_key = nested_parts[final_level] temp_dict = {final_key: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() # Remove key name, keep only value if ':' in formatted_line: value_part = formatted_line.split(':', 1)[1].strip() else: value_part = str(typed_value) output_lines.append(f&#34;{final_indent}{final_key}: {value_part}&#34;) else: # Simple properties (shouldn't appear in groups theoretically, but for safety) temp_dict = {prop_key: typed_value} formatted_line = yaml.dump(temp_dict, Dumper=OrderedDumper, allow_unicode=True, default_flow_style=False, indent=2, sort_keys=False).strip() output_lines.append(f&#34; {formatted_line}&#34;) # Process below comments if prop_key in comment_mapping: has_below_comments = False for comment_block in comment_mapping[prop_key]: if comment_block['position'] == 'below': if not has_below_comments: output_lines.append(&#34;&#34;) # Add separator empty line has_below_comments = True for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) output_lines.append(&#34;&#34;) # Add empty line separately processed_groups.add(top_level_key) # Skip processed properties while i < len(data['_structure']) and data['_structure'][i]['type'] == 'property': if data['_structure'][i]['key'].split('.')[0] == top_level_key: i += 1 else: break continue # Skip all properties of this group while i < len(data['_structure']) and data['_structure'][i]['type'] == 'property': next_key = data['_structure'][i]['key'] if next_key.split('.')[0] == top_level_key: i += 1 else: break else: # Process comments and output for simple properties if key in comment_mapping: # Process above comments for comment_block in comment_mapping[key]: if comment_block['position'] == 'above': for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) # Output property value = item['value'] output_lines.append(f&#34;{key}: '{value}'&#34;) # Process below comments if key in comment_mapping: has_below_comments = False for comment_block in comment_mapping[key]: if comment_block['position'] == 'below': if not has_below_comments: output_lines.append(&#34;&#34;) # Separator empty line has_below_comments = True for comment in comment_block['comments']: output_lines.append(f&#34;# {comment}&#34;) output_lines.append(&#34;&#34;) # Empty line after comments i += 1 else: i += 1 # Remove trailing empty lines while output_lines and output_lines[-1] == &#34;&#34;: output_lines.pop() result = '\\n'.join(output_lines) if stream: stream.write(result) return result def properties_to_yaml(properties_file_path): &#34;&#34;&#34;Convert properties file to YAML format&#34;&#34;&#34; try: prop_path = Path(properties_file_path) if not prop_path.exists(): print(f&#34;Error: File does not exist - {properties_file_path}&#34;) return False if not prop_path.is_file(): print(f&#34;Error: Path is not a file - {properties_file_path}&#34;) return False with open(prop_path, 'r', encoding='utf-8') as f: content = f.read() properties_dict = parse_properties_content(content) yaml_file_path = prop_path.with_suffix('.yaml') result = dump_yaml_with_structure(properties_dict) # Final content check debug information has been removed with open(yaml_file_path, 'w', encoding='utf-8') as f: f.write(result) print(f&#34;Successfully converted: {properties_file_path} -> {yaml_file_path}&#34;) return True except Exception as e: print(f&#34;Conversion failed: {properties_file_path}&#34;) print(f&#34;Error message: {str(e)}&#34;) import traceback traceback.print_exc() return False def main(): &#34;&#34;&#34;Main function: Process command line arguments and execute conversion&#34;&#34;&#34; parser = argparse.ArgumentParser(description='Convert properties files to yaml files') parser.add_argument('files', nargs='+', help='Paths of properties files to convert') args = parser.parse_args() success_count = 0 fail_count = 0 print(&#34;Starting conversion of properties files to yaml format...&#34;) print(&#34;=&#34; * 50) for file_path in args.files: if properties_to_yaml(file_path): success_count += 1 else: fail_count += 1 print(&#34;=&#34; * 50) print(f&#34;Conversion completed! Success: {success_count}, Failed: {fail_count}&#34;) return 1 if fail_count > 0 else 0 if __name__ == '__main__': sys.exit(main()) ðŸš€ Main Features\râœ… Core Functions\rMulti-file batch conversion - Support simultaneous conversion of multiple configuration files Intelligent type inference - Automatically identify boolean values, numbers, strings and other data types Complete comment preservation - Preserve all original comments and their positional relationships Structure order maintenance - Strictly maintain the key-value pair order of the original file Nested property handling - Intelligent processing of dot-separated hierarchical configurations ðŸŽ¯ Advanced Features\rComment intelligent positioning - Support precise position maintenance of above and below comments Independent comment processing - Intelligent processing of independent comment blocks in files UTF-8 encoding support - Perfect support for Chinese and other multilingual characters Error handling mechanism - Comprehensive error prompts and conversion statistics ðŸ“¦ Installation Requirements\rSystem Environment\rPython version: 3.6 or higher Operating system: Windows, Linux, macOS all supported Dependencies\rNeed to install PyYAML library:\n"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/en/><img src=/img/avatar_hu_a0cc1cf57968b27d.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>ðŸŒ±</span></figure><div class=site-meta><h1 class=site-name><a href=/en>å°å·· Blog</a></h1><h2 class=site-description>Recording is not to prove myself; rather, to make a habit of 'solving problems â†’ thinking â†’ sedimentation'.</h2></div></header><ol class=menu id=main-menu><li><a href=/en/stu/><span>Study Notes</span></a></li><li class=current><a href=/en/blog/><span>Essays</span></a></li><li><a href=/en/life/><span>Life</span></a></li><li><a href=/categories/><span>Categories</span></a></li><li><a href=/tags/><span>Tags</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://zg-dd.github.io/>ç®€ä½“ä¸­æ–‡</option><option value=https://zg-dd.github.io/en/ selected>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#-overview>ðŸ“‹ Overview</a></li><li><a href=#-script>ðŸ“œ Script</a></li><li><a href=#-main-features>ðŸš€ Main Features</a><ul><li><a href=#-core-functions>âœ… Core Functions</a></li><li><a href=#-advanced-features>ðŸŽ¯ Advanced Features</a></li></ul></li><li><a href=#-installation-requirements>ðŸ“¦ Installation Requirements</a><ul><li><a href=#system-environment>System Environment</a></li><li><a href=#dependencies>Dependencies</a></li></ul></li><li><a href=#-usage-methods>ðŸ› ï¸ Usage Methods</a><ul><li><a href=#1-basic-usage>1. Basic Usage</a></li><li><a href=#2-path-usage>2. Path Usage</a></li></ul></li><li><a href=#-conversion-examples>ðŸ“ Conversion Examples</a><ul><li><a href=#input-file-example-applicationproperties>Input File Example (application.properties)</a></li><li><a href=#output-file-example-applicationyaml>Output File Example (application.yaml)</a></li></ul></li><li><a href=#-function-details>ðŸ”§ Function Details</a><ul><li><a href=#1-type-inference-mechanism>1. Type Inference Mechanism</a></li><li><a href=#2-comment-processing-mechanism>2. Comment Processing Mechanism</a></li><li><a href=#3-nested-structure-processing>3. Nested Structure Processing</a></li><li><a href=#4-order-maintenance-mechanism>4. Order Maintenance Mechanism</a></li></ul></li><li><a href=#-advanced-usage>âš™ï¸ Advanced Usage</a><ul><li><a href=#1-batch-processing-script>1. Batch Processing Script</a></li><li><a href=#2-integration-into-cicd-pipeline>2. Integration into CI/CD Pipeline</a></li><li><a href=#3-import-as-module>3. Import as Module</a></li></ul></li><li><a href=#-output-format-description>ðŸ“Š Output Format Description</a><ul><li><a href=#generated-file-naming>Generated File Naming</a></li><li><a href=#yaml-format-characteristics>YAML Format Characteristics</a></li></ul></li><li><a href=#-error-handling>ðŸš¨ Error Handling</a><ul><li><a href=#common-errors-and-solutions>Common Errors and Solutions</a></li></ul></li><li><a href=#-troubleshooting>ðŸ” Troubleshooting</a><ul><li><a href=#debugging-tips>Debugging Tips</a></li></ul></li><li><a href=#-performance-information>ðŸ“ˆ Performance Information</a><ul><li><a href=#processing-capability>Processing Capability</a></li></ul></li></ul></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/en/categories/java/>Java
</a><a href=/en/categories/ops-tools/>Ops Tools</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/en/blog/properties-to-yaml/>Properties to YAML Conversion Tool</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2026-02-09T00:32:40+08:00>Feb 09, 2026</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>12 minute read</time></div></footer><footer class=article-translations><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://zg-dd.github.io/blog/properties-to-yaml/ class=link>ç®€ä½“ä¸­æ–‡</a></div></footer></div></header><section class=article-content><h1 id=properties-to-yaml-conversion-tool-user-manual>Properties to YAML Conversion Tool User Manual</h1><h2 id=-overview>ðŸ“‹ Overview</h2><p>This is a powerful Python script tool for converting Java <code>.properties</code> configuration files to YAML format. The tool not only supports basic format conversion, but also features intelligent comment preservation, type inference, and structure maintenance functions.</p><h2 id=-script>ðŸ“œ Script</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -*- coding: utf-8 -*-</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Properties file to YAML file tool (fixed version)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Fixed the issue of values being forcibly converted to strings
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> argparse
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> OrderedDict
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> yaml
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>infer_value_type</span>(value_str):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Infer the type of value and return the appropriate Python object
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(value_str, str):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value_str
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    value_str <span style=color:#f92672>=</span> value_str<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Null value processing</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> value_str <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#f92672>or</span> value_str<span style=color:#f92672>.</span>lower() <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;null&#39;</span>, <span style=color:#e6db74>&#39;nil&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Boolean values</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> value_str<span style=color:#f92672>.</span>lower() <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;true&#39;</span>, <span style=color:#e6db74>&#39;false&#39;</span>]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value_str<span style=color:#f92672>.</span>lower() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;true&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Numbers (integers)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> value_str <span style=color:#f92672>and</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;^-?\d+$&#39;</span>, value_str):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> int(value_str)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Numbers (floating point)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;^-?\d+\.?\d*$&#39;</span>, value_str):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> float(value_str)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Remove possible quotes</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (value_str<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;&#34;&#39;</span>) <span style=color:#f92672>and</span> value_str<span style=color:#f92672>.</span>endswith(<span style=color:#e6db74>&#39;&#34;&#39;</span>)) <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>            (value_str<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#34;&#39;&#34;</span>) <span style=color:#f92672>and</span> value_str<span style=color:#f92672>.</span>endswith(<span style=color:#e6db74>&#34;&#39;&#34;</span>)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value_str[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value_str
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse_properties_content</span>(content):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Parse properties file content, strictly maintaining the original order and structure
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> OrderedDict()
</span></span><span style=display:flex><span>    result[<span style=color:#e6db74>&#39;_structure&#39;</span>] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    lines <span style=color:#f92672>=</span> content<span style=color:#f92672>.</span>splitlines()
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> len(lines):
</span></span><span style=display:flex><span>        line <span style=color:#f92672>=</span> lines[i]
</span></span><span style=display:flex><span>        stripped_line <span style=color:#f92672>=</span> line<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stripped_line<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;#&#39;</span>) <span style=color:#f92672>or</span> stripped_line<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;!&#39;</span>):
</span></span><span style=display:flex><span>            comment_content <span style=color:#f92672>=</span> stripped_line[<span style=color:#ae81ff>1</span>:]<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>            result[<span style=color:#e6db74>&#39;_structure&#39;</span>]<span style=color:#f92672>.</span>append({
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;type&#39;</span>: <span style=color:#e6db74>&#39;comment&#39;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;content&#39;</span>: comment_content,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;original_line&#39;</span>: line
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> stripped_line:
</span></span><span style=display:flex><span>            result[<span style=color:#e6db74>&#39;_structure&#39;</span>]<span style=color:#f92672>.</span>append({
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;type&#39;</span>: <span style=color:#e6db74>&#39;empty_line&#39;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;original_line&#39;</span>: line
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;=&#39;</span> <span style=color:#f92672>in</span> stripped_line <span style=color:#f92672>or</span> <span style=color:#e6db74>&#39;:&#39;</span> <span style=color:#f92672>in</span> stripped_line:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;=&#39;</span> <span style=color:#f92672>in</span> stripped_line:
</span></span><span style=display:flex><span>                separator <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;=&#39;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                separator <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;:&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            key, value <span style=color:#f92672>=</span> stripped_line<span style=color:#f92672>.</span>split(separator, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            key <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>            value <span style=color:#f92672>=</span> value<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Infer value type</span>
</span></span><span style=display:flex><span>            typed_value <span style=color:#f92672>=</span> infer_value_type(value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            struct_entry <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;type&#39;</span>: <span style=color:#e6db74>&#39;property&#39;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;key&#39;</span>: key,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;value&#39;</span>: value,  <span style=color:#75715e># Original string value</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;typed_value&#39;</span>: typed_value,  <span style=color:#75715e># Type-inferred value</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;original_line&#39;</span>: line
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            result[<span style=color:#e6db74>&#39;_structure&#39;</span>]<span style=color:#f92672>.</span>append(struct_entry)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>in</span> key:
</span></span><span style=display:flex><span>                keys <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)
</span></span><span style=display:flex><span>                current_dict <span style=color:#f92672>=</span> result
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> j, k <span style=color:#f92672>in</span> enumerate(keys[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]):
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> k <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> current_dict:
</span></span><span style=display:flex><span>                        current_dict[k] <span style=color:#f92672>=</span> OrderedDict()
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>elif</span> <span style=color:#f92672>not</span> isinstance(current_dict[k], OrderedDict):
</span></span><span style=display:flex><span>                        current_dict[k] <span style=color:#f92672>=</span> OrderedDict([(<span style=color:#e6db74>&#39;_value&#39;</span>, current_dict[k])])
</span></span><span style=display:flex><span>                    current_dict <span style=color:#f92672>=</span> current_dict[k]
</span></span><span style=display:flex><span>                current_dict[keys[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> typed_value
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                result[key] <span style=color:#f92672>=</span> typed_value
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Warning: Line </span><span style=color:#e6db74>{</span>i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74> format is incorrect, skipping: </span><span style=color:#e6db74>{</span>stripped_line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dump_yaml_with_structure</span>(data, stream<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Fixed version: Correctly handle value types, avoid forced stringification
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Build nested structure (using type-inferred values)</span>
</span></span><span style=display:flex><span>    ordered_nested <span style=color:#f92672>=</span> OrderedDict()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, item <span style=color:#f92672>in</span> enumerate(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> item[<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>            key <span style=color:#f92672>=</span> item[<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>            typed_value <span style=color:#f92672>=</span> item<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;typed_value&#39;</span>, item[<span style=color:#e6db74>&#39;value&#39;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>in</span> key:
</span></span><span style=display:flex><span>                top_level_key <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> top_level_key <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> ordered_nested:
</span></span><span style=display:flex><span>                    ordered_nested[top_level_key] <span style=color:#f92672>=</span> OrderedDict()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                parts <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)
</span></span><span style=display:flex><span>                current <span style=color:#f92672>=</span> ordered_nested
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> part <span style=color:#f92672>in</span> parts[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> part <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> current:
</span></span><span style=display:flex><span>                        current[part] <span style=color:#f92672>=</span> OrderedDict()
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>elif</span> <span style=color:#f92672>not</span> isinstance(current[part], OrderedDict):
</span></span><span style=display:flex><span>                        current[part] <span style=color:#f92672>=</span> OrderedDict([(<span style=color:#e6db74>&#39;_value&#39;</span>, current[part])])
</span></span><span style=display:flex><span>                    current <span style=color:#f92672>=</span> current[part]
</span></span><span style=display:flex><span>                current[parts[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> typed_value
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                ordered_nested[key] <span style=color:#f92672>=</span> typed_value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Generate YAML (using standard yaml.dump, which automatically handles types)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderedDumper</span>(yaml<span style=color:#f92672>.</span>SafeDumper):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>represent_ordereddict</span>(dumper, data):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dumper<span style=color:#f92672>.</span>represent_dict(data<span style=color:#f92672>.</span>items())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    OrderedDumper<span style=color:#f92672>.</span>add_representer(OrderedDict, represent_ordereddict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Process comments and structure</span>
</span></span><span style=display:flex><span>    output_lines <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    processed_groups <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Comment processing logic: Identify independent and associated comment blocks</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Independent comment blocks: Surrounded by empty lines or file boundaries</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Associated comment blocks: Next line is a property item</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Sticky processing: Independent comment blocks prefer upward search, downward if not found</span>
</span></span><span style=display:flex><span>    comment_mapping <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># First pass scan: Identify comment block types and positions</span>
</span></span><span style=display:flex><span>    scan_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> scan_index <span style=color:#f92672>&lt;</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][scan_index][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;comment&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Find the start and end of comment block</span>
</span></span><span style=display:flex><span>            comment_block_start <span style=color:#f92672>=</span> scan_index
</span></span><span style=display:flex><span>            comment_contents <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Collect consecutive comments</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> scan_index <span style=color:#f92672>&lt;</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]) <span style=color:#f92672>and</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][scan_index][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;comment&#39;</span>:
</span></span><span style=display:flex><span>                comment_contents<span style=color:#f92672>.</span>append(data[<span style=color:#e6db74>&#39;_structure&#39;</span>][scan_index][<span style=color:#e6db74>&#39;content&#39;</span>])
</span></span><span style=display:flex><span>                scan_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            comment_block_end <span style=color:#f92672>=</span> scan_index <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Determine comment block type and sticky processing</span>
</span></span><span style=display:flex><span>            target_property <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>            target_position <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>            comment_type <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Check context environment</span>
</span></span><span style=display:flex><span>            prev_is_empty_or_start <span style=color:#f92672>=</span> (comment_block_start <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>                                      data[<span style=color:#e6db74>&#39;_structure&#39;</span>][comment_block_start <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;empty_line&#39;</span>)
</span></span><span style=display:flex><span>            next_is_empty_or_end <span style=color:#f92672>=</span> (comment_block_end <span style=color:#f92672>==</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>                                    data[<span style=color:#e6db74>&#39;_structure&#39;</span>][comment_block_end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;empty_line&#39;</span>)
</span></span><span style=display:flex><span>            next_is_property <span style=color:#f92672>=</span> (comment_block_end <span style=color:#f92672>&lt;</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span>
</span></span><span style=display:flex><span>                                data[<span style=color:#e6db74>&#39;_structure&#39;</span>][comment_block_end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Sticky processing logic</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> prev_is_empty_or_start <span style=color:#f92672>and</span> next_is_empty_or_end:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Sticky processing for independent comment blocks</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># First try to search upward for property items</span>
</span></span><span style=display:flex><span>                found_upward_property <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(comment_block_start <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>                        found_upward_property <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> found_upward_property:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Found property item above, set as below independent comment block</span>
</span></span><span style=display:flex><span>                    target_property <span style=color:#f92672>=</span> found_upward_property
</span></span><span style=display:flex><span>                    target_position <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;below&#39;</span>
</span></span><span style=display:flex><span>                    comment_type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;isolated_below&#39;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Not found above, sticky search downward for first property item</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(comment_block_end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>])):
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>                            target_property <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> target_property:
</span></span><span style=display:flex><span>                        target_position <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;above&#39;</span>
</span></span><span style=display:flex><span>                        comment_type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;isolated_above&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> next_is_property:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Associated comment block: Sticky search downward for first property item</span>
</span></span><span style=display:flex><span>                target_property <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][comment_block_end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                target_position <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;above&#39;</span>
</span></span><span style=display:flex><span>                comment_type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;associated&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># If target property is found, add comment block</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> target_property <span style=color:#f92672>and</span> target_position <span style=color:#f92672>and</span> comment_type:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> target_property <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> comment_mapping:
</span></span><span style=display:flex><span>                    comment_mapping[target_property] <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>                <span style=color:#75715e># Add comment block to list, maintaining order</span>
</span></span><span style=display:flex><span>                comment_mapping[target_property]<span style=color:#f92672>.</span>append({
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;comments&#39;</span>: comment_contents<span style=color:#f92672>.</span>copy(),
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;type&#39;</span>: comment_type,
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#39;position&#39;</span>: target_position
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            scan_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Debug information for comment mapping results has been removed</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Structure processing: Process by property groups, preserve comment positions</span>
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]):
</span></span><span style=display:flex><span>        item <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> item[<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>            key <span style=color:#f92672>=</span> item[<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>in</span> key:
</span></span><span style=display:flex><span>                top_level_key <span style=color:#f92672>=</span> key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>                <span style=color:#75715e># Only process unprocessed groups</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> top_level_key <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> processed_groups:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Before processing group, check if there are above comments to insert</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e># For group-level comments, check comments of first property in group</span>
</span></span><span style=display:flex><span>                    first_group_property <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Find the first property of this group</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i, len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>])):
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>                            prop_key <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> prop_key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> top_level_key:
</span></span><span style=display:flex><span>                                first_group_property <span style=color:#f92672>=</span> prop_key
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> first_group_property <span style=color:#f92672>and</span> first_group_property <span style=color:#f92672>in</span> comment_mapping:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> comment_block <span style=color:#f92672>in</span> comment_mapping[first_group_property]:
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> comment_block[<span style=color:#e6db74>&#39;position&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;above&#39;</span>:
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>for</span> comment <span style=color:#f92672>in</span> comment_block[<span style=color:#e6db74>&#39;comments&#39;</span>]:
</span></span><span style=display:flex><span>                                    output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;# </span><span style=color:#e6db74>{</span>comment<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Collect all properties of this group (find all same-group properties in entire structure)</span>
</span></span><span style=display:flex><span>                    group_properties <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Traverse entire structure, collect all properties belonging to this group</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>])):
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>                            prop_key <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> prop_key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> top_level_key:
</span></span><span style=display:flex><span>                                group_properties<span style=color:#f92672>.</span>append({
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#39;key&#39;</span>: prop_key,
</span></span><span style=display:flex><span>                                    <span style=color:#e6db74>&#39;typed_value&#39;</span>: data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j]<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;typed_value&#39;</span>, data[<span style=color:#e6db74>&#39;_structure&#39;</span>][j][<span style=color:#e6db74>&#39;value&#39;</span>])
</span></span><span style=display:flex><span>                                })
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Output group start</span>
</span></span><span style=display:flex><span>                    output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>top_level_key<span style=color:#e6db74>}</span><span style=color:#e6db74>:&#34;</span>)
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Process group properties one by one</span>
</span></span><span style=display:flex><span>                    current_nested_path <span style=color:#f92672>=</span> []  <span style=color:#75715e># Track current nested path</span>
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> idx, prop_info <span style=color:#f92672>in</span> enumerate(group_properties):
</span></span><span style=display:flex><span>                        prop_key <span style=color:#f92672>=</span> prop_info[<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                        typed_value <span style=color:#f92672>=</span> prop_info[<span style=color:#e6db74>&#39;typed_value&#39;</span>]
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Process above comments (exclude group-level comments of first property)</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> prop_key <span style=color:#f92672>in</span> comment_mapping:
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> comment_block <span style=color:#f92672>in</span> comment_mapping[prop_key]:
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> comment_block[<span style=color:#e6db74>&#39;position&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;above&#39;</span>:
</span></span><span style=display:flex><span>                                    <span style=color:#75715e># If it&#39;s the first property (idx=0), and this property is the group&#39;s first property, skip</span>
</span></span><span style=display:flex><span>                                    <span style=color:#75715e># Because its comments have already been processed at group level</span>
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> (idx <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> prop_key <span style=color:#f92672>==</span> first_group_property):
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>for</span> comment <span style=color:#f92672>in</span> comment_block[<span style=color:#e6db74>&#39;comments&#39;</span>]:
</span></span><span style=display:flex><span>                                            output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;  # </span><span style=color:#e6db74>{</span>comment<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Output property (optimized nested structure processing)</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>in</span> prop_key:
</span></span><span style=display:flex><span>                            <span style=color:#75715e># Nested properties</span>
</span></span><span style=display:flex><span>                            nested_parts <span style=color:#f92672>=</span> prop_key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>1</span>:]  <span style=color:#75715e># Remove top-level key</span>
</span></span><span style=display:flex><span>                            
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> len(nested_parts) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Second-level properties</span>
</span></span><span style=display:flex><span>                                temp_dict <span style=color:#f92672>=</span> {nested_parts[<span style=color:#ae81ff>0</span>]: typed_value}
</span></span><span style=display:flex><span>                                formatted_line <span style=color:#f92672>=</span> yaml<span style=color:#f92672>.</span>dump(temp_dict, Dumper<span style=color:#f92672>=</span>OrderedDumper,
</span></span><span style=display:flex><span>                                                         allow_unicode<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, default_flow_style<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>                                                         indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, sort_keys<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Add appropriate indentation</span>
</span></span><span style=display:flex><span>                                indented_line <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;  &#39;</span> <span style=color:#f92672>+</span> formatted_line
</span></span><span style=display:flex><span>                                output_lines<span style=color:#f92672>.</span>append(indented_line)
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Deeper nesting - need to build correct hierarchical structure</span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e># First output parent structure</span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>for</span> level <span style=color:#f92672>in</span> range(len(nested_parts) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                                    current_part <span style=color:#f92672>=</span> nested_parts[level]
</span></span><span style=display:flex><span>                                    indent_spaces <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;  &#39;</span> <span style=color:#f92672>*</span> (level <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                                    
</span></span><span style=display:flex><span>                                    <span style=color:#75715e># Check if this level has already been output</span>
</span></span><span style=display:flex><span>                                    path_so_far <span style=color:#f92672>=</span> nested_parts[:level<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> path_so_far <span style=color:#f92672>!=</span> current_nested_path[:len(path_so_far)]:
</span></span><span style=display:flex><span>                                        output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>indent_spaces<span style=color:#e6db74>}{</span>current_part<span style=color:#e6db74>}</span><span style=color:#e6db74>:&#34;</span>)
</span></span><span style=display:flex><span>                                        <span style=color:#75715e># Update current path</span>
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>if</span> len(current_nested_path) <span style=color:#f92672>&lt;=</span> level:
</span></span><span style=display:flex><span>                                            current_nested_path<span style=color:#f92672>.</span>extend(path_so_far[len(current_nested_path):])
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                                            current_nested_path <span style=color:#f92672>=</span> path_so_far[:]
</span></span><span style=display:flex><span>                                
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Output last-level property</span>
</span></span><span style=display:flex><span>                                final_level <span style=color:#f92672>=</span> len(nested_parts) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                                final_indent <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;  &#39;</span> <span style=color:#f92672>*</span> (final_level <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                                final_key <span style=color:#f92672>=</span> nested_parts[final_level]
</span></span><span style=display:flex><span>                                temp_dict <span style=color:#f92672>=</span> {final_key: typed_value}
</span></span><span style=display:flex><span>                                formatted_line <span style=color:#f92672>=</span> yaml<span style=color:#f92672>.</span>dump(temp_dict, Dumper<span style=color:#f92672>=</span>OrderedDumper,
</span></span><span style=display:flex><span>                                                         allow_unicode<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, default_flow_style<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>                                                         indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, sort_keys<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Remove key name, keep only value</span>
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;:&#39;</span> <span style=color:#f92672>in</span> formatted_line:
</span></span><span style=display:flex><span>                                    value_part <span style=color:#f92672>=</span> formatted_line<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;:&#39;</span>, <span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                                    value_part <span style=color:#f92672>=</span> str(typed_value)
</span></span><span style=display:flex><span>                                output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>final_indent<span style=color:#e6db74>}{</span>final_key<span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>value_part<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                            <span style=color:#75715e># Simple properties (shouldn&#39;t appear in groups theoretically, but for safety)</span>
</span></span><span style=display:flex><span>                            temp_dict <span style=color:#f92672>=</span> {prop_key: typed_value}
</span></span><span style=display:flex><span>                            formatted_line <span style=color:#f92672>=</span> yaml<span style=color:#f92672>.</span>dump(temp_dict, Dumper<span style=color:#f92672>=</span>OrderedDumper,
</span></span><span style=display:flex><span>                                                     allow_unicode<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, default_flow_style<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>                                                     indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, sort_keys<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>                            output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;  </span><span style=color:#e6db74>{</span>formatted_line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Process below comments</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> prop_key <span style=color:#f92672>in</span> comment_mapping:
</span></span><span style=display:flex><span>                            has_below_comments <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> comment_block <span style=color:#f92672>in</span> comment_mapping[prop_key]:
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> comment_block[<span style=color:#e6db74>&#39;position&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;below&#39;</span>:
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> has_below_comments:
</span></span><span style=display:flex><span>                                        output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34;&#34;</span>)  <span style=color:#75715e># Add separator empty line</span>
</span></span><span style=display:flex><span>                                        has_below_comments <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>for</span> comment <span style=color:#f92672>in</span> comment_block[<span style=color:#e6db74>&#39;comments&#39;</span>]:
</span></span><span style=display:flex><span>                                        output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;# </span><span style=color:#e6db74>{</span>comment<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                                    output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34;&#34;</span>)  <span style=color:#75715e># Add empty line separately</span>
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    processed_groups<span style=color:#f92672>.</span>add(top_level_key)
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Skip processed properties</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]) <span style=color:#f92672>and</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][i][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][i][<span style=color:#e6db74>&#39;key&#39;</span>]<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> top_level_key:
</span></span><span style=display:flex><span>                            i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Skip all properties of this group</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> len(data[<span style=color:#e6db74>&#39;_structure&#39;</span>]) <span style=color:#f92672>and</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][i][<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;property&#39;</span>:
</span></span><span style=display:flex><span>                    next_key <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;_structure&#39;</span>][i][<span style=color:#e6db74>&#39;key&#39;</span>]
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> next_key<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> top_level_key:
</span></span><span style=display:flex><span>                        i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Process comments and output for simple properties</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> key <span style=color:#f92672>in</span> comment_mapping:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Process above comments</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> comment_block <span style=color:#f92672>in</span> comment_mapping[key]:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> comment_block[<span style=color:#e6db74>&#39;position&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;above&#39;</span>:
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> comment <span style=color:#f92672>in</span> comment_block[<span style=color:#e6db74>&#39;comments&#39;</span>]:
</span></span><span style=display:flex><span>                                output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;# </span><span style=color:#e6db74>{</span>comment<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e># Output property</span>
</span></span><span style=display:flex><span>                value <span style=color:#f92672>=</span> item[<span style=color:#e6db74>&#39;value&#39;</span>]
</span></span><span style=display:flex><span>                output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>key<span style=color:#e6db74>}</span><span style=color:#e6db74>: &#39;</span><span style=color:#e6db74>{</span>value<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;&#34;</span>)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e># Process below comments</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> key <span style=color:#f92672>in</span> comment_mapping:
</span></span><span style=display:flex><span>                    has_below_comments <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> comment_block <span style=color:#f92672>in</span> comment_mapping[key]:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> comment_block[<span style=color:#e6db74>&#39;position&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;below&#39;</span>:
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> has_below_comments:
</span></span><span style=display:flex><span>                                output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34;&#34;</span>)  <span style=color:#75715e># Separator empty line</span>
</span></span><span style=display:flex><span>                                has_below_comments <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> comment <span style=color:#f92672>in</span> comment_block[<span style=color:#e6db74>&#39;comments&#39;</span>]:
</span></span><span style=display:flex><span>                                output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;# </span><span style=color:#e6db74>{</span>comment<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>                            output_lines<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34;&#34;</span>)  <span style=color:#75715e># Empty line after comments</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Remove trailing empty lines</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> output_lines <span style=color:#f92672>and</span> output_lines[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span>:
</span></span><span style=display:flex><span>        output_lines<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>join(output_lines)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> stream:
</span></span><span style=display:flex><span>        stream<span style=color:#f92672>.</span>write(result)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>properties_to_yaml</span>(properties_file_path):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Convert properties file to YAML format&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        prop_path <span style=color:#f92672>=</span> Path(properties_file_path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> prop_path<span style=color:#f92672>.</span>exists():
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Error: File does not exist - </span><span style=color:#e6db74>{</span>properties_file_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> prop_path<span style=color:#f92672>.</span>is_file():
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Error: Path is not a file - </span><span style=color:#e6db74>{</span>properties_file_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> open(prop_path, <span style=color:#e6db74>&#39;r&#39;</span>, encoding<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;utf-8&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>            content <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        properties_dict <span style=color:#f92672>=</span> parse_properties_content(content)
</span></span><span style=display:flex><span>        yaml_file_path <span style=color:#f92672>=</span> prop_path<span style=color:#f92672>.</span>with_suffix(<span style=color:#e6db74>&#39;.yaml&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> dump_yaml_with_structure(properties_dict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Final content check debug information has been removed</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> open(yaml_file_path, <span style=color:#e6db74>&#39;w&#39;</span>, encoding<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;utf-8&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>            f<span style=color:#f92672>.</span>write(result)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Successfully converted: </span><span style=color:#e6db74>{</span>properties_file_path<span style=color:#e6db74>}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{</span>yaml_file_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Conversion failed: </span><span style=color:#e6db74>{</span>properties_file_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Error message: </span><span style=color:#e6db74>{</span>str(e)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>import</span> traceback
</span></span><span style=display:flex><span>        traceback<span style=color:#f92672>.</span>print_exc()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Main function: Process command line arguments and execute conversion&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    parser <span style=color:#f92672>=</span> argparse<span style=color:#f92672>.</span>ArgumentParser(description<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Convert properties files to yaml files&#39;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#39;files&#39;</span>, nargs<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;+&#39;</span>, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Paths of properties files to convert&#39;</span>)
</span></span><span style=display:flex><span>    args <span style=color:#f92672>=</span> parser<span style=color:#f92672>.</span>parse_args()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    success_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    fail_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Starting conversion of properties files to yaml format...&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file_path <span style=color:#f92672>in</span> args<span style=color:#f92672>.</span>files:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> properties_to_yaml(file_path):
</span></span><span style=display:flex><span>            success_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            fail_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Conversion completed! Success: </span><span style=color:#e6db74>{</span>success_count<span style=color:#e6db74>}</span><span style=color:#e6db74>, Failed: </span><span style=color:#e6db74>{</span>fail_count<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> fail_count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(main())
</span></span></code></pre></div><h2 id=-main-features>ðŸš€ Main Features</h2><h3 id=-core-functions>âœ… Core Functions</h3><ul><li><strong>Multi-file batch conversion</strong> - Support simultaneous conversion of multiple configuration files</li><li><strong>Intelligent type inference</strong> - Automatically identify boolean values, numbers, strings and other data types</li><li><strong>Complete comment preservation</strong> - Preserve all original comments and their positional relationships</li><li><strong>Structure order maintenance</strong> - Strictly maintain the key-value pair order of the original file</li><li><strong>Nested property handling</strong> - Intelligent processing of dot-separated hierarchical configurations</li></ul><h3 id=-advanced-features>ðŸŽ¯ Advanced Features</h3><ul><li><strong>Comment intelligent positioning</strong> - Support precise position maintenance of above and below comments</li><li><strong>Independent comment processing</strong> - Intelligent processing of independent comment blocks in files</li><li><strong>UTF-8 encoding support</strong> - Perfect support for Chinese and other multilingual characters</li><li><strong>Error handling mechanism</strong> - Comprehensive error prompts and conversion statistics</li></ul><h2 id=-installation-requirements>ðŸ“¦ Installation Requirements</h2><h3 id=system-environment>System Environment</h3><ul><li><strong>Python version</strong>: 3.6 or higher</li><li><strong>Operating system</strong>: Windows, Linux, macOS all supported</li></ul><h3 id=dependencies>Dependencies</h3><p>Need to install PyYAML library:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install pyyaml
</span></span></code></pre></div><h2 id=-usage-methods>ðŸ› ï¸ Usage Methods</h2><h3 id=1-basic-usage>1. Basic Usage</h3><h4 id=convert-single-file>Convert Single File</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python properties_to_yaml.py config.properties
</span></span></code></pre></div><h4 id=convert-multiple-files>Convert Multiple Files</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python properties_to_yaml.py app.properties database.properties redis.properties
</span></span></code></pre></div><h3 id=2-path-usage>2. Path Usage</h3><h4 id=absolute-path>Absolute Path</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python properties_to_yaml.py C:<span style=color:#ae81ff>\p</span>rojects<span style=color:#ae81ff>\m</span>yapp<span style=color:#ae81ff>\c</span>onfig<span style=color:#ae81ff>\a</span>pplication.properties
</span></span></code></pre></div><h4 id=relative-path>Relative Path</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python properties_to_yaml.py ./config/dev.properties
</span></span></code></pre></div><h4 id=current-directory-file>Current Directory File</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python properties_to_yaml.py application.properties
</span></span></code></pre></div><h2 id=-conversion-examples>ðŸ“ Conversion Examples</h2><h3 id=input-file-example-applicationproperties>Input File Example (application.properties)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># ==========================================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Application Core Configuration</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==========================================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Application Basic Information</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app.name</span><span style=color:#f92672>=</span><span style=color:#e6db74>MyAwesomeApplication</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app.version</span><span style=color:#f92672>=</span><span style=color:#e6db74>2.1.0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app.description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Enterprise Application Platform</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Development Mode Switch</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app.debug</span><span style=color:#f92672>=</span><span style=color:#e6db74>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Database Connection Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.host</span><span style=color:#f92672>=</span><span style=color:#e6db74>localhost</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.port</span><span style=color:#f92672>=</span><span style=color:#e6db74>3306</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.username</span><span style=color:#f92672>=</span><span style=color:#e6db74>admin</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.password</span><span style=color:#f92672>=</span><span style=color:#e6db74>secure_password_123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Connection Pool Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.pool.max-size</span><span style=color:#f92672>=</span><span style=color:#e6db74>20</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.pool.min-idle</span><span style=color:#f92672>=</span><span style=color:#e6db74>5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>database.pool.max-wait</span><span style=color:#f92672>=</span><span style=color:#e6db74>30000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Other Configuration Items</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>timeout</span><span style=color:#f92672>=</span><span style=color:#e6db74>30000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>max-connections</span><span style=color:#f92672>=</span><span style=color:#e6db74>100</span>
</span></span></code></pre></div><h3 id=output-file-example-applicationyaml>Output File Example (application.yaml)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># ==========================================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Application Core Configuration</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==========================================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Application Basic Information</span>
</span></span><span style=display:flex><span><span style=color:#f92672>app</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>MyAwesomeApplication</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>version</span>: <span style=color:#ae81ff>2.1.0</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>description</span>: <span style=color:#ae81ff>Enterprise Application Platform</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Development Mode Switch</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>debug</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Database Connection Configuration</span>
</span></span><span style=display:flex><span><span style=color:#f92672>database</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>host</span>: <span style=color:#ae81ff>localhost</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>3306</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>username</span>: <span style=color:#ae81ff>admin</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>password</span>: <span style=color:#ae81ff>secure_password_123</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Connection Pool Configuration</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>pool</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>max-size</span>: <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>min-idle</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>max-wait</span>: <span style=color:#ae81ff>30000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Other Configuration Items</span>
</span></span><span style=display:flex><span><span style=color:#f92672>timeout</span>: <span style=color:#e6db74>&#39;30000&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>max-connections</span>: <span style=color:#e6db74>&#39;100&#39;</span>
</span></span></code></pre></div><h2 id=-function-details>ðŸ”§ Function Details</h2><h3 id=1-type-inference-mechanism>1. Type Inference Mechanism</h3><p>The tool can intelligently identify and maintain the following data types:</p><div class=table-wrapper><table><thead><tr><th>Properties Value</th><th>Inferred Type</th><th>YAML Output</th><th>Description</th></tr></thead><tbody><tr><td><code>true</code>/<code>false</code></td><td>boolean</td><td><code>true</code>/<code>false</code></td><td>Boolean values</td></tr><tr><td><code>8080</code></td><td>integer</td><td><code>8080</code></td><td>Integers</td></tr><tr><td><code>30.5</code></td><td>float</td><td><code>30.5</code></td><td>Floating point numbers</td></tr><tr><td><code>hello</code></td><td>string</td><td><code>hello</code></td><td>Strings</td></tr><tr><td><code>"hello world"</code></td><td>string</td><td><code>hello world</code></td><td>Unquoted strings</td></tr></tbody></table></div><h3 id=2-comment-processing-mechanism>2. Comment Processing Mechanism</h3><h4 id=comment-type-recognition>Comment Type Recognition</h4><ul><li><strong>Associated comments</strong>: Comments immediately preceding configuration items</li><li><strong>Independent comments</strong>: Comment blocks surrounded by blank lines</li><li><strong>File header comments</strong>: Comments at the beginning of the file</li></ul><h4 id=position-maintenance-strategy>Position Maintenance Strategy</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># This is above comment</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>config.value</span><span style=color:#f92672>=</span><span style=color:#e6db74>test</span>
</span></span><span style=display:flex><span><span style=color:#75715e># This is below comment</span>
</span></span></code></pre></div><p>After conversion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># This is above comment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>value</span>: <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span><span style=color:#75715e># This is below comment</span>
</span></span></code></pre></div><h3 id=3-nested-structure-processing>3. Nested Structure Processing</h3><p>Dot-separated key names are automatically converted to YAML nested structures:</p><div class=table-wrapper><table><thead><tr><th>Properties</th><th>YAML</th></tr></thead><tbody><tr><td><code>database.host=localhost</code></td><td><code>database: {host: localhost}</code></td></tr><tr><td><code>spring.datasource.url=jdbc:...</code></td><td><code>spring: {datasource: {url: jdbc:...}}</code></td></tr></tbody></table></div><h3 id=4-order-maintenance-mechanism>4. Order Maintenance Mechanism</h3><ul><li><strong>Strict order</strong>: Completely maintain the key-value pair order in the original properties file</li><li><strong>Hierarchical order</strong>: The hierarchical structure of nested properties also maintains the original order</li><li><strong>Comment order</strong>: The relative position of comments and configuration items is completely maintained</li></ul><h2 id=-advanced-usage>âš™ï¸ Advanced Usage</h2><h3 id=1-batch-processing-script>1. Batch Processing Script</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Batch convert all properties files in current directory</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> file in *.properties; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    python properties_to_yaml.py <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><h3 id=2-integration-into-cicd-pipeline>2. Integration into CI/CD Pipeline</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># Using in GitHub Actions</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Convert Properties to YAML</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>run</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    python properties_to_yaml.py config/*.properties</span>
</span></span></code></pre></div><h3 id=3-import-as-module>3. Import as Module</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> properties_to_yaml <span style=color:#f92672>import</span> parse_properties_content, dump_yaml_with_structure
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Read and convert</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;config.properties&#39;</span>, <span style=color:#e6db74>&#39;r&#39;</span>, encoding<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;utf-8&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    content <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parsed_data <span style=color:#f92672>=</span> parse_properties_content(content)
</span></span><span style=display:flex><span>yaml_result <span style=color:#f92672>=</span> dump_yaml_with_structure(parsed_data)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(yaml_result)
</span></span></code></pre></div><h2 id=-output-format-description>ðŸ“Š Output Format Description</h2><h3 id=generated-file-naming>Generated File Naming</h3><ul><li>Input: <code>application.properties</code></li><li>Output: <code>application.yaml</code></li><li>Save location: Same directory as source file</li></ul><h3 id=yaml-format-characteristics>YAML Format Characteristics</h3><ul><li>Uses 2-space indentation</li><li>Supports UTF-8 encoding</li><li>Maintains clear hierarchical structure</li><li>Comments start with <code>#</code></li></ul><h2 id=-error-handling>ðŸš¨ Error Handling</h2><h3 id=common-errors-and-solutions>Common Errors and Solutions</h3><h4 id=1-file-not-found>1. File Not Found</h4><pre tabindex=0><code>Error: File does not exist - /path/to/config.properties
</code></pre><p><strong>Solution</strong>: Check if the file path is correct</p><h4 id=2-format-error>2. Format Error</h4><pre tabindex=0><code>Warning: Line 5 format is incorrect, skipping: invalid=format=line
</code></pre><p><strong>Solution</strong>: Check properties file format, ensure using <code>=</code> or <code>:</code> separator</p><h4 id=3-insufficient-permissions>3. Insufficient Permissions</h4><pre tabindex=0><code>Error: Permission denied - config.properties
</code></pre><p><strong>Solution</strong>: Check file read/write permissions</p><h2 id=-troubleshooting>ðŸ” Troubleshooting</h2><h3 id=debugging-tips>Debugging Tips</h3><ol><li><strong>View Detailed Output</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python properties_to_yaml.py config.properties
</span></span></code></pre></div><ol start=2><li><strong>Check Generated YAML</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat config.yaml
</span></span></code></pre></div><ol start=3><li><strong>Validate YAML Syntax</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python -c <span style=color:#e6db74>&#34;import yaml; yaml.safe_load(open(&#39;config.yaml&#39;))&#34;</span>
</span></span></code></pre></div><h2 id=-performance-information>ðŸ“ˆ Performance Information</h2><h3 id=processing-capability>Processing Capability</h3><ul><li><strong>Small files</strong> (&lt; 100KB): Instant completion</li><li><strong>Medium files</strong> (100KB-1MB): 1-2 seconds</li><li><strong>Large files</strong> (> 1MB): Usually within 5 seconds depending on content complexity</li></ul><hr><p><strong>Note</strong>: This tool is designed specifically for configuration file conversion and is not suitable for other types of file conversion. It is recommended to backup original files before conversion.</p></section><footer class=article-footer><section class=article-tags><a href=/en/tags/properties/>Properties</a>
<a href=/en/tags/yaml/>YAML</a></section></footer></article><script src=https://giscus.app/client.js data-repo=zg-dd/zg-dd.github.io data-repo-id=R_kgDOQwB7tw data-category=Announcements data-category-id=DIC_kwDOQwB7t84C0WGD data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"preferred_color_scheme":"preferred_color_scheme")}})()</script><footer class=site-footer><section class=copyright>&copy;
2026 å°å·· Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.33.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>
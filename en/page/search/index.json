[{"content":"1. Closures\r1.1 What is a closure?\rA closure is a function combined with the environment that it captures. In Go, closures can access and modify variables defined in their enclosing scopes even after the outer function returns.\n1.2 Closure properties\rA closure can access variables from its outer scope. A closure can modify those outer-scope variables. The variables persist after the outer function exits. 1.3 Closure example\rpackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println(pos(i), neg(-2*i)) } } Each call to adder returns a distinct closure that captures its own sum variable. The output shows two independent sums growing separately.\n2. Types\r2.1 Custom types\rGo lets you define new type names with the type keyword.\n2.2 Type example\rpackage main import \u0026#34;fmt\u0026#34; type addFun func(int) int type selfint int func adder2(x int) addFun { return func(y int) int { return x + y } } func main() { var eg addFun = adder2(10) fmt.Println(eg(15)) var num1 selfint = 10 var num2 int = 20 fmt.Println(num1 + selfint(num2)) fmt.Println(int(num1) + num2) } Output: 25, 30, 30. selfint cannot be mixed with int without conversion.\n3. Defer\r3.1 How defer works\rA defer statement postpones a function call until the surrounding function returns.\n3.2 Defer example\rpackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } Output: hello followed by world because the deferred call runs after main finishes.\n4. Panic and Recover\rpanic is similar to throwing an exception; recover catches it. Go does not have try..catch syntax.\n4.1 Usage\rpanic signals an unrecoverable error. recover captures the panic so the program can continue. 4.2 Example\rpackage main import \u0026#34;fmt\u0026#34; func main() { defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;Recovered from\u0026#34;, r) } }() fmt.Println(\u0026#34;Starting the program\u0026#34;) panic(\u0026#34;Something went wrong!\u0026#34;) fmt.Println(\u0026#34;This line will not run\u0026#34;) } Output: Starting the program and then Recovered from Something went wrong! because the deferred function recovered from the panic.\n5. The time package\rThe time package provides utilities for working with dates and times, including formatting, parsing, duration math, and comparisons.\ncurrentTime := time.Now() fmt.Println(\u0026#34;Current Time:\u0026#34;, currentTime) year := currentTime.Year() month := currentTime.Month() day := currentTime.Day() hour := currentTime.Hour() minute := currentTime.Minute() second := currentTime.Second() fmt.Printf(\u0026#34;Current Time: %d-%02d-%02d %02d:%02d:%02d\\n\u0026#34;, year, month, day, hour, minute, second) fmt.Println(\u0026#34;Formatted:\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) timeStr := \u0026#34;2023-01-01 12:00:00\u0026#34; parsedTime, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err != nil { fmt.Println(\u0026#34;Failed to parse:\u0026#34;, err) return } fmt.Println(\u0026#34;Parsed:\u0026#34;, parsedTime) duration := time.Duration(10) * time.Second fmt.Println(\u0026#34;Duration:\u0026#34;, duration) newTime := currentTime.Add(duration) fmt.Println(\u0026#34;New Time:\u0026#34;, newTime) if currentTime.Before(parsedTime) { fmt.Println(\u0026#34;Current time is before parsed time\u0026#34;) } else if currentTime.After(parsedTime) { fmt.Println(\u0026#34;Current time is after parsed time\u0026#34;) } else { fmt.Println(\u0026#34;Current time equals parsed time\u0026#34;) } if currentTime.Equal(parsedTime) { fmt.Println(\u0026#34;Current time equals parsed time\u0026#34;) } Summary:\ntime.Now() Year/Month/Day/Hour/Minute/Second currentTime.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;) time.Parse(\u0026quot;2006-01-02 15:04:05\u0026quot;, timeStr) time.Duration(10) * time.Second currentTime.Add(duration) currentTime.Before/After/Equal(parsedTime) ","date":"2025-02-13T17:45:37+08:00","permalink":"https://zg-dd.github.io/en/stu/golang_stu_07/","title":"Golang Learning Journey [Part 7: closures, types, defer, panic/recover \u0026 the time package]"},{"content":"1. Map Data Type\rA map is a collection of key-value pairs where each key is unique and maps to a value. Maps are unordered, so iteration order is undefined. A map’s zero value is nil, so you must create it with make before use. Maps are reference types.\n1.1 Declaring and initializing maps\rvar map1 map[string]int map1 = make(map[string]int) map1[\u0026#34;a\u0026#34;] = 1 map1[\u0026#34;b\u0026#34;] = 2 map1[\u0026#34;c\u0026#34;] = 3 var map2 = make(map[string]int) map2[\u0026#34;a\u0026#34;] = 4 map2[\u0026#34;b\u0026#34;] = 5 map2[\u0026#34;c\u0026#34;] = 6 map3 := map[string]int{} map3[\u0026#34;a\u0026#34;] = 7 map3[\u0026#34;b\u0026#34;] = 8 map3[\u0026#34;c\u0026#34;] = 9 var map4 = map[string]int{\u0026#34;a\u0026#34;: 10, \u0026#34;b\u0026#34;: 11, \u0026#34;c\u0026#34;: 12} map5 := map[string]int{\u0026#34;a\u0026#34;: 13, \u0026#34;b\u0026#34;: 14, \u0026#34;c\u0026#34;: 15} var map6 map[string]int var map7 = map[string]int{} fmt.Printf(\u0026#34;map1 type:%T value:%v nil:%v\\n\u0026#34;, map1, map1, map1 == nil) fmt.Printf(\u0026#34;map2 type:%T value:%v nil:%v\\n\u0026#34;, map2, map2, map2 == nil) fmt.Printf(\u0026#34;map3 type:%T value:%v nil:%v\\n\u0026#34;, map3, map3, map3 == nil) fmt.Printf(\u0026#34;map4 type:%T value:%v nil:%v\\n\u0026#34;, map4, map4, map4 == nil) fmt.Printf(\u0026#34;map5 type:%T value:%v nil:%v\\n\u0026#34;, map5, map5, map5 == nil) fmt.Printf(\u0026#34;map6 type:%T value:%v nil:%v\\n\u0026#34;, map6, map6, map6 == nil) fmt.Printf(\u0026#34;map7 type:%T value:%v nil:%v\\n\u0026#34;, map7, map7, map7 == nil) map8 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} fmt.Println(len(map1)) Output:\nmap1 type:map[string]int value:map[a:1 b:2 c:3] nil:false map2 type:map[string]int value:map[a:4 b:5 c:6] nil:false map3 type:map[string]int value:map[a:7 b:8 c:9] nil:false map4 type:map[string]int value:map[a:10 b:11 c:12] nil:false map5 type:map[string]int value:map[a:13 b:14 c:15] nil:false map6 type:map[string]int value:\u0026lt;nil\u0026gt; nil:true map7 type:map[string]int value:map[] nil:false 3 1.2 Iterating over maps\rmap1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} fmt.Println(\u0026#34;1. fori style\u0026#34;) keys := make([]string, 0, len(map1)) for k := range map1 { keys = append(keys, k) } for i := 0; i \u0026lt; len(keys); i++ { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, keys[i], map1[keys[i]]) } fmt.Println(\u0026#34;2. for range style\u0026#34;) for k, v := range map1 { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, k, v) } Output:\n1. fori style key=one value=java key=two value=python key=three value=go 2. for range style key=one value=java key=two value=python key=three value=go 1.3 Map CRUD\rmap1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} map1[\u0026#34;four\u0026#34;] = \u0026#34;php\u0026#34; fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) delete(map1, \u0026#34;one\u0026#34;) fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) map1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; if value, ok := map1[\u0026#34;two\u0026#34;]; ok { fmt.Println(value) } if value1, ok1 := map1[\u0026#34;five\u0026#34;]; ok1 { fmt.Println(value1) } else { fmt.Println(\u0026#34;five does not exist\u0026#34;) } Output:\nmap1: map[four:php three:go two:python] map1: map[three:go two:python] c++ five does not exist 2. Functions\rFunctions are reusable code blocks that implement a specific feature.\nFunctions have the following traits:\nIncrease code reuse and readability, and simplify maintenance. Return values via return, which can send back one or more values. Parameters are defined in a parameter list and can be any type and any count. Local variable scope is limited to inside the function; the outside cannot access them. The parameter list and return values define the function’s interface and contract. 2.1 Various function definitions\rpackage main import \u0026#34;fmt\u0026#34; func sayHello() { fmt.Println(\u0026#34;hello world\u0026#34;) } func sayHello2(name string) { fmt.Println(\u0026#34;hello\u0026#34;, name) } func add(a int, b int) int { return a + b } func add2(a, b int) int { return a + b } func add3(a, b int) (c int) { c = a + b return } func add4(a, b int) (int, int) { return a + b, a - b } func add5(a, b int) (sum, diff int) { sum = a + b diff = a - b return } func add6(a ...int) int { sum := 0 for _, v := range a { sum += v } return sum } func opreate(a, b int, op func(int, int) int) int { return op(a, b) } func add7(a, b int) func() string { f := func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) } return f } func add8(a, b int) func() string { return func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) } } func main() { sayHello() sayHello2(\u0026#34;Zhang San\u0026#34;) fmt.Printf(\u0026#34;add %d\\n\u0026#34;, add(1, 2)) fmt.Printf(\u0026#34;add2 %d\\n\u0026#34;, add2(3, 4)) fmt.Printf(\u0026#34;add3 %d\\n\u0026#34;, add3(5, 6)) sum1, diff1 := add4(7, 8) fmt.Printf(\u0026#34;add4 %d %d\\n\u0026#34;, sum1, diff1) sum2, diff2 := add5(9, 10) fmt.Printf(\u0026#34;add5 %d %d\\n\u0026#34;, sum2, diff2) fmt.Printf(\u0026#34;add6 %d\\n\u0026#34;, add6(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(1, 2, add)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(2, 4, func(i1, i2 int) int { return i1 * i2 })) fmt.Printf(\u0026#34;add7 %s\\n\u0026#34;, add7(1, 2)()) fmt.Printf(\u0026#34;add8 %s\\n\u0026#34;, add8(3, 4)()) } Output:\nhello world hello Zhang San add 3 add2 7 add3 11 add4 15 -3 add5 19 -1 add6 55 opreate 3 opreate 8 add7 1 + 2 = 3 add8 3 + 4 = 7 ","date":"2025-02-11T20:05:09+08:00","permalink":"https://zg-dd.github.io/en/stu/golang_stu_06/","title":"Golang Learning Journey [Part 6: Composite Types – Map \u0026 Function Primer]"},{"content":"1. Operators\r1.1 Arithmetic operators\rSymbol Description + Addition - Subtraction * Multiplication / Division % Modulo Example:\nnum1 := 5 num2 := 3 fmt.Printf(\u0026#34;%v + %v = %v\\n\u0026#34;, num1, num2, num1+num2) fmt.Printf(\u0026#34;%v - %v = %v\\n\u0026#34;, num1, num2, num1-num2) fmt.Printf(\u0026#34;%v * %v = %v\\n\u0026#34;, num1, num2, num1*num2) fmt.Printf(\u0026#34;%v / %v = %v\\n\u0026#34;, num1, num2, num1/num2) fmt.Printf(\u0026#34;%v %% %v = %v\\n\u0026#34;, num1, num2, num1%num2) num2++ fmt.Printf(\u0026#34;After ++: %v \\n\u0026#34;, num2) num2-- fmt.Printf(\u0026#34;After --: %v \\n\u0026#34;, num2) Output:\n5 + 3 = 8 5 - 3 = 2 5 * 3 = 15 5 / 3 = 1 5 % 3 = 2 After ++: 4 After --: 3 Note: Go’s ++ and \u0026ndash; are statements, not expressions, so they cannot be assigned.\n1.2 Comparison operators\rSymbol Description == equal to != not equal to \u0026gt; greater than \u0026gt;= greater than or equal to \u0026lt; less than \u0026lt;= less than or equal to Example:\nnum3, num4 := 8, 6 fmt.Printf(\u0026#34;%v == %v = %v\\n\u0026#34;, num3, num4, num3 == num4) fmt.Printf(\u0026#34;%v != %v = %v\\n\u0026#34;, num3, num4, num3 != num4) fmt.Printf(\u0026#34;%v \u0026gt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt; num4) fmt.Printf(\u0026#34;%v \u0026gt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt;= num4) fmt.Printf(\u0026#34;%v \u0026lt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt; num4) fmt.Printf(\u0026#34;%v \u0026lt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt;= num4) Output:\n8 == 6 = false 8 != 6 = true 8 \u0026gt; 6 = true 8 \u0026gt;= 6 = true 8 \u0026lt; 6 = false 8 \u0026lt;= 6 = false 1.3 Logical operators\rSymbol Description \u0026amp;\u0026amp; logical AND ! logical NOT Example:\nnum5, num6 := 16, 20 fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 \u0026lt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 \u0026amp;\u0026amp; num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 || num6 \u0026lt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 || num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 || num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 || num6 \u0026gt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, !(num5 \u0026lt; 15)) fmt.Printf(\u0026#34;%v\\n\u0026#34;, !(num6 == 20)) Output:\nfalse false true true true true false true false 1.4 Assignment operators\rSymbol Description = Assign += Add and assign -= Subtract and assign *= Multiply and assign /= Divide and assign %= Modulo and assign \u0026laquo;= Left shift and assign \u0026raquo;= Right shift and assign \u0026amp;= Bitwise AND and assign = ^= Bitwise XOR and assign Example:\nnum6, num7 := 3, 6 num7 += num6 fmt.Printf(\u0026#34;num7 += num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 -= num6 fmt.Printf(\u0026#34;num7 -= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 *= num6 fmt.Printf(\u0026#34;num7 *= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 /= num6 fmt.Printf(\u0026#34;num7 /= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 %= num6 fmt.Printf(\u0026#34;num7 %%= num6 result: %v\\n\u0026#34;, num7) Output:\nnum7 += num6 result: 9 num7 -= num6 result: 3 num7 *= num6 result: 18 num7 /= num6 result: 2 num7 %= num6 result: 0 Advanced assignment operators are used in the binary section below.\n1.5 Other operators\rSymbol Description \u0026amp; Address of a variable * Pointer dereference Computers store variables through memory addresses. A pointer holds an address, and dereferencing it gives the stored value.\nExample:\nvar p *int num8 := 100 p = \u0026amp;num8 fmt.Printf(\u0026#34;p address=%v, value=%v\u0026#34;, p, *p) Output:\np address=0xc00000a0d8, value=100 2. Binary operations\rAll binary operations below operate on binary digits.\nSymbol Description \u0026amp; bitwise AND ^ bitwise XOR \u0026laquo; left shift \u0026raquo; right shift |p | q | p\u0026amp;q | p|q | p^q | |\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;| | 0 | 0 | 0 | 0 | 0 | | 1 | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 0 |\n\u0026amp; yields a 1 only if both bits are 1; | yields 0 only if both bits are 0; ^ yields 1 when bits differ; \u0026laquo; shifts left (fills with 0); \u0026raquo; shifts right (discards bits). Binary ops are useful for fast hardware-level control, such as address or IP manipulation.\nExample:\nvar num1 = 0b101011 var num2 = 0b110001 fmt.Printf(\u0026#34;%b \u0026amp; %b = %b \\n\u0026#34;, num1, num2, num1\u0026amp;num2) fmt.Printf(\u0026#34;%b | %b = %b \\n\u0026#34;, num1, num2, num1|num2) fmt.Printf(\u0026#34;%b ^ %b = %b \\n\u0026#34;, num1, num2, num1^num2) fmt.Printf(\u0026#34;%b \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, num1, 2, num1\u0026lt;\u0026lt;2) fmt.Printf(\u0026#34;%b \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, num2, 2, num2\u0026gt;\u0026gt;2) num2 = 0b110001 num2 \u0026amp;= num1 fmt.Printf(\u0026#34;num2 \u0026amp;= num1: %b \\n\u0026#34;, num2) num2 = 0b110001 num2 |= num1 fmt.Printf(\u0026#34;num2 |= num1: %b \\n\u0026#34;, num2) num2 = 0b110001 num2 ^= num1 fmt.Printf(\u0026#34;num2 ^= num1: %b \\n\u0026#34;, num2) num1 = 0b110001 num1 \u0026lt;\u0026lt;= 2 fmt.Printf(\u0026#34;num1 \u0026lt;\u0026lt;= 2: %b \\n\u0026#34;, num1) num2 = 0b110001 num2 \u0026gt;\u0026gt;= 2 fmt.Printf(\u0026#34;num2 \u0026gt;\u0026gt;= 2: %b \\n\u0026#34;, num2) Output:\n101011 \u0026amp; 110001 = 100001 101011 | 110001 = 111011 101011 ^ 110001 = 11010 101011 \u0026lt;\u0026lt; 2 = 10101100 110001 \u0026gt;\u0026gt; 2 = 1100 100001 111011 11010 11000100 1100 \u0026amp; and | can also toggle flags. For example, treat a 5-bit binary value as seat occupancy (0=free, 1=occupied). Using masks you can clear or set specific bits:\nvar seat = 0b10011 var mask1 = 0b01010 fmt.Printf(\u0026#34;clear positions 1,3,5: %b \\n\u0026#34;, seat\u0026amp;mask1) var mask2 = 0b01010 fmt.Printf(\u0026#34;set positions 2,4: %b \\n\u0026#34;, seat|mask2) Output:\nclear positions 1,3,5: 10 set positions 2,4: 11011 The same mask 01010 can support multiple scenarios such as traffic lights or switches that toggle opposite settings.\n3. Control Flow\r3.1 if statements\rThe program evaluates conditions sequentially and executes only the first matching block.\nscore := 60 if score \u0026gt;= 90 { fmt.Println(\u0026#34;Outstanding\u0026#34;) } else if score \u0026gt;= 80 { fmt.Println(\u0026#34;Excellent\u0026#34;) } else if score \u0026gt;= 70 { fmt.Println(\u0026#34;Good\u0026#34;) } else if score \u0026gt;= 60 { fmt.Println(\u0026#34;Pass\u0026#34;) } else { fmt.Println(\u0026#34;Fail\u0026#34;) } if score1 := 80; score1 \u0026gt;= 90 { fmt.Println(\u0026#34;Outstanding\u0026#34;) } else if score1 \u0026gt;= 80 { fmt.Println(\u0026#34;Excellent\u0026#34;) } else if score1 \u0026gt;= 70 { fmt.Println(\u0026#34;Good\u0026#34;) } else if score1 \u0026gt;= 60 { fmt.Println(\u0026#34;Pass\u0026#34;) } else { fmt.Println(\u0026#34;Fail\u0026#34;) } fmt.Println(strconv.Itoa(score)) Output:\nPass Excellent 80 3.2 for loops\rvar str = \u0026#34;hello world\u0026#34; for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) } fmt.Println() i := 0 for i \u0026lt; len(str) { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } fmt.Println() i = 0 for { if i \u0026gt;= len(str) { break } fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } Output:\nh e l l o w o r l d h e l l o w o r l d h e l l o w o r l d 3.3 for range (key/value loop)\rtext := \u0026#34;你好,program\u0026#34; for k, v := range text { fmt.Printf(\u0026#34;k=%v,v=%c\\n\u0026#34;, k, v) } Output:\nk=0,v=你 k=3,v=好 k=6,v=, k=7,v=p k=8,v=r k=9,v=o k=10,v=g k=11,v=r k=12,v=a k=13,v=m 3.4 switch\u0026hellip;case\rswitch is typically used for enums or discrete choices.\nvar week = 3 switch week { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } switch week1 := 0; week1 { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } switch num := 10; num { case 0, 2, 4, 6, 8, 10: fmt.Println(\u0026#34;Even\u0026#34;) case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;Odd\u0026#34;) } score := 80 switch { case score \u0026gt;= 90: fmt.Println(\u0026#34;Outstanding\u0026#34;) case score \u0026gt;= 80: fmt.Println(\u0026#34;Excellent\u0026#34;) case score \u0026gt;= 70: fmt.Println(\u0026#34;Good\u0026#34;) case score \u0026gt;= 60: fmt.Println(\u0026#34;Pass\u0026#34;) default: fmt.Println(\u0026#34;Fail\u0026#34;) } Output:\nWednesday Unknown Even Excellent Go’s switch/case automatically breaks after executing a matching case. Use fallthrough to continue to the next case.\nswitch week1 := 5; week1 { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) fallthrough case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } Output:\nFriday Saturday 3.5 break, continue, goto\rbreak exits the current loop. continue skips to the next iteration. goto jumps to a labeled statement. lable1: for i := 0; i \u0026lt;= 3; i++ { if i == 0 { continue } if i == 1 { continue lable1 } fmt.Printf(\u0026#34;i=%d \\n\u0026#34;, i) } lable2: for j := 0; j \u0026lt;= 3; j++ { if j == 3 { fmt.Printf(\u0026#34;break loop\\n\u0026#34;) break } if j == 1 { break lable2 } fmt.Printf(\u0026#34;j=%d \\n\u0026#34;, j) } i := 0 lable3: fmt.Println(\u0026#34;statement 1\u0026#34;) i++ if i == 2 { goto lable5 } goto lable4 fmt.Println(\u0026#34;statement 2\u0026#34;) lable4: fmt.Println(\u0026#34;statement 3\u0026#34;) goto lable3 lable5: fmt.Println(\u0026#34;statement 4\u0026#34;) Output:\ni=2 i=3 j=0 statement 1 statement 3 statement 1 statement 4 ","date":"2025-01-01T11:03:08+08:00","permalink":"https://zg-dd.github.io/en/stu/golang_stu_04/","title":"Golang Learning Journey [Part 4: Operators \u0026 Control Flow]"},{"content":"1. Overview\rGo data types are split into basic types and composite types.\nBasic types include integers, floating-point numbers, booleans, and strings. Composite types include arrays, slices, structs, functions, maps, channels, interfaces, etc.\n2. Basic Data Types\r2.1 Integers\rType Range Size Signed? int8 $-2^7$~$2^7-1$ 1 byte Yes int16 $-2^{15}$~$2^{15}-1$ 2 bytes Yes int32 $-2^{31}$~$2^{31}-1$ 4 bytes Yes int64 $-2^{63}$~$2^{63}-1$ 8 bytes Yes uint8 $0$~$2^8-1$ 1 byte No uint16 $0$~$2^{16}-1$ 2 bytes No uint32 $0$~$2^{32}-1$ 4 bytes No uint64 $0$~$2^{64}-1$ 8 bytes No Special integer types:\nType Description uint 32-bit on 32-bit OS, 64-bit on 64-bit OS int 32-bit on 32-bit OS, 64-bit on 64-bit OS uintptr Unsigned integer used to store pointer values Example:\nvar ( num1 int = 666 num2 uint = 666 num3 int8 = math.MaxInt8 num4 int16 = math.MaxInt16 num5 int32 = math.MaxInt32 num6 int64 = math.MaxInt64 num7 uint8 = math.MaxUint8 num8 uint16 = math.MaxUint16 num9 uint32 = math.MaxUint32 num10 uint64 = math.MaxUint64 ) fmt.Println(num1, num2, num3, num4, num5, num6, num7, num8, num9, num10) Output:\n666 666 127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615 2.2 Floating-point numbers\rGo provides float32 and float64 following IEEE 754. On 32-bit systems the default is float32; on 64-bit systems it is float64.\nfloat32: range of -3.4e38 to 3.4e38, uses 4 bytes float64: range of -1.8e308 to 1.8e308, uses 8 bytes var num1 float32 = 1.06 num2 := 3.1415926 fmt.Printf(\u0026#34;Exact: %v; default 6 decimals: %f; fixed 3 decimals: %0.3f \\n\u0026#34;, num1, num2, num2) var ( num3 float32 = 3.1415926 num4 float64 = 1.113 num5 = 3.14e2 num6 = 3.14e-2 ) fmt.Println(num3, num4, num5, num6) Output:\nExact: 1.06; default 6 decimals: 3.141593; fixed 3 decimals: 3.142 3.1415925 1.113 314 0.0314 2.3 Booleans\rbool only has two values: true and false. Uninitialized booleans default to false.\nvar ( bool1 bool bool2 = true ) fmt.Println(bool1, bool2) Output:\nfalse true 2.4 Characters\rCharacters are single values and are represented as ints. Go exposes them via byte (ASCII) and rune (UTF-8).\nbyte: an alias for int representing ASCII values rune: an alias for int representing UTF-8 code points Note: UTF-8 is the universal encoding that extends ASCII to cover characters from multiple languages.\nvar a = \u0026#39;A\u0026#39; fmt.Printf(\u0026#34;ASCII: %v; Char: %c \\n\u0026#34;, a, a) var ( b = \u0026#39;B\u0026#39; c = \u0026#39;你\u0026#39; d = \u0026#34;this\u0026#34; ) fmt.Printf(\u0026#34;%c,%c,%c,%c,%c,%c\u0026#34;, b, c, d[0], d[1], d[2], d[3]) Output:\nASCII: 65; Char: A B,你,t,h,i,s 2.4 Strings\r2.4.1 Common definitions\rvar val1 string = \u0026#34;hello world\u0026#34; var val2 = \u0026#34;你好 go\u0026#34; val3 := \u0026#34;Good\u0026#34; fmt.Println(val1, val2, val3) fmt.Println(len(val2)) var info = `姓名：张三 年龄：18` fmt.Println(info) Output:\nhello world 你好 go Good 9 姓名：张三 年龄：18 In strings, ASCII letters occupy one byte and Chinese characters occupy three bytes. Use len to get the byte length.\n2.4.2 Escape characters\rEscape sequences start with \\. Common ones include:\n\\r: carriage return (moves to the beginning of the line) \\n: newline (moves to the next line) \\t: tab (helps align output) \\': single quote \\\u0026quot;: double quote \\\\: backslash var val1 string = \u0026#34;hello\\r\u0026#34; var val2 string = \u0026#34;world\\n\u0026#34; var val3 string = \u0026#34;hello world\\t\u0026#34; var val4 string = \u0026#34;\u0026#39;hello\u0026#39; \\\\ \\\u0026#34;world\\\u0026#34;\u0026#34; fmt.Println(val1, val2, val3, val4) Output:\nworld hello world \u0026#39;hello\u0026#39; \\ \u0026#34;world\u0026#34; 2.4.3 Common string methods\rMost method names are intuitive and shared across languages.\nMethod Description len length + or fmt.Sprint concatenation strings.Split split string strings.Contains check substring strings.HasPrefix / HasSuffix prefix/suffix test strings.Index / LastIndex find substring index strings.Join join slice into string strings.ToLower lowercase strings.ToUpper uppercase Example:\nvar val = \u0026#34;Hello World\u0026#34; length := len(val) fmt.Printf(\u0026#34;%s length: %d\\n\u0026#34;, val, length) str1 := val + \u0026#34;小明\u0026#34; str2 := fmt.Sprint(val, \u0026#34;小红\u0026#34;) fmt.Printf(\u0026#34;+ concat: %s; Sprint concat: %s \\n\u0026#34;, str1, str2) splitVal := strings.Split(val, \u0026#34; \u0026#34;) newStr := strings.Join(splitVal, \u0026#34;,\u0026#34;) fmt.Printf(\u0026#34;split: %v; Join result: %s \\n\u0026#34;, splitVal, newStr) bool1 := strings.Contains(val, \u0026#34;Hello\u0026#34;) bool2 := strings.Contains(val, \u0026#34;olleH\u0026#34;) fmt.Printf(\u0026#34;contains Hello: %v; contains olleH: %v \\n\u0026#34;, bool1, bool2) bool3 := strings.HasPrefix(val, \u0026#34;He\u0026#34;) bool4 := strings.HasPrefix(val, \u0026#34;llo\u0026#34;) bool5 := strings.HasSuffix(val, \u0026#34;World\u0026#34;) bool6 := strings.HasSuffix(val, \u0026#34;Wor\u0026#34;) fmt.Printf(\u0026#34;prefix He: %v; prefix llo: %v; suffix World: %v; suffix Wor: %v \\n\u0026#34;, bool3, bool4, bool5, bool6) index1 := strings.Index(val, \u0026#34;o\u0026#34;) index2 := strings.LastIndex(val, \u0026#34;o\u0026#34;) index3 := strings.Index(val, \u0026#34;a\u0026#34;) fmt.Printf(\u0026#34;o first index: %v; o last index: %v; a index: %v\\n\u0026#34;, index1, index2, index3) str3 := strings.ToLower(val) str4 := strings.ToUpper(val) fmt.Printf(\u0026#34;lower: %v; upper: %v\\n\u0026#34;, str3, str4) Output:\nHello World length: 11 + concat: Hello World小明; Sprint concat: Hello World小红 split: [Hello World]; Join result: Hello,World contains Hello: true; contains olleH: false prefix He: true; prefix llo: false; suffix World: true; suffix Wor: false o first index: 4; o last index: 7; a index: -1 lower: hello world; upper: HELLO WORLD Tip: len, split, contains, prefix, suffix, index, join, lower, upper have similar meanings across languages. Learning one makes the rest easier.\n2.4.4 Mutating a string via slices\rvar val1 = \u0026#34;hello xioaming\u0026#34; byteStr := []byte(val1) byteStr[0] = \u0026#39;a\u0026#39; fmt.Println(string(byteStr)) var val2 = \u0026#34;你好小明\u0026#34; runeStr := []rune(val2) runeStr[0] = \u0026#39;我\u0026#39; fmt.Println(string(runeStr)) Output:\naello xioaming 我好小明 3. Type Conversion\rNumeric conversion goes both ways: low-precision to high-precision and vice versa. Warning: converting from high to low precision can drop data because of differences in range.\n3.1 Integer-to-integer conversions\rvar a int8 = 127 b := int64(a) fmt.Printf(\u0026#34;a=%v, type: %T\\tb=%v, type: %T \\n\u0026#34;, a, a, b, b) var c int64 = 127 d := int16(c) fmt.Printf(\u0026#34;c=%v, type: %T\\td=%v, type: %T \\n\u0026#34;, c, c, d, d) Output:\na=127, type: int8 b=127, type: int64 c=127, type: int64 d=127, type: int16 3.2 Floating-point and integer conversions\rvar e int16 = 256 f := float32(e) fmt.Printf(\u0026#34;e=%v, type: %T\\tf=%v, type: %T \\n\u0026#34;, e, e, f, f) var g float64 = 3.145 h := int16(g) fmt.Printf(\u0026#34;g=%v, type: %T\\th=%v, type: %T \\n\u0026#34;, g, g, h, h) Output:\ne=256, type: int16 f=256, type: float32 g=3.145, type: float64 h=3, type: int16 3.3 Other type to string conversion via fmt\rvar ( intV = 123 floatV = 3.145 boolV = true charV = \u0026#39;A\u0026#39; ) str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, intV) str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, floatV) str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, boolV) str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, charV) fmt.Println(str1, str2, str3, str4) Output:\n123 3.145000 true A 3.4 strconv helpers\r3.4.1 strconv.Atoi and strconv.Itoa\rTip: in Itoa the leading i stands for int -\u0026gt; string. In Atoi the trailing i stands for string -\u0026gt; int.\nvar str = \u0026#34;123\u0026#34; num1, _ := strconv.Atoi(str) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, num1, num1) var num2 int64 = 456 str2 := strconv.Itoa(int(num2)) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str2, str2) Output:\nvalue: 123 type: int value: 456 type: string 3.4.2 strconv.ParseX functions\rstrconv.Parse performs conversions only if the source is valid.\nvar ( str1 = \u0026#34;256\u0026#34; str2 = \u0026#34;3.145\u0026#34; str3 = \u0026#34;true\u0026#34; ) num1, _ := strconv.ParseInt(str1, 10, 0) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, num1, num1) num2, _ := strconv.ParseFloat(str2, 32) fmt.Printf(\u0026#34;value: %0.3f\\ttype: %T\\n\u0026#34;, num2, num2) boo, _ := strconv.ParseBool(str3) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, boo, boo) Output:\nvalue: 256 type: int64 value: 3.145 type: float64 value: true type: bool 3.4.3 strconv.FormatX functions\rvar ( intV = 123 floatV = 3.145e2 booV = true ) str1 := strconv.FormatInt(int64(intV), 10) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str1, str1) str2 := strconv.FormatFloat(floatV, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str2, str2) str3 := strconv.FormatBool(booV) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str3, str3) Output:\nvalue: 123 type: string value: 314.5 type: string value: true type: string 3.4.4 Other helpers\rstrconv also includes helpers like Append (to append to byte slices), IsPrint, IsGraphic, Quote, Unquote, and CanBackquote. Study them when needed; this reference is handy.\n","date":"2024-12-21T19:37:51+08:00","permalink":"https://zg-dd.github.io/en/stu/golang_stu_03/","title":"Golang Learning Journey [Part 3: Basic Data Types and Type Conversion]"},{"content":" Preface: Packages in Go are collections of functionality provided either by the standard library or by custom code. You need to import a package before using it—for today we focus on the fmt package, imported with import \u0026quot;fmt\u0026quot;.\n1. fmt Package\rThe fmt package is a widely used standard library module that handles formatted I/O, similar to printf and scanf in C. It lets you read input and display formatted data to stdout or to other writers.\n1.1 Printing\rPrinting in Go is handled by functions whose names start with Print. Print writes without inserting a newline, Println appends a newline, and Printf allows formatted printing.\n1.1.1 fmt.Print\r// package declaration: think of it as a folder package main // import statement: bring in the fmt package import \u0026#34;fmt\u0026#34; // main function: entry point func main() { fmt.Print(\u0026#39;C\u0026#39;) // prints a rune; single quotes are flexible fmt.Print(\u0026#34;a\u0026#34;) // prints a string fmt.Print(\u0026#34;Hello World\u0026#34;) // prints a string in double quotes fmt.Print(123) // prints an integer fmt.Print(3.1415926) // prints a float fmt.Print(true) // prints a boolean } Output:\n67aHello World1233.1415926true Summary: Print can print anything. Note that 'C' prints the ASCII value 67 because single quotes denote a rune literal; double quotes produce a string. Writing 'ABC' would trigger the error more than one character in rune literal because rune literals must be a single character.\n1.1.2 fmt.Println\rIf you switch to Println, each call adds a newline. From now on only the relevant code is shown.\nfmt.Println(\u0026#39;C\u0026#39;) fmt.Println(\u0026#34;a\u0026#34;) fmt.Println(\u0026#34;Hello World\u0026#34;, \u0026#34;你好\u0026#34;) fmt.Println(123) fmt.Println(3.1415926) fmt.Println(true) Result:\n67 a Hello World 你好 123 3.1415926 true 1.1.3 fmt.Printf\rPrintf allows you to control the formatting with verbs. Common verbs:\nVerb Description Importance (personal view) %T print the variable type high %v print with the default format high %t print true/false high %b print binary high %c print the Unicode character low %d print decimal high %o print octal high %x print lowercase hexadecimal high %X print uppercase hexadecimal low %U Unicode format low %f decimal floating-point high %e scientific notation with lowercase e low %E scientific notation with uppercase E low %g automatically choose %f or %e high %s plain string high %q double-quoted string or character low %p pointer address low Example:\nfmt.Printf(\u0026#34;Boolean value: %t \\n\u0026#34;, false) fmt.Printf(\u0026#34;Unicode 65: %c \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Default format 65: %v \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Binary 65: %b \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Decimal 65: %d \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Octal 65: %o \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Hex (lower) 1024: %x \\n\u0026#34;, 1024) fmt.Printf(\u0026#34;Hex (upper) 1024: %X \\n\u0026#34;, 1024) fmt.Printf(\u0026#34;\u0026#39;C\u0026#39; Unicode: %U \\n\u0026#34;, \u0026#39;C\u0026#39;) fmt.Printf(\u0026#34;Float: %f \\n\u0026#34;, 3.1415926) fmt.Printf(\u0026#34;Scientific (lower): %e \\n\u0026#34;, 3.1415926) fmt.Printf(\u0026#34;Scientific (upper): %E \\n\u0026#34;, 3.1415926) Output:\nBoolean value: false Unicode 65: A Default format 65: 65 Binary 65: 1000001 Decimal 65: 65 Octal 65: 101 Hex (lower) 1024: 400 Hex (upper) 1024: 400 \u0026#39;C\u0026#39; Unicode: U+0043 Float: 3.141593 Scientific (lower): 3.141593e+00 Scientific (upper): 3.141593E+00 1.2 Input (Scan)\rScan captures raw input; the f suffix (ScanF) enables formatting.\n1.2.1 fmt.Scan\rExample:\nvar name string var age int fmt.Print(\u0026#34;请输入姓名和年龄：\u0026#34;) fmt.Scan(\u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) Result:\n请输入姓名和年龄：张三 18 name=张三,age=18 1.2.2 fmt.Scanf\rExample:\nvar name string var age int fmt.Print(\u0026#34;请输入姓名和年龄：\u0026#34;) fmt.Scanf(\u0026#34;%s %d\u0026#34;, \u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) Run several times to see Go\u0026rsquo;s flexibility for beginners:\nPS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 18 name=张三,age=18 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 李四 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 李四 18 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 18 李四 name=张三,age=18 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：18 张三 name=18,age=0 PS F:\\go_project\u0026gt; 2. Variables\rVariables are containers for data and can hold any type of value. Variable names must consist of letters, digits, and underscores, and cannot start with a digit. Keywords and reserved words cannot be used as variable names.\n2.1 Variable declaration\rDeclare a variable by defining it. Several options exist:\nvar a string var b = \u0026#34;张三\u0026#34; fmt.Printf(\u0026#34;a=%v,b=%v\u0026#34;, a, b) Output:\na=,b=张三 Default values:\nvar a string var b int var c bool var d float32 fmt.Printf(\u0026#34;a=%v, b=%v, c=%v, d=%v\u0026#34;, a, b, c, d) Output:\na=, b=0, c=false, d=0 Tip: Declared variables must be used; otherwise Go reports declared and not used.\n2.2 Initialization and assignment\rvar name string name = \u0026#34;张三\u0026#34; var age = 18 sex := \u0026#34;男\u0026#34; score := 80 fmt.Print(name, age, sex, score) Result:\n张三18男80 2.2 Declaring multiple variables\rvar a1, a2, a3 string a1 = \u0026#34;张三\u0026#34; a2 = \u0026#34;李四\u0026#34; a3 = \u0026#34;王五\u0026#34; fmt.Println(a1, a2, a3) var ( name string age int ) name = \u0026#34;赵六\u0026#34; age = 20 fmt.Println(name, age) var ( num1 = 1 num2 = 2 ) fmt.Println(num1, num2) num3, num4, num5 := 3, 4, \u0026#34;Hello\u0026#34; fmt.Println(num3, num4, num5) Result (Println automatically adds spaces and a newline):\n张三 李四 王五 赵六 20 1 2 3 4 Hello var is used for global definitions, while := can only be used locally.\n2.3 Anonymous variables\rAnonymous variables discard values using _ and do not occupy namespace.\nExample:\npackage main import \u0026#34;fmt\u0026#34; func getUserInfo() (string, int) { return \u0026#34;zhangsan\u0026#34;, 10 } func main() { var name, age = getUserInfo() fmt.Println(name, age) var _, age1 = getUserInfo() fmt.Println(age1) var name1, _ = getUserInfo() fmt.Println(name1) } Result:\nzhangsan 10 10 zhangsan Anonymous variables can be reused because they do not reserve names, but using var or := requires unique names.\n3. Constants\rVariables change over time; constants never do. Use const to declare them.\n3.1 Declaring constants\rconst A = \u0026#34;TEST1\u0026#34; fmt.Println(A) const ( B = \u0026#34;TEST2\u0026#34; C = \u0026#34;TEST3\u0026#34; D = \u0026#34;TEST4\u0026#34; ) fmt.Println(B, C, D) const ( E = \u0026#34;TEST5\u0026#34; F G H = \u0026#34;TEST6\u0026#34; I ) fmt.Println(E, F, G, H, I) Output:\nTEST1 TEST2 TEST3 TEST4 TEST5 TEST5 TEST5 TEST6 TEST6 3.2 iota counter\riota is a counter used together with const.\nconst ( n1 = iota n2 _ n3 n4 = iota n5 n6 = 100 n7 = iota n8, n9, n10 = iota, iota, iota + 1 ) fmt.Println(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10) Output:\n0 1 3 4 5 100 7 8 8 9 4. Summary: Variable and constant naming rules\rVariable names may contain letters, digits, and underscores. Identifiers cannot begin with a digit. Identifiers cannot be reserved keywords (var, if, for, etc.). Names are case-sensitive: name, Name, NAme, and NAME are different. Choose descriptive names. CamelCase is preferred; for example maxAge. Acronyms such as DNS or IP can stay uppercase. ","date":"2024-12-21T19:36:53+08:00","permalink":"https://zg-dd.github.io/en/stu/golang_stu_02/","title":"Golang Learning Journey [Part 2: fmt Package and Variables/Constants]"},{"content":" Preface: Go (also called Golang) is an open-source programming language developed by Google and first released publicly in 2009. It aims to provide concise, efficient, and reliable tools for software development. Golang is statically typed and compiled, and it is expressive thanks to its concurrency features. Programs written in Go can make very effective use of multi-core and networked computers, and its novel type system keeps the code modular and flexible. Compiling Go code to machine code is fast, and the language also offers convenient garbage collection plus a powerful reflection runtime.\nNotes from this journey: I will supplement this section after finishing the lessons.\n1. Learning Resources\rChinese documentation: https://go.p2hp.com/ 【Not recommended—lagging behind the official docs】\nOfficial documentation: https://go.dev/ 【Recommended—the latest, in English】\nPractice while learning: Chinese tour | English tour\nBilibili study video\n2. Installing Go on Windows\r2.1 Installation\rFollow the screenshots below step by step: Click the arrow to download the installer and follow the prompts. Note: Developers typically avoid installing the newest release because it may have bugs, but the latest version is fine for learning. Double-click the downloaded go1.23.4.windows-amd64.msi file to install.\n2.2 Verification\rWindows environment variables tutorial You can also verify the Go installation via commands:\nPress Win + R, type cmd, and press Enter. Run the following commands:\n# Go version go version # Go environment go env Tip: If you accidentally left-click and see the terminal highlighted (pay attention to the selection indicator in the top-left), the cmd window is paused. Right-click to release and continue. 3. Development Environment—VsCode\r3.1 Installing VsCode\rDownload VsCode After downloading, extract the archive and be sure to click “Extract” or “Extract to \u0026quot;VsCode-win***\u0026quot;”; otherwise the files scatter across the current directory. Place the extracted folder anywhere you like on your chosen drive.\nClick “Extract” to proceed: Put a shortcut on the desktop. Open the software and review the quick overview. 3.2 Install Extensions\r3.2.1 Language localization extension\r3.2.2 Go extension\rInstall the Go extension in the same way. 4. Hello World Walkthrough\r4.1 Create the project\rOpen the project folder in VsCode. When prompted, trust the author. 4.2 Create the project file\r4.3 Write the Hello World program\r// package declaration: Think of it as a folder package main // import: usually brings in standard library or custom packages import \u0026#34;fmt\u0026#34; // main function: the entry point func main() { // Print the Hello World string; semicolons are optional fmt.Println(\u0026#34;Hello World\u0026#34;) } 4.4 Fix VsCode code suggestions\rOpen a cmd terminal and configure the Go proxy:\ngo env -w GOPROXY=https://goproxy.io/ Restart VsCode a few times until the tools finish installing and code completion works. 4.5 Run the program\rOpen a terminal (it is just the Windows cmd window) and run the Go file:\n# run a Go file go run main.go # output # Hello World 4.6 Build the executable\r# compile the Go file into an executable go build main.go After the build you can double-click the exe to run it. Tip: The program exits immediately after finishing, so the terminal window closes at once, which makes it look like nothing happened.\n","date":"2024-12-21T10:51:49+08:00","permalink":"https://zg-dd.github.io/en/stu/golang_stu_01/","title":"Golang Learning Journey [Part 1: Getting Started]"},{"content":"Regex Concepts\r[] Use [] to match a single character inside the brackets. For example, [abc] matches any one of a, b, or c. In the string \u0026ldquo;abcdabcdbd\u0026rdquo; it matches a, b, c, a, b, c, b. It matches one character at a time and does not merge them. [abc]+ means one or more occurrences of any character in a, b, c. In the same string it matches abc, abc, b. In other words, it matches any of a, b, c one or more times, and consecutive matches are grouped as one string.\n\\ \\ is the escape character. Common escapes include \\n (newline), \\t (tab), \\r (carriage return), \\b (backspace), \\f (form feed), \\v (vertical tab), ' (single quote), \u0026quot; (double quote), and \\ (backslash). Regex has many other symbols; the image below lists them. Important: In regex, some escapes like \\b, \\f, \\n, \\t, \\r, ' can be written directly, e.g. regex=\u0026quot;\\n\u0026quot;; that matches a newline. regex=\u0026quot;\\\\n\u0026quot; also matches a newline. But for symbols like \\w, \\W, \\B, \\S, \\s, you must write regex=\u0026quot;\\\\w\u0026quot; to be valid; otherwise it fails. When you copy these escapes, \\ is often automatically doubled. So I recommend using \\\\ when you need a literal backslash in regex. Note: Not every escape needs to be doubled. For example, to match a double quote, you should not write regex=\u0026quot;\\\u0026quot;\u0026quot;. That would be interpreted incorrectly. Use regex=\u0026quot;\\\\\u0026quot;\u0026quot;. Using regex=\u0026quot;\u0026quot;\u0026quot; also works. If you want to match a backslash itself, in Java you would write regex=\u0026quot; \\\\\\\\ \u0026ldquo; (four backslashes). The first two represent the escape for , and the last two represent another literal \\ (this is my understanding; the expression is correct). By the same logic, to match \\, you would write regex=\u0026rdquo; \\\\\\\\\\\\\\ \u0026ldquo;.\n| This symbol means OR. For x|y, it matches x or y. The | operator has higher precedence than x,y. For regex = \u0026ldquo;[a][b]|[c][d]\u0026rdquo;, it matches \u0026ldquo;ab\u0026rdquo; or \u0026ldquo;cd\u0026rdquo;, not \u0026ldquo;a(b|c)d\u0026rdquo;.\n?\u0026lt;= and ?= These are lookaround tokens. They match a symbol without including it in the result. Example: to extract the text inside double quotes, for String str = \u0026ldquo;he says,\\\u0026ldquo;Hello,Java!\\\u0026rdquo; \u0026ldquo;; You can use: regex = \u0026ldquo;(?\u0026lt;=\\\u0026quot;)[^\\\u0026quot;]+(?=\\\u0026quot;)\u0026rdquo;. Here, (?\u0026lt;=\\\u0026rdquo;) matches a quote but does not include it, [^\\\u0026rdquo;]+ matches one or more non-quote characters, and (?=\\\u0026rdquo;) matches the closing quote without including it. These two are usually used together: one before and one after.\nNote: The single and double quotes above are English quotes. Some symbols may appear as Chinese punctuation due to escaping; keep that in mind when reading. That is all for now; I will add more later if I find new points.\nRegex Symbol Table\r","date":"2020-04-27T18:00:00+08:00","permalink":"https://zg-dd.github.io/en/stu/regular/","title":"Regex Basics: Common Symbols Explained ([] \\\\ | (?\u003c=))"}]
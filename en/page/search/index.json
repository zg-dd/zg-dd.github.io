[{"content":"Overview\rDelve (dlv) is the official Go debugger, designed for Go‚Äôs concurrency model and runtime. It is the most widely used and powerful debugger in the Go ecosystem.\nInstallation\rRecommended install\rInstall the latest version using Go modules:\ngo install github.com/go-delve/delve/cmd/dlv@latest Verify\rAfter installation:\ndlv version If $GOPATH/bin is not in your PATH, add it or use the full path:\n~/go/bin/dlv version Core capabilities\rBreakpoints at specific lines or functions Step execution (line-by-line or into functions) Variable inspection and complex structure viewing Goroutine management (inspect and switch) Runtime variable changes for testing Call stack inspection Basic usage\rExample code\rCreate main.go:\npackage main import \u0026#34;fmt\u0026#34; func main() { message := \u0026#34;Hello, Delve!\u0026#34; fmt.Println(message) result := add(23, 19) fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) } func add(a, b int) int { sum := a + b return sum } Start a debug session\rMode 1: Debug source\rdlv debug main.go Mode 2: Debug binary\rgo build -o myapp main.go dlv exec ./myapp Mode 3: Attach to running process\r# Build and run go build -gcflags=\u0026#34;all=-N -l\u0026#34; -o myapp main.go ./myapp \u0026amp; # Attach PID=$! dlv attach $PID Common commands\rBreakpoint management\rCommand Alias Description break main.main b main.main break at main() break main.go:10 b main.go:10 break at line 10 breakpoints bp list breakpoints clear 1 - remove breakpoint #1 clearall - remove all breakpoints Execution control\rCommand Alias Description continue c continue to next breakpoint next n step over step s step into stepout so step out restart r restart program Variables \u0026amp; expressions\rCommand Alias Description print message p message print a variable locals - list locals args - list function args Other commands\rCommand Alias Description stack bt show call stack goroutines - list goroutines goroutine 1 g 1 switch goroutine exit q quit Full session example\r$ dlv debug main.go Type \u0026#39;help\u0026#39; for list of commands. # Set breakpoints (dlv) b main.main Breakpoint 1 set at 0x... for main.main() ./main.go:5 (dlv) b main.go:11 Breakpoint 2 set at 0x... for main.main() ./main.go:11 # Continue (dlv) c \u0026gt; main.main() ./main.go:5 (hits goroutine(1):1 total:1) (PC: 0x...) 1: package main 2: 3: import \u0026#34;fmt\u0026#34; 4: =\u0026gt; 5: func main() { 6: message := \u0026#34;Hello, Delve!\u0026#34; 7: fmt.Println(message) 8: result := add(23, 19) 9: fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) 10: } # Step (dlv) n \u0026gt; main.main() ./main.go:6 (PC: 0x...) 5: func main() { =\u0026gt; 6: message := \u0026#34;Hello, Delve!\u0026#34; 7: fmt.Println(message) 8: result := add(23, 19) 9: fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) 10: } # Inspect (dlv) p message \u0026#34;\u0026#34; (dlv) n \u0026gt; main.main() ./main.go:7 (PC: 0x...) (dlv) p message \u0026#34;Hello, Delve!\u0026#34; # Step into (dlv) s \u0026gt; fmt.Println(...) # Step out (dlv) so Hello, Delve! \u0026gt; main.main() ./main.go:8 (PC: 0x...) # Continue (dlv) c Result: 42 \u0026gt; main.main() ./main.go:11 (hits goroutine(1):1 total:1) (PC: 0x...) (dlv) p result 42 # Quit (dlv) q Advanced features\rConditional breakpoints\r(dlv) b main.go:10 Breakpoint 1 set at main.go:10 (dlv) cond 1 i == 5 Debug tests\rdlv test main_test.go Set breakpoint:\n(dlv) b TestMyFunction Pass command-line args\rdlv debug -- arg1 arg2 # or dlv exec ./myapp -- arg1 arg2 Goroutine debugging\r(dlv) goroutines (dlv) goroutine 5 (dlv) p localVar Practical tips\r1. Production debugging\rBuild with optimizations disabled:\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o myapp main.go 2. Performance considerations\rDebug builds run slower; use them only for debugging. Use standard build options in production. 3. IDE integration\rVS Code: install Go extension Goland: built-in Delve support CLI proficiency helps you understand IDE debugging 4. Troubleshooting\rIssue: breakpoints don‚Äôt hit\nEnsure -gcflags=\u0026quot;all=-N -l\u0026quot; Verify breakpoint line and function Issue: variable values look wrong\nCompiler optimizations can distort values Rebuild with optimizations disabled Summary\rDelve is essential for Go developers. With it you can:\nLocate bugs quickly using breakpoints and stepping Understand code flow by tracking variables Debug concurrency by inspecting goroutines Improve productivity by reducing debug time Start with small programs, practice the commands, and gradually apply Delve to complex debugging tasks.\n","date":"2025-11-19T11:00:42+08:00","permalink":"https://zg-dd.github.io/en/stu/go-delve/","title":"Go Debugger Delve (dlv) Notes"},{"content":"Common Docker \u0026amp; Docker Compose Commands\r1. Image management\rImages are like installation packages or templates.\nCommand Description Example docker imagesdocker image ls List local images docker images docker search \u0026lt;name\u0026gt; Search images from registry docker search nginx docker pull \u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; Pull image (defaults to latest) docker pull nginx:alpine docker rmi \u0026lt;image\u0026gt; Remove local image docker rmi nginx docker image prune Remove dangling images docker image prune docker build -t \u0026lt;tag\u0026gt; . Build image from Dockerfile docker build -t my-app:1.0 . 2. Container management\rContainers are runtime instances created from images.\nCommand Description Example docker run [options] \u0026lt;image\u0026gt; Create and start a container docker run -d -p 80:80 nginx docker start \u0026lt;name/ID\u0026gt; Start a stopped container docker start my_nginx docker stop \u0026lt;name/ID\u0026gt; Stop a running container (graceful) docker stop my_nginx docker restart \u0026lt;name/ID\u0026gt; Restart container docker restart my_nginx docker rm \u0026lt;name/ID\u0026gt; Remove a stopped container docker rm my_nginx docker container prune Remove all stopped containers docker container prune docker ps List running containers docker ps docker ps -a List all containers docker ps -a docker logs \u0026lt;name/ID\u0026gt; View container logs docker logs my_nginx docker logs -f \u0026lt;name/ID\u0026gt; Follow logs in real time docker logs -f my_nginx docker exec -it \u0026lt;name/ID\u0026gt; \u0026lt;cmd\u0026gt; Run a command inside container docker exec -it my_nginx /bin/bash 3. Network management\rCommand Description Example docker network ls List networks docker network ls docker network create \u0026lt;name\u0026gt; Create a network docker network create my_net docker network inspect \u0026lt;name\u0026gt; Inspect a network docker network inspect bridge 4. Volume management\rVolumes store persistent data.\nCommand Description Example docker volume ls List volumes docker volume ls docker volume create \u0026lt;name\u0026gt; Create a volume docker volume create my_data docker volume rm \u0026lt;name\u0026gt; Remove a volume docker volume rm my_data docker volume prune Remove unused volumes docker volume prune 5. System and info\rCommand Description Example docker info Show Docker system info docker info docker version Show Docker version docker version docker stats Live resource usage docker stats docker system df Disk usage docker system df 6. Docker Compose commands\rManage multi-container apps.\nCommand Description Example docker compose up Create and start services docker compose up docker compose up -d Start services in background docker compose up -d docker compose down Stop and remove services docker compose down docker compose ps List project containers docker compose ps docker compose logs View logs docker compose logs docker compose logs -f \u0026lt;service\u0026gt; Follow logs for a service docker compose logs -f web docker compose exec \u0026lt;service\u0026gt; \u0026lt;cmd\u0026gt; Run a command in service container docker compose exec db mysql -u root -p Common flags\rFlag Long Meaning Example -d --detach Run in background docker run -d nginx -it -i -t Interactive TTY docker run -it ubuntu /bin/bash -p --publish Port mapping docker run -p 8080:80 nginx -v --volume Mount volume or dir docker run -v /host/data:/container/data nginx -e --env Set env var docker run -e MY_VAR=value nginx --name Set container name docker run --name my_nginx nginx --rm Remove container on exit docker run --rm alpine echo \u0026quot;hello\u0026quot; üöÄ Most-used commands\rCheck status: docker ps (containers), docker images (images) Pull image: docker pull \u0026lt;name\u0026gt; Run container: docker run -d -p ... --name ... \u0026lt;image\u0026gt; Stop container: docker stop \u0026lt;name\u0026gt; Enter container: docker exec -it \u0026lt;name\u0026gt; /bin/bash View logs: docker logs -f \u0026lt;name\u0026gt; Remove container: docker rm \u0026lt;name\u0026gt; Remove image: docker rmi \u0026lt;name\u0026gt; Tip: Save this list as a daily quick reference.\n","date":"2025-09-25T11:57:50+08:00","permalink":"https://zg-dd.github.io/en/stu/docker-command/","title":"Docker Common Commands Cheat Sheet"},{"content":"Core Knowledge of Network Communication\r1. Core concepts\r1. Socket\rWhat it is: An extension mechanism for inter‚Äëprocess communication (IPC)\nUse: Establish network communication channels (TCP/UDP)\nFlow:\nServer: socket ‚Üí bind ‚Üí listen ‚Üí accept Client: socket ‚Üí connect ‚Üí write/read ‚Üí close\nNote: handle byte‚Äëorder conversion (htonl/ntohl) 2. TCP vs UDP\rFeature TCP UDP Connection Connection‚Äëoriented (3‚Äëway handshake) Connectionless Reliability Reliable (retransmission) Unreliable Data form Stream socket Datagram socket Use cases File transfer, web browsing Real‚Äëtime video, DNS 2. Server models\r1. Iterative server\rLimitation: Single‚Äëthreaded blocking; cannot handle concurrent requests.\n2. Process/Thread model\rProcess approach:\nUse waitpid() to avoid zombie processes Parent must reap child resources Zombie handling details:\nCause:\nChild terminates but parent never calls wait() Consumes process table resources Solutions:\nSynchronous reap: waitpid(pid, NULL, 0); Async reap (recommended): signal(SIGCHLD, [](int) { while(waitpid(-1, NULL, WNOHANG) \u0026gt; 0); }); Special cases:\nIf parent exits first, init adopts and reaps Batch reaping requires a loop Thread approach:\nMust synchronize shared variables More complex critical‚Äësection control 3. Process pool optimization\rType Characteristics Static pool Pre‚Äëcreated processes, fixed concurrency Dynamic pool Maintain min/max idle processes 3. High‚Äëperformance I/O models\r1. Traditional blocking\rCharacteristics:\nSingle thread blocks on I/O Low resource utilization 2. Select/Poll\rFeature Select Poll Mechanism Bitmap FD scan Linked list FD scan Max connections 1024 (FD_SETSIZE) No hard limit Efficiency O(n) scan O(n) scan Portability All platforms All platforms 3. Epoll\rCore mechanism:\nRegistration via epoll_ctl (red‚Äëblack tree) Ready list maintained by kernel Trigger modes: LT (level‚Äëtriggered) ET (edge‚Äëtriggered) Advantages:\nO(1) event notification Supports massive connections (C1000K) 4. NIO (Non‚Äëblocking I/O)\rCore components:\nChannel: full‚Äëduplex pipes (SocketChannel/FileChannel) Buffer: ByteBuffer/CharBuffer Selector: multiplexer (based on epoll/kqueue) Workflow:\nstart : Create Selector; : Register Channel; repeat : select() for ready events; : Handle SelectionKey; repeat while (events?) stop 5. AIO (Asynchronous I/O)\rPrinciple:\nKernel completes I/O and calls back No user‚Äëthread polling Typical use cases:\nLarge file async read/write High‚Äëlatency network ops 6. Comparison\rModel Blocking Threading Trigger Use case Blocking I/O Blocking 1:1 - Low concurrency Select Non‚Äëblocking 1:N Polling Cross‚Äëplatform medium load Poll Non‚Äëblocking 1:N Polling \u0026lt;10K connections Epoll Non‚Äëblocking 1:N Event‚Äëdriven Linux high concurrency NIO Non‚Äëblocking 1:N Readiness High throughput AIO Async 0:1 Callback Latency‚Äësensitive Notes\rKernel support:\nWindows: IOCP is true async I/O Linux: io_uring (\u0026gt;=5.1) is close to true async Performance thresholds:\nC10K: Select/Poll bottleneck C100K: Epoll/NIO required C1000K: Epoll + zero‚Äëcopy optimization Complexity:\nBlocking \u0026lt; Select \u0026lt; Poll \u0026lt; Epoll \u0026lt; NIO \u0026lt; AIO 4. Practical points\r1. Daemons\rKey steps:\nfork() setsid()\nRedirect standard I/O to /dev/null 2. UDP server\rTraits:\nNo listen()/accept() Use recvfrom()/sendto() 3. Other tips\rReuse Address: avoid TIME_WAIT port blocking Thundering herd: multi‚Äëprocess accept contention, needs kernel lock optimizations Server types: I/O‚Äëbound: LNMP (nginx) CPU‚Äëbound: LAMP (Apache) Coroutines: user‚Äëmode threads with lower context switch cost than kernel threads 5. Learning suggestions\r1. Diagnostic tools\rnetstat -anp # list network connections 2. Classic books\rUnix Network Programming Advanced Programming in the UNIX Environment ","date":"2025-08-15T19:08:51+08:00","permalink":"https://zg-dd.github.io/en/stu/socket/","title":"Core Knowledge of Network Communication"},{"content":" Personal study notes\n1. What is MCP?\rMCP (Model Content Protocol) is an open standard introduced by Anthropic in 2024. It provides a unified interaction framework between LLMs and external tools, data sources, and services. The core goal is to solve data silos in the AI ecosystem by standardizing interfaces so models can connect to external resources seamlessly‚Äîlike a \u0026ldquo;USB‚ÄëC\u0026rdquo; for AI or a universal adapter.\n2. Core features and principles\r2.1 Standardized 3‚Äëlayer architecture\rHost: the main app running the model (e.g., Claude Desktop, IDE plugins) Client: establishes a 1:1 connection with the server, wraps and forwards requests Server: lightweight adapter to real tools/data sources (databases, APIs, file systems) 2.2 Communication: JSON‚ÄëRPC 2.0\rLocal: JSON‚ÄëRPC over stdio for local tool calls Remote: long-lived HTTP via SSE (Server‚ÄëSent Events) and Streamable HTTP for async streaming Message format: all requests/responses follow JSON‚ÄëRPC 2.0 2.3 Dynamic discovery\rTool-level discovery: tools describe themselves (e.g., via OpenAPI) so models can call them without hard‚Äëcoded integration Service-level discovery (uncertain): URI‚Äëdriven discovery. The client parses a custom URI like mcp://api.service.com and fetches metadata (e.g., https://api.service.com/llms.txt). The server returns a JSON description including capabilities, docs, and auth. The client auto‚Äëconfigures access. Example: paste an MCP URI into chat and the LLM auto‚Äëintegrates the service (e.g., stock API) without manual config. 3. Security and permissions\rLocal execution by default to avoid data leakage User confirmation for high‚Äërisk operations (e.g., file deletion) Enterprise extensions: JWT, RBAC, IPsec tunnels for regulated scenarios 4. How it differs from traditional approaches\rFeature MCP Traditional API Function Calling Integration Unified protocol, dynamic discovery Per‚ÄëAPI custom integration Hard‚Äëcoded bindings Communication Bi‚Äëdirectional, real‚Äëtime Request‚Äëresponse Synchronous, no streaming Flexibility Plug‚Äëand‚Äëplay, multi‚Äëtool composition Re‚Äëdevelopment required Vendor‚Äëspecific 5. Summary\rMCP combines client‚Äëserver decoupling, JSON‚ÄëRPC messaging, and dynamic discovery to solve three pain points for LLM‚Äëtool integration:\nFlexibility: tools can be hot‚Äëplugged and services can expand dynamically Security: local execution plus permission control Standardization: unified protocol lowers integration cost and pushes openness By decoupling models from tools at the protocol layer, MCP moves AI from ‚Äúchat assistant‚Äù to ‚Äúexecution agent,‚Äù forming a foundation for complex agent systems. As enterprise adoption grows (e.g., Changhong Hongxin EADP integrating MCP), it is becoming core infrastructure for next‚Äëgeneration AI agents.\n","date":"2025-08-06T15:14:07+08:00","permalink":"https://zg-dd.github.io/en/stu/mcp-protocol-core/","title":"MCP Protocol: Intro and Core Mechanisms"},{"content":"When using MyBatis, we often inspect SQL logs to debug and optimize queries. However, MyBatis logs include placeholders and parameter values, so the SQL is not directly executable. This simple HTML + JavaScript tool parses MyBatis SQL logs and outputs runnable SQL statements.\n1. Features\rParse SQL logs: Extract SQL statements and parameters from MyBatis logs. Replace parameters: Replace ? placeholders with actual parameter values. Generate executable SQL: Output full SQL ready to run. 2. Implementation details\r2.1 HTML structure\rThe HTML provides a simple UI with an input area, a parse button, and an output area.\nInput area: paste MyBatis SQL logs. Parse button: triggers the JS parser. Output area: shows the executable SQL. 2.2 JavaScript logic\rThe JS logic does the following:\nSplit logs by newline and process line by line. Extract SQL from lines containing Preparing:. Parse parameters from lines containing Parameters: and handle types: Strings \u0026amp; timestamps: wrap with single quotes and escape single quotes. Nulls: replace with NULL. Other types: replace directly. Output results to the output textarea. 3. Script code\rCreate a .html file, paste the following into it, save, then open in a browser.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Mybatis SQL Log Parser\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function f(obj) { try { var textVa = obj.value; var logs = textVa.split(\u0026#39;\\n\u0026#39;); // Split by newline var results = []; var currentStatement = null; logs.forEach(function(log) { // Check if this line contains \u0026#34;Preparing:\u0026#34; or \u0026#34;Parameters:\u0026#34; if (log.indexOf(\u0026#39;Preparing:\u0026#39;) !== -1) { if (currentStatement !== null) { // If we have a current statement, push it to the results results.push(currentStatement); } // Start a new statement currentStatement = log.substring(log.indexOf(\u0026#39;Preparing:\u0026#39;) + \u0026#34;Preparing:\u0026#34;.length).trim(); } else if (log.indexOf(\u0026#39;Parameters:\u0026#39;) !== -1 \u0026amp;\u0026amp; currentStatement !== null) { // If we find parameters and have a current statement, parse the parameters var parametersStr = log.substring(log.indexOf(\u0026#39;Parameters:\u0026#39;) + \u0026#34;Parameters:\u0026#34;.length).trim(); var parameters = parametersStr.split(/,(?![^()]*\\))/g); // Use regex to split correctly for (var i = 0; i \u0026lt; parameters.length; i++) { var paramValue = parameters[i].trim(); if (paramValue === \u0026#34;null\u0026#34;) { currentStatement = currentStatement.replace(\u0026#34;?\u0026#34;, \u0026#34;NULL\u0026#34;); } else { var typeStr = paramValue.substring(paramValue.indexOf(\u0026#34;(\u0026#34;) + 1, paramValue.indexOf(\u0026#34;)\u0026#34;)); paramValue = paramValue.substring(0, paramValue.indexOf(\u0026#34;(\u0026#34;)).trim(); if (typeStr === \u0026#34;String\u0026#34; || typeStr === \u0026#34;Timestamp\u0026#34;) { paramValue = \u0026#34;\u0026#39;\u0026#34; + paramValue.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;\u0026#34;; } currentStatement = currentStatement.replace(\u0026#34;?\u0026#34;, paramValue); } } // Add the final statement to the results and reset currentStatement results.push(currentStatement); currentStatement = null; } }); // If there\u0026#39;s a remaining statement, push it to the results if (currentStatement !== null) { results.push(currentStatement); } document.getElementById(\u0026#34;d1\u0026#34;).value = results.join(\u0026#34;\\n\\n\u0026#34;); } catch (e) { console.error(e); alert(\u0026#34;Error parsing SQL: \u0026#34; + e.message); } } function copySQL() { var SQL = document.getElementById(\u0026#34;d1\u0026#34;); navigator.clipboard.writeText(SQL.value).then(function() { var msg = document.getElementById(\u0026#34;msg\u0026#34;); msg.innerHTML = \u0026#34;Copied to clipboard\u0026#34;; setTimeout(function () { msg.innerHTML = \u0026#34;\u0026#34;; }, 3000); }).catch(function(err) { console.error(\u0026#34;Copy failed:\u0026#34;, err); alert(\u0026#34;Error copying SQL: \u0026#34; + err.message); }); } function clearLog(obj) { obj.value = \u0026#34;\u0026#34;; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#00bfff\u0026#34;\u0026gt;Paste Mybatis SQL logs:\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;textarea id=\u0026#34;sqlLog\u0026#34; rows=\u0026#34;12\u0026#34; cols=\u0026#34;140\u0026#34; style=\u0026#34;font-size:12px;font-family: \u0026#39;CourierNew\u0026#39;;font-weight: bold;width: 98%;\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;div style=\u0026#34;border:0px deepskyblue solid;width:1425px;height:50px;text-align:right;\u0026#34;\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;button\u0026#34; onclick=\u0026#34;clearLog(document.getElementById(\u0026#39;sqlLog\u0026#39;))\u0026#34;\u0026gt;Clear\u0026lt;/button\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;submit\u0026#34; onclick=\u0026#34;f(document.getElementById(\u0026#39;sqlLog\u0026#39;))\u0026#34;\u0026gt;Parse SQL\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#32cd32\u0026#34;\u0026gt;Executable SQL:\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;textarea id=\u0026#34;d1\u0026#34; rows=\u0026#34;12\u0026#34; cols=\u0026#34;140\u0026#34; style=\u0026#34;font-size:12px;font-family: \u0026#39;CourierNew\u0026#39;;font-weight: bold;width: 98%;\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;div style=\u0026#34;border:0px deepskyblue solid;width:1425px;height:50px;text-align:right;\u0026#34;\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;button\u0026#34; onclick=\u0026#34;copySQL()\u0026#34;\u0026gt;Copy SQL\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;msg\u0026#34; style=\u0026#34;color:cornflowerblue;border:0px black solid;width:800px;height:20px;text-align:right;font-style: initial;font-size: large\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. How to use\rPaste MyBatis SQL logs into the input area. Click \u0026ldquo;Parse SQL\u0026rdquo;. View and copy the executable SQL in the output area. 4.1 Example\rInput:\nPreparing: INSERT INTO users (name, email) VALUES (?, ?) Parameters: John(String), null Output:\nINSERT INTO users (name, email) VALUES (\u0026#39;John\u0026#39;, NULL) 5. Summary\rThis simple script converts MyBatis SQL logs into executable SQL statements, making development and debugging much easier.\n","date":"2025-02-19T21:52:49+08:00","permalink":"https://zg-dd.github.io/en/blog/mybatis-sql-log-parser/","title":"MyBatis SQL Log Parser Script"},{"content":" In Java projects, POJOs (Plain Old Java Objects) are everywhere and often need to be logged. The traditional approach is to print them via toString, but the output is usually unstructured and makes troubleshooting harder. This tool converts about 90% of daily POJO logs into structured JSON automatically, greatly improving readability and maintainability and helping ops engineers locate issues faster.\n1. Problems solved\rExample 1: Simple object\nInput: User(id=1, name=\u0026quot;Alice\u0026quot;, age=25)\nOutput: {\u0026quot;User\u0026quot;: {\u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Alice\u0026quot;, \u0026quot;age\u0026quot;: 25}} Example 2: Nested object\nInput: Order(id=1001, items=[Item(id=2001, name=\u0026quot;Book\u0026quot;)])\nOutput: {\u0026quot;Order\u0026quot;: {\u0026quot;id\u0026quot;: 1001, \u0026quot;items\u0026quot;: [{\u0026quot;Item\u0026quot;: {\u0026quot;id\u0026quot;: 2001, \u0026quot;name\u0026quot;: \u0026quot;Book\u0026quot;}}]}}\nExample 3: Complex map\nInput: Config(settings={key1=\u0026quot;value1\u0026quot;, key2=[1, 2, 3]})\nOutput: {\u0026quot;Config\u0026quot;: {\u0026quot;settings\u0026quot;: {\u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: [1, 2, 3]}}} Example 4: Custom complex object\nInput: User(username=Âº†‰∏â, password=123456, students=[Student(name=ÊùéÂõõ, age=18, score=0.0, courses=null), Student(name=Áéã‰∫î, age=20, score=0.0, courses=[Êï∞Â≠¶, Ëã±ËØ≠, Áâ©ÁêÜ])], map={aa=123, bb=456, cc=‰Ω†Â•Ω})\nOutput:\n{ \u0026#34;User\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Âº†‰∏â\u0026#34;, \u0026#34;password\u0026#34;: 123456, \u0026#34;students\u0026#34;: [ { \u0026#34;Student\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;ÊùéÂõõ\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;score\u0026#34;: 0.0, \u0026#34;courses\u0026#34;: null } }, { \u0026#34;Student\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Áéã‰∫î\u0026#34;, \u0026#34;age\u0026#34;: 20, \u0026#34;score\u0026#34;: 0.0, \u0026#34;courses\u0026#34;: [ \u0026#34;Êï∞Â≠¶\u0026#34;, \u0026#34;Ëã±ËØ≠\u0026#34;, \u0026#34;Áâ©ÁêÜ\u0026#34; ] } } ], \u0026#34;map\u0026#34;: { \u0026#34;aa\u0026#34;: 123, \u0026#34;bb\u0026#34;: 456, \u0026#34;cc\u0026#34;: \u0026#34;‰Ω†Â•Ω\u0026#34; } } } 2. Download\rDownload script\n","date":"2025-02-19T21:48:01+08:00","permalink":"https://zg-dd.github.io/en/blog/java-pojo-log-json/","title":"Java POJO Log JSON Converter"},{"content":"1. Closures\r1.1 What is a closure?\rA closure is a function combined with the environment that it captures. In Go, closures can access and modify variables defined in their enclosing scopes even after the outer function returns.\n1.2 Closure properties\rA closure can access variables from its outer scope. A closure can modify those outer-scope variables. The variables persist after the outer function exits. 1.3 Closure example\rpackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println(pos(i), neg(-2*i)) } } Each call to adder returns a distinct closure that captures its own sum variable. The output shows two independent sums growing separately.\n2. Types\r2.1 Custom types\rGo lets you define new type names with the type keyword.\n2.2 Type example\rpackage main import \u0026#34;fmt\u0026#34; type addFun func(int) int type selfint int func adder2(x int) addFun { return func(y int) int { return x + y } } func main() { var eg addFun = adder2(10) fmt.Println(eg(15)) var num1 selfint = 10 var num2 int = 20 fmt.Println(num1 + selfint(num2)) fmt.Println(int(num1) + num2) } Output: 25, 30, 30. selfint cannot be mixed with int without conversion.\n3. Defer\r3.1 How defer works\rA defer statement postpones a function call until the surrounding function returns.\n3.2 Defer example\rpackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } Output: hello followed by world because the deferred call runs after main finishes.\n4. Panic and Recover\rpanic is similar to throwing an exception; recover catches it. Go does not have try..catch syntax.\n4.1 Usage\rpanic signals an unrecoverable error. recover captures the panic so the program can continue. 4.2 Example\rpackage main import \u0026#34;fmt\u0026#34; func main() { defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;Recovered from\u0026#34;, r) } }() fmt.Println(\u0026#34;Starting the program\u0026#34;) panic(\u0026#34;Something went wrong!\u0026#34;) fmt.Println(\u0026#34;This line will not run\u0026#34;) } Output: Starting the program and then Recovered from Something went wrong! because the deferred function recovered from the panic.\n5. The time package\rThe time package provides utilities for working with dates and times, including formatting, parsing, duration math, and comparisons.\ncurrentTime := time.Now() fmt.Println(\u0026#34;Current Time:\u0026#34;, currentTime) year := currentTime.Year() month := currentTime.Month() day := currentTime.Day() hour := currentTime.Hour() minute := currentTime.Minute() second := currentTime.Second() fmt.Printf(\u0026#34;Current Time: %d-%02d-%02d %02d:%02d:%02d\\n\u0026#34;, year, month, day, hour, minute, second) fmt.Println(\u0026#34;Formatted:\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) timeStr := \u0026#34;2023-01-01 12:00:00\u0026#34; parsedTime, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err != nil { fmt.Println(\u0026#34;Failed to parse:\u0026#34;, err) return } fmt.Println(\u0026#34;Parsed:\u0026#34;, parsedTime) duration := time.Duration(10) * time.Second fmt.Println(\u0026#34;Duration:\u0026#34;, duration) newTime := currentTime.Add(duration) fmt.Println(\u0026#34;New Time:\u0026#34;, newTime) if currentTime.Before(parsedTime) { fmt.Println(\u0026#34;Current time is before parsed time\u0026#34;) } else if currentTime.After(parsedTime) { fmt.Println(\u0026#34;Current time is after parsed time\u0026#34;) } else { fmt.Println(\u0026#34;Current time equals parsed time\u0026#34;) } if currentTime.Equal(parsedTime) { fmt.Println(\u0026#34;Current time equals parsed time\u0026#34;) } Summary:\ntime.Now() Year/Month/Day/Hour/Minute/Second currentTime.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;) time.Parse(\u0026quot;2006-01-02 15:04:05\u0026quot;, timeStr) time.Duration(10) * time.Second currentTime.Add(duration) currentTime.Before/After/Equal(parsedTime) ","date":"2025-02-13T17:45:37+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-07/","title":"Golang Learning Journey [Part 7: closures, types, defer, panic/recover \u0026 the time package]"},{"content":"1. Map Data Type\rA map is a collection of key-value pairs where each key is unique and maps to a value. Maps are unordered, so iteration order is undefined. A map‚Äôs zero value is nil, so you must create it with make before use. Maps are reference types.\n1.1 Declaring and initializing maps\rvar map1 map[string]int map1 = make(map[string]int) map1[\u0026#34;a\u0026#34;] = 1 map1[\u0026#34;b\u0026#34;] = 2 map1[\u0026#34;c\u0026#34;] = 3 var map2 = make(map[string]int) map2[\u0026#34;a\u0026#34;] = 4 map2[\u0026#34;b\u0026#34;] = 5 map2[\u0026#34;c\u0026#34;] = 6 map3 := map[string]int{} map3[\u0026#34;a\u0026#34;] = 7 map3[\u0026#34;b\u0026#34;] = 8 map3[\u0026#34;c\u0026#34;] = 9 var map4 = map[string]int{\u0026#34;a\u0026#34;: 10, \u0026#34;b\u0026#34;: 11, \u0026#34;c\u0026#34;: 12} map5 := map[string]int{\u0026#34;a\u0026#34;: 13, \u0026#34;b\u0026#34;: 14, \u0026#34;c\u0026#34;: 15} var map6 map[string]int var map7 = map[string]int{} fmt.Printf(\u0026#34;map1 type:%T value:%v nil:%v\\n\u0026#34;, map1, map1, map1 == nil) fmt.Printf(\u0026#34;map2 type:%T value:%v nil:%v\\n\u0026#34;, map2, map2, map2 == nil) fmt.Printf(\u0026#34;map3 type:%T value:%v nil:%v\\n\u0026#34;, map3, map3, map3 == nil) fmt.Printf(\u0026#34;map4 type:%T value:%v nil:%v\\n\u0026#34;, map4, map4, map4 == nil) fmt.Printf(\u0026#34;map5 type:%T value:%v nil:%v\\n\u0026#34;, map5, map5, map5 == nil) fmt.Printf(\u0026#34;map6 type:%T value:%v nil:%v\\n\u0026#34;, map6, map6, map6 == nil) fmt.Printf(\u0026#34;map7 type:%T value:%v nil:%v\\n\u0026#34;, map7, map7, map7 == nil) map8 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} fmt.Println(len(map1)) Output:\nmap1 type:map[string]int value:map[a:1 b:2 c:3] nil:false map2 type:map[string]int value:map[a:4 b:5 c:6] nil:false map3 type:map[string]int value:map[a:7 b:8 c:9] nil:false map4 type:map[string]int value:map[a:10 b:11 c:12] nil:false map5 type:map[string]int value:map[a:13 b:14 c:15] nil:false map6 type:map[string]int value:\u0026lt;nil\u0026gt; nil:true map7 type:map[string]int value:map[] nil:false 3 1.2 Iterating over maps\rmap1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} fmt.Println(\u0026#34;1. fori style\u0026#34;) keys := make([]string, 0, len(map1)) for k := range map1 { keys = append(keys, k) } for i := 0; i \u0026lt; len(keys); i++ { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, keys[i], map1[keys[i]]) } fmt.Println(\u0026#34;2. for range style\u0026#34;) for k, v := range map1 { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, k, v) } Output:\n1. fori style key=one value=java key=two value=python key=three value=go 2. for range style key=one value=java key=two value=python key=three value=go 1.3 Map CRUD\rmap1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} map1[\u0026#34;four\u0026#34;] = \u0026#34;php\u0026#34; fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) delete(map1, \u0026#34;one\u0026#34;) fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) map1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; if value, ok := map1[\u0026#34;two\u0026#34;]; ok { fmt.Println(value) } if value1, ok1 := map1[\u0026#34;five\u0026#34;]; ok1 { fmt.Println(value1) } else { fmt.Println(\u0026#34;five does not exist\u0026#34;) } Output:\nmap1: map[four:php three:go two:python] map1: map[three:go two:python] c++ five does not exist 2. Functions\rFunctions are reusable code blocks that implement a specific feature.\nFunctions have the following traits:\nIncrease code reuse and readability, and simplify maintenance. Return values via return, which can send back one or more values. Parameters are defined in a parameter list and can be any type and any count. Local variable scope is limited to inside the function; the outside cannot access them. The parameter list and return values define the function‚Äôs interface and contract. 2.1 Various function definitions\rpackage main import \u0026#34;fmt\u0026#34; func sayHello() { fmt.Println(\u0026#34;hello world\u0026#34;) } func sayHello2(name string) { fmt.Println(\u0026#34;hello\u0026#34;, name) } func add(a int, b int) int { return a + b } func add2(a, b int) int { return a + b } func add3(a, b int) (c int) { c = a + b return } func add4(a, b int) (int, int) { return a + b, a - b } func add5(a, b int) (sum, diff int) { sum = a + b diff = a - b return } func add6(a ...int) int { sum := 0 for _, v := range a { sum += v } return sum } func opreate(a, b int, op func(int, int) int) int { return op(a, b) } func add7(a, b int) func() string { f := func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) } return f } func add8(a, b int) func() string { return func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) } } func main() { sayHello() sayHello2(\u0026#34;Zhang San\u0026#34;) fmt.Printf(\u0026#34;add %d\\n\u0026#34;, add(1, 2)) fmt.Printf(\u0026#34;add2 %d\\n\u0026#34;, add2(3, 4)) fmt.Printf(\u0026#34;add3 %d\\n\u0026#34;, add3(5, 6)) sum1, diff1 := add4(7, 8) fmt.Printf(\u0026#34;add4 %d %d\\n\u0026#34;, sum1, diff1) sum2, diff2 := add5(9, 10) fmt.Printf(\u0026#34;add5 %d %d\\n\u0026#34;, sum2, diff2) fmt.Printf(\u0026#34;add6 %d\\n\u0026#34;, add6(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(1, 2, add)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(2, 4, func(i1, i2 int) int { return i1 * i2 })) fmt.Printf(\u0026#34;add7 %s\\n\u0026#34;, add7(1, 2)()) fmt.Printf(\u0026#34;add8 %s\\n\u0026#34;, add8(3, 4)()) } Output:\nhello world hello Zhang San add 3 add2 7 add3 11 add4 15 -3 add5 19 -1 add6 55 opreate 3 opreate 8 add7 1 + 2 = 3 add8 3 + 4 = 7 ","date":"2025-02-11T20:05:09+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-06/","title":"Golang Learning Journey [Part 6: Composite Types ‚Äì Map \u0026 Function Primer]"},{"content":"1. Arrays\rAn array is a fixed-length collection of elements of the same type. Arrays are value types.\n1.1 Declaring an array\rvar name = [length]\u0026lt;type\u0026gt; var name = [length]\u0026lt;type\u0026gt;{} name := [length]\u0026lt;type\u0026gt;{} Example:\nvar arr1 [4]int fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr1, len(arr1), arr1) Output:\nType: [4]int; length: 4; data: [0 0 0 0] 1.2 Initializing arrays\rvar arr1 [4]int arr1[0] = 1 arr1[3] = 4 fmt.Printf(\u0026#34;Method1: %T length: %v data: %v\\n\u0026#34;, arr1, len(arr1), arr1) var arr2 = [3]float64{1, 2, 4.6} fmt.Printf(\u0026#34;Method2: %T length: %v data: %v\\n\u0026#34;, arr2, len(arr2), arr2) arr3 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;Method3: %T length: %v data: %v\\n\u0026#34;, arr3, len(arr3), arr3) arr4 := [...]int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;Method4: %T length: %v data: %v\\n\u0026#34;, arr4, len(arr4), arr4) arr5 := [...]float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;Method5: %T length: %v data: %v\\n\u0026#34;, arr5, len(arr5), arr5) Output:\nType: [4]int; length: 4; data: [0 0 0 0] Method1: [4]int; length: 4; data: [1 0 0 4] Method2: [3]float64; length: 3; data: [1 2 4.6] Method3: [3]string; length: 3; data: [java Golang Python] Method4: [5]int; length: 5; data: [2 4 6 7 8] Method5: [8]float64; length: 8; data: [2 0 3.5 0 0 4.6 0 9] 1.3 Looping through arrays\rarr6 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} for i := 0; i \u0026lt; len(arr6); i++ { fmt.Printf(\u0026#34;idx%v: %v\\t\u0026#34;, i, arr6[i]) } fmt.Println() for index, value := range arr6 { fmt.Printf(\u0026#34;idx%v: %v\\t\u0026#34;, index, value) } Output:\nfori loop idx0: java; idx1: Golang; idx2: Python; for range loop idx0: java; idx1: Golang; idx2: Python; 1.4 Multidimensional arrays\rarr7 := [3][3]int{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, } fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr7, len(arr7), arr7) arr8 := [...][2]string{{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}} fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr8, len(arr8), arr8) for i := 0; i \u0026lt; len(arr7); i++ { for j := 0; j \u0026lt; len(arr7[i]); j++ { fmt.Printf(\u0026#34;row%v col%v: %v\\t\u0026#34;, i+1, j+1, arr7[i][j]) } fmt.Println() } for row, rowValue := range arr8 { for col, value := range rowValue { fmt.Printf(\u0026#34;row%v col%v: %v\\t\u0026#34;, row+1, col+1, value) } fmt.Println() } Output:\nType: [3][3]int; length: 3; data: [[1 2 3] [4 5 6] [7 8 9]] Type: [2][2]string; length: 2; data: [[a b] [c d]] row1 col1: 1; row1 col2: 2; row1 col3: 3; row2 col1: 4; row2 col2: 5; row2 col3: 6; row3 col1: 7; row3 col2: 8; row3 col3: 9; row1 col1: a; row1 col2: b; row2 col1: c; row2 col2: d; 2. Slices\rA slice is a wrapper over an array and represents a dynamic-length view. Slices are reference types.\n2.1 Declaring and initializing slices\rvar arr1 []int fmt.Printf(\u0026#34;Type: %T; len: %v; data: %v\\n\u0026#34;, arr1, len(arr1), arr1) var arr2 = []float64{1, 2, 4.6} fmt.Printf(\u0026#34;Method1: %T; len: %v; data: %v\\n\u0026#34;, arr2, len(arr2), arr2) arr3 := []string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;Method2: %T; len: %v; data: %v\\n\u0026#34;, arr3, len(arr3), arr3) arr4 := []int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;Method3: %T; len: %v; data: %v\\n\u0026#34;, arr4, len(arr4), arr4) arr5 := []float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;Method4: %T; len: %v; data: %v\\n\u0026#34;, arr5, len(arr5), arr5) Output:\nType: []int; len: 0; data: [] Method1: []float64; len: 3; data: [1 2 4.6] Method2: []string; len: 3; data: [java Golang Python] Method3: []int; len: 5; data: [2 4 6 7 8] Method4: []float64; len: 8; data: [2 0 3.5 0 0 4.6 0 9] 2.2 Creating slices from arrays\rarr1 := [5]int{10, 29, 49, 58, 32} fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr1, len(arr1), arr1) s1 := arr1[:] s2 := arr1[2:] s3 := arr1[:2] fmt.Printf(\u0026#34;Full slice: %T; len: %v; data: %v\\n\u0026#34;, s1, len(s1), s1) fmt.Printf(\u0026#34;From idx2: %T; len: %v; data: %v\\n\u0026#34;, s2, len(s2), s2) fmt.Printf(\u0026#34;Before idx2: %T; len: %v; data: %v\\n\u0026#34;, s3, len(s3), s3) Output:\nType: [5]int; length: 5; data: [10 29 49 58 32] Full slice: []int; len: 5; data: [10 29 49 58 32] From idx2: []int; len: 3; data: [49 58 32] Before idx2: []int; len: 2; data: [10 29] Summary: arr[start:end] extracts elements from index start (inclusive) to end (exclusive). Omit start or end to mean the beginning or end of the array.\n2.3 Slice length and capacity\rA slice has its own length and capacity: len returns the number of elements; cap counts how many elements remain from the first element to the end of the underlying array.\na := []int{2, 3, 4, 5, 6, 7} fmt.Printf(\u0026#34;Type: %T, len: %v, cap: %v, data: %v\\n\u0026#34;, a, len(a), cap(a), a) b := a[3:] c := a[:3] fmt.Printf(\u0026#34;%T, len: %v, cap: %v, data: %v\\n\u0026#34;, b, len(b), cap(b), b) fmt.Printf(\u0026#34;%T, len: %v, cap: %v, data: %v\\n\u0026#34;, c, len(c), cap(c), c) Output:\nType: []int, len: 6, cap: 6, data: [2 3 4 5 6 7] Type: []int, len: 3, cap: 3, data: [5 6 7] Type: []int, len: 3, cap: 6, data: [2 3 4] 3. nil\rThe predefined identifier nil represents the zero value for pointers, channels, functions, interfaces, maps, slices, etc.\nType Default value bool false int, float 0 string \u0026quot;\u0026quot; pointers nil arrays zero value array slices nil maps nil channels nil functions nil var arr [3]int var slices1 []int var slices2 = []int{1} fmt.Println(arr) fmt.Println(slices1, slices1 == nil, slices2 == nil) Output:\n[0 0 0] [] true false 4. Value vs. reference types\rValue types store independent copies, so updating one variable does not affect another. Reference types share the same underlying data, so modifying one reflects in the other. Slices are typical reference types.\na1 := [...]int{2, 3, 4, 5} a2 := []int{2, 3, 4, 5} b1 := a1 b2 := a2 b1[0] = 6 b2[0] = 6 fmt.Printf(\u0026#34;a1=%v,b1=%v\\n\u0026#34;, a1, b1) fmt.Printf(\u0026#34;a2=%v,b2=%v\\n\u0026#34;, a2, b2) Output:\na1=[2 3 4 5],b1=[6 3 4 5] a2=[6 3 4 5],b2=[6 3 4 5] 5. Common slice utilities\r5.1 make\rmake([]int, 10, 11) allocates a slice with length 10 and capacity 11.\nslice1 := make([]int, 10, 11) slice1[2] = 6 slice1[9] = 20 fmt.Printf(\u0026#34;Type: %T, len: %v, cap: %v, data: %v\\n\u0026#34;, slice1, len(slice1), cap(slice1), slice1) Output:\nType: []int, len: 10, cap: 11, data: [0 0 6 0 0 0 0 0 0 20] 5.2 append\rUse append(slice, elems...) to grow slices.\nslice2 := make([]int, 0, 0) slice2 = append(slice2, 12, 14, 24) fmt.Printf(\u0026#34;%T len: %v cap: %v data: %v\\n\u0026#34;, slice2, len(slice2), cap(slice2), slice2) slice3 := []int{3, 4, 5} slice4 := append(slice2, slice3...) fmt.Printf(\u0026#34;%T len: %v cap: %v data: %v\\n\u0026#34;, slice4, len(slice4), cap(slice4), slice4) Output:\nType: []int, len: 3, cap: 3, data: [12 14 24] Type: []int, len: 6, cap: 6, data: [12 14 24 3 4 5] 5.3 copy (deep clone)\rcopy(dst, src) copies src into dst. Use it to avoid sharing the same backing array.\nslice2 := make([]int, 0, 0) slice2 = append(slice2, 12, 14, 24) slice3 := []int{3, 4, 5} slice4 := append(slice2, slice3...) slice4Copy := make([]int, len(slice4)) copy(slice4Copy, slice4) slice4Copy[0] = 6666 fmt.Println(slice4, slice4Copy) Output:\n[12 14 24 3 4 5] [6666 14 24 3 4 5] 5.4 Deleting from a slice\rGo has no built-in delete. Combine slicing with append to drop a range.\ns1 := []int{1, 2, 3, 4, 5, 6} delIdx := 3 s1 = append(s1[:delIdx], s1[delIdx+1:]...) fmt.Println(s1) Output:\n[1 2 3 5 6] 5.5 Sorting slices\r5.5.1 Ascending\rUse sort.Ints, sort.Float64s, or sort.Strings.\nintList := []int{3, 4, 32, 32, 423, 12} floatList := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} sort.Ints(intList) sort.Float64s(floatList) sort.Strings(stringList) fmt.Println(intList) fmt.Println(floatList) fmt.Println(stringList) Output:\n[3 4 12 32 32 423] [1.1 3.13 4.2 5.3] [A C D S] 5.5.2 Descending\rCombine sort.XXXSlice, sort.Reverse, and sort.Sort.\nintList := []int{3, 4, 32, 32, 423, 12} floatList := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(floatList))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Println(intList) fmt.Println(floatList) fmt.Println(stringList) Output:\n[423 32 32 12 4 3] [5.3 4.2 3.13 1.1] [S D C A] 6. Tips and tricks\r6.1 Editor hints\rWhen you type . after a variable the editor shows suggestions. Items ending with ! insert scaffolding code. Hint Meaning append! Append slice items copy! Copy slice for! standard for loop forr! for range loop ifnotnil! if var != nil guard last! shorthand for a[len(a)-1] len! shorthand for len(a) print! print variable range! alias for forr! reverse! reverse slice sort! custom sort scaffolding var! assign to a new variable 6.2 Inspecting signatures\rHover for over 1s to view parameter and return metadata. Ctrl+Click enters the definition with full documentation. Use translation tools if needed. ","date":"2025-01-08T22:05:33+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-05/","title":"Golang Learning Journey [Part 5: Composite Types ‚Äì Arrays \u0026 Slices]"},{"content":"1. Operators\r1.1 Arithmetic operators\rSymbol Description + Addition - Subtraction * Multiplication / Division % Modulo Example:\nnum1 := 5 num2 := 3 fmt.Printf(\u0026#34;%v + %v = %v\\n\u0026#34;, num1, num2, num1+num2) fmt.Printf(\u0026#34;%v - %v = %v\\n\u0026#34;, num1, num2, num1-num2) fmt.Printf(\u0026#34;%v * %v = %v\\n\u0026#34;, num1, num2, num1*num2) fmt.Printf(\u0026#34;%v / %v = %v\\n\u0026#34;, num1, num2, num1/num2) fmt.Printf(\u0026#34;%v %% %v = %v\\n\u0026#34;, num1, num2, num1%num2) num2++ fmt.Printf(\u0026#34;After ++: %v \\n\u0026#34;, num2) num2-- fmt.Printf(\u0026#34;After --: %v \\n\u0026#34;, num2) Output:\n5 + 3 = 8 5 - 3 = 2 5 * 3 = 15 5 / 3 = 1 5 % 3 = 2 After ++: 4 After --: 3 Note: Go‚Äôs ++ and \u0026ndash; are statements, not expressions, so they cannot be assigned.\n1.2 Comparison operators\rSymbol Description == equal to != not equal to \u0026gt; greater than \u0026gt;= greater than or equal to \u0026lt; less than \u0026lt;= less than or equal to Example:\nnum3, num4 := 8, 6 fmt.Printf(\u0026#34;%v == %v = %v\\n\u0026#34;, num3, num4, num3 == num4) fmt.Printf(\u0026#34;%v != %v = %v\\n\u0026#34;, num3, num4, num3 != num4) fmt.Printf(\u0026#34;%v \u0026gt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt; num4) fmt.Printf(\u0026#34;%v \u0026gt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt;= num4) fmt.Printf(\u0026#34;%v \u0026lt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt; num4) fmt.Printf(\u0026#34;%v \u0026lt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt;= num4) Output:\n8 == 6 = false 8 != 6 = true 8 \u0026gt; 6 = true 8 \u0026gt;= 6 = true 8 \u0026lt; 6 = false 8 \u0026lt;= 6 = false 1.3 Logical operators\rSymbol Description \u0026amp;\u0026amp; logical AND ! logical NOT Example:\nnum5, num6 := 16, 20 fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 \u0026lt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 \u0026amp;\u0026amp; num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 || num6 \u0026lt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 || num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 || num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 || num6 \u0026gt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, !(num5 \u0026lt; 15)) fmt.Printf(\u0026#34;%v\\n\u0026#34;, !(num6 == 20)) Output:\nfalse false true true true true false true false 1.4 Assignment operators\rSymbol Description = Assign += Add and assign -= Subtract and assign *= Multiply and assign /= Divide and assign %= Modulo and assign \u0026laquo;= Left shift and assign \u0026raquo;= Right shift and assign \u0026amp;= Bitwise AND and assign = ^= Bitwise XOR and assign Example:\nnum6, num7 := 3, 6 num7 += num6 fmt.Printf(\u0026#34;num7 += num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 -= num6 fmt.Printf(\u0026#34;num7 -= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 *= num6 fmt.Printf(\u0026#34;num7 *= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 /= num6 fmt.Printf(\u0026#34;num7 /= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 %= num6 fmt.Printf(\u0026#34;num7 %%= num6 result: %v\\n\u0026#34;, num7) Output:\nnum7 += num6 result: 9 num7 -= num6 result: 3 num7 *= num6 result: 18 num7 /= num6 result: 2 num7 %= num6 result: 0 Advanced assignment operators are used in the binary section below.\n1.5 Other operators\rSymbol Description \u0026amp; Address of a variable * Pointer dereference Computers store variables through memory addresses. A pointer holds an address, and dereferencing it gives the stored value.\nExample:\nvar p *int num8 := 100 p = \u0026amp;num8 fmt.Printf(\u0026#34;p address=%v, value=%v\u0026#34;, p, *p) Output:\np address=0xc00000a0d8, value=100 2. Binary operations\rAll binary operations below operate on binary digits.\nSymbol Description \u0026amp; bitwise AND ^ bitwise XOR \u0026laquo; left shift \u0026raquo; right shift |p | q | p\u0026amp;q | p|q | p^q | |\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;| | 0 | 0 | 0 | 0 | 0 | | 1 | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 0 |\n\u0026amp; yields a 1 only if both bits are 1; | yields 0 only if both bits are 0; ^ yields 1 when bits differ; \u0026laquo; shifts left (fills with 0); \u0026raquo; shifts right (discards bits). Binary ops are useful for fast hardware-level control, such as address or IP manipulation.\nExample:\nvar num1 = 0b101011 var num2 = 0b110001 fmt.Printf(\u0026#34;%b \u0026amp; %b = %b \\n\u0026#34;, num1, num2, num1\u0026amp;num2) fmt.Printf(\u0026#34;%b | %b = %b \\n\u0026#34;, num1, num2, num1|num2) fmt.Printf(\u0026#34;%b ^ %b = %b \\n\u0026#34;, num1, num2, num1^num2) fmt.Printf(\u0026#34;%b \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, num1, 2, num1\u0026lt;\u0026lt;2) fmt.Printf(\u0026#34;%b \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, num2, 2, num2\u0026gt;\u0026gt;2) num2 = 0b110001 num2 \u0026amp;= num1 fmt.Printf(\u0026#34;num2 \u0026amp;= num1: %b \\n\u0026#34;, num2) num2 = 0b110001 num2 |= num1 fmt.Printf(\u0026#34;num2 |= num1: %b \\n\u0026#34;, num2) num2 = 0b110001 num2 ^= num1 fmt.Printf(\u0026#34;num2 ^= num1: %b \\n\u0026#34;, num2) num1 = 0b110001 num1 \u0026lt;\u0026lt;= 2 fmt.Printf(\u0026#34;num1 \u0026lt;\u0026lt;= 2: %b \\n\u0026#34;, num1) num2 = 0b110001 num2 \u0026gt;\u0026gt;= 2 fmt.Printf(\u0026#34;num2 \u0026gt;\u0026gt;= 2: %b \\n\u0026#34;, num2) Output:\n101011 \u0026amp; 110001 = 100001 101011 | 110001 = 111011 101011 ^ 110001 = 11010 101011 \u0026lt;\u0026lt; 2 = 10101100 110001 \u0026gt;\u0026gt; 2 = 1100 100001 111011 11010 11000100 1100 \u0026amp; and | can also toggle flags. For example, treat a 5-bit binary value as seat occupancy (0=free, 1=occupied). Using masks you can clear or set specific bits:\nvar seat = 0b10011 var mask1 = 0b01010 fmt.Printf(\u0026#34;clear positions 1,3,5: %b \\n\u0026#34;, seat\u0026amp;mask1) var mask2 = 0b01010 fmt.Printf(\u0026#34;set positions 2,4: %b \\n\u0026#34;, seat|mask2) Output:\nclear positions 1,3,5: 10 set positions 2,4: 11011 The same mask 01010 can support multiple scenarios such as traffic lights or switches that toggle opposite settings.\n3. Control Flow\r3.1 if statements\rThe program evaluates conditions sequentially and executes only the first matching block.\nscore := 60 if score \u0026gt;= 90 { fmt.Println(\u0026#34;Outstanding\u0026#34;) } else if score \u0026gt;= 80 { fmt.Println(\u0026#34;Excellent\u0026#34;) } else if score \u0026gt;= 70 { fmt.Println(\u0026#34;Good\u0026#34;) } else if score \u0026gt;= 60 { fmt.Println(\u0026#34;Pass\u0026#34;) } else { fmt.Println(\u0026#34;Fail\u0026#34;) } if score1 := 80; score1 \u0026gt;= 90 { fmt.Println(\u0026#34;Outstanding\u0026#34;) } else if score1 \u0026gt;= 80 { fmt.Println(\u0026#34;Excellent\u0026#34;) } else if score1 \u0026gt;= 70 { fmt.Println(\u0026#34;Good\u0026#34;) } else if score1 \u0026gt;= 60 { fmt.Println(\u0026#34;Pass\u0026#34;) } else { fmt.Println(\u0026#34;Fail\u0026#34;) } fmt.Println(strconv.Itoa(score)) Output:\nPass Excellent 80 3.2 for loops\rvar str = \u0026#34;hello world\u0026#34; for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) } fmt.Println() i := 0 for i \u0026lt; len(str) { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } fmt.Println() i = 0 for { if i \u0026gt;= len(str) { break } fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } Output:\nh e l l o w o r l d h e l l o w o r l d h e l l o w o r l d 3.3 for range (key/value loop)\rtext := \u0026#34;‰Ω†Â•Ω,program\u0026#34; for k, v := range text { fmt.Printf(\u0026#34;k=%v,v=%c\\n\u0026#34;, k, v) } Output:\nk=0,v=‰Ω† k=3,v=Â•Ω k=6,v=, k=7,v=p k=8,v=r k=9,v=o k=10,v=g k=11,v=r k=12,v=a k=13,v=m 3.4 switch\u0026hellip;case\rswitch is typically used for enums or discrete choices.\nvar week = 3 switch week { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } switch week1 := 0; week1 { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } switch num := 10; num { case 0, 2, 4, 6, 8, 10: fmt.Println(\u0026#34;Even\u0026#34;) case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;Odd\u0026#34;) } score := 80 switch { case score \u0026gt;= 90: fmt.Println(\u0026#34;Outstanding\u0026#34;) case score \u0026gt;= 80: fmt.Println(\u0026#34;Excellent\u0026#34;) case score \u0026gt;= 70: fmt.Println(\u0026#34;Good\u0026#34;) case score \u0026gt;= 60: fmt.Println(\u0026#34;Pass\u0026#34;) default: fmt.Println(\u0026#34;Fail\u0026#34;) } Output:\nWednesday Unknown Even Excellent Go‚Äôs switch/case automatically breaks after executing a matching case. Use fallthrough to continue to the next case.\nswitch week1 := 5; week1 { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) fallthrough case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } Output:\nFriday Saturday 3.5 break, continue, goto\rbreak exits the current loop. continue skips to the next iteration. goto jumps to a labeled statement. lable1: for i := 0; i \u0026lt;= 3; i++ { if i == 0 { continue } if i == 1 { continue lable1 } fmt.Printf(\u0026#34;i=%d \\n\u0026#34;, i) } lable2: for j := 0; j \u0026lt;= 3; j++ { if j == 3 { fmt.Printf(\u0026#34;break loop\\n\u0026#34;) break } if j == 1 { break lable2 } fmt.Printf(\u0026#34;j=%d \\n\u0026#34;, j) } i := 0 lable3: fmt.Println(\u0026#34;statement 1\u0026#34;) i++ if i == 2 { goto lable5 } goto lable4 fmt.Println(\u0026#34;statement 2\u0026#34;) lable4: fmt.Println(\u0026#34;statement 3\u0026#34;) goto lable3 lable5: fmt.Println(\u0026#34;statement 4\u0026#34;) Output:\ni=2 i=3 j=0 statement 1 statement 3 statement 1 statement 4 ","date":"2025-01-01T11:03:08+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-04/","title":"Golang Learning Journey [Part 4: Operators \u0026 Control Flow]"},{"content":"1. Overview\rGo data types are split into basic types and composite types.\nBasic types include integers, floating-point numbers, booleans, and strings. Composite types include arrays, slices, structs, functions, maps, channels, interfaces, etc.\n2. Basic Data Types\r2.1 Integers\rType Range Size Signed? int8 $-2^7$~$2^7-1$ 1 byte Yes int16 $-2^{15}$~$2^{15}-1$ 2 bytes Yes int32 $-2^{31}$~$2^{31}-1$ 4 bytes Yes int64 $-2^{63}$~$2^{63}-1$ 8 bytes Yes uint8 $0$~$2^8-1$ 1 byte No uint16 $0$~$2^{16}-1$ 2 bytes No uint32 $0$~$2^{32}-1$ 4 bytes No uint64 $0$~$2^{64}-1$ 8 bytes No Special integer types:\nType Description uint 32-bit on 32-bit OS, 64-bit on 64-bit OS int 32-bit on 32-bit OS, 64-bit on 64-bit OS uintptr Unsigned integer used to store pointer values Example:\nvar ( num1 int = 666 num2 uint = 666 num3 int8 = math.MaxInt8 num4 int16 = math.MaxInt16 num5 int32 = math.MaxInt32 num6 int64 = math.MaxInt64 num7 uint8 = math.MaxUint8 num8 uint16 = math.MaxUint16 num9 uint32 = math.MaxUint32 num10 uint64 = math.MaxUint64 ) fmt.Println(num1, num2, num3, num4, num5, num6, num7, num8, num9, num10) Output:\n666 666 127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615 2.2 Floating-point numbers\rGo provides float32 and float64 following IEEE 754. On 32-bit systems the default is float32; on 64-bit systems it is float64.\nfloat32: range of -3.4e38 to 3.4e38, uses 4 bytes float64: range of -1.8e308 to 1.8e308, uses 8 bytes var num1 float32 = 1.06 num2 := 3.1415926 fmt.Printf(\u0026#34;Exact: %v; default 6 decimals: %f; fixed 3 decimals: %0.3f \\n\u0026#34;, num1, num2, num2) var ( num3 float32 = 3.1415926 num4 float64 = 1.113 num5 = 3.14e2 num6 = 3.14e-2 ) fmt.Println(num3, num4, num5, num6) Output:\nExact: 1.06; default 6 decimals: 3.141593; fixed 3 decimals: 3.142 3.1415925 1.113 314 0.0314 2.3 Booleans\rbool only has two values: true and false. Uninitialized booleans default to false.\nvar ( bool1 bool bool2 = true ) fmt.Println(bool1, bool2) Output:\nfalse true 2.4 Characters\rCharacters are single values and are represented as ints. Go exposes them via byte (ASCII) and rune (UTF-8).\nbyte: an alias for int representing ASCII values rune: an alias for int representing UTF-8 code points Note: UTF-8 is the universal encoding that extends ASCII to cover characters from multiple languages.\nvar a = \u0026#39;A\u0026#39; fmt.Printf(\u0026#34;ASCII: %v; Char: %c \\n\u0026#34;, a, a) var ( b = \u0026#39;B\u0026#39; c = \u0026#39;‰Ω†\u0026#39; d = \u0026#34;this\u0026#34; ) fmt.Printf(\u0026#34;%c,%c,%c,%c,%c,%c\u0026#34;, b, c, d[0], d[1], d[2], d[3]) Output:\nASCII: 65; Char: A B,‰Ω†,t,h,i,s 2.4 Strings\r2.4.1 Common definitions\rvar val1 string = \u0026#34;hello world\u0026#34; var val2 = \u0026#34;‰Ω†Â•Ω go\u0026#34; val3 := \u0026#34;Good\u0026#34; fmt.Println(val1, val2, val3) fmt.Println(len(val2)) var info = `ÂßìÂêçÔºöÂº†‰∏â Âπ¥ÈæÑÔºö18` fmt.Println(info) Output:\nhello world ‰Ω†Â•Ω go Good 9 ÂßìÂêçÔºöÂº†‰∏â Âπ¥ÈæÑÔºö18 In strings, ASCII letters occupy one byte and Chinese characters occupy three bytes. Use len to get the byte length.\n2.4.2 Escape characters\rEscape sequences start with \\. Common ones include:\n\\r: carriage return (moves to the beginning of the line) \\n: newline (moves to the next line) \\t: tab (helps align output) \\': single quote \\\u0026quot;: double quote \\\\: backslash var val1 string = \u0026#34;hello\\r\u0026#34; var val2 string = \u0026#34;world\\n\u0026#34; var val3 string = \u0026#34;hello world\\t\u0026#34; var val4 string = \u0026#34;\u0026#39;hello\u0026#39; \\\\ \\\u0026#34;world\\\u0026#34;\u0026#34; fmt.Println(val1, val2, val3, val4) Output:\nworld hello world \u0026#39;hello\u0026#39; \\ \u0026#34;world\u0026#34; 2.4.3 Common string methods\rMost method names are intuitive and shared across languages.\nMethod Description len length + or fmt.Sprint concatenation strings.Split split string strings.Contains check substring strings.HasPrefix / HasSuffix prefix/suffix test strings.Index / LastIndex find substring index strings.Join join slice into string strings.ToLower lowercase strings.ToUpper uppercase Example:\nvar val = \u0026#34;Hello World\u0026#34; length := len(val) fmt.Printf(\u0026#34;%s length: %d\\n\u0026#34;, val, length) str1 := val + \u0026#34;Â∞èÊòé\u0026#34; str2 := fmt.Sprint(val, \u0026#34;Â∞èÁ∫¢\u0026#34;) fmt.Printf(\u0026#34;+ concat: %s; Sprint concat: %s \\n\u0026#34;, str1, str2) splitVal := strings.Split(val, \u0026#34; \u0026#34;) newStr := strings.Join(splitVal, \u0026#34;,\u0026#34;) fmt.Printf(\u0026#34;split: %v; Join result: %s \\n\u0026#34;, splitVal, newStr) bool1 := strings.Contains(val, \u0026#34;Hello\u0026#34;) bool2 := strings.Contains(val, \u0026#34;olleH\u0026#34;) fmt.Printf(\u0026#34;contains Hello: %v; contains olleH: %v \\n\u0026#34;, bool1, bool2) bool3 := strings.HasPrefix(val, \u0026#34;He\u0026#34;) bool4 := strings.HasPrefix(val, \u0026#34;llo\u0026#34;) bool5 := strings.HasSuffix(val, \u0026#34;World\u0026#34;) bool6 := strings.HasSuffix(val, \u0026#34;Wor\u0026#34;) fmt.Printf(\u0026#34;prefix He: %v; prefix llo: %v; suffix World: %v; suffix Wor: %v \\n\u0026#34;, bool3, bool4, bool5, bool6) index1 := strings.Index(val, \u0026#34;o\u0026#34;) index2 := strings.LastIndex(val, \u0026#34;o\u0026#34;) index3 := strings.Index(val, \u0026#34;a\u0026#34;) fmt.Printf(\u0026#34;o first index: %v; o last index: %v; a index: %v\\n\u0026#34;, index1, index2, index3) str3 := strings.ToLower(val) str4 := strings.ToUpper(val) fmt.Printf(\u0026#34;lower: %v; upper: %v\\n\u0026#34;, str3, str4) Output:\nHello World length: 11 + concat: Hello WorldÂ∞èÊòé; Sprint concat: Hello WorldÂ∞èÁ∫¢ split: [Hello World]; Join result: Hello,World contains Hello: true; contains olleH: false prefix He: true; prefix llo: false; suffix World: true; suffix Wor: false o first index: 4; o last index: 7; a index: -1 lower: hello world; upper: HELLO WORLD Tip: len, split, contains, prefix, suffix, index, join, lower, upper have similar meanings across languages. Learning one makes the rest easier.\n2.4.4 Mutating a string via slices\rvar val1 = \u0026#34;hello xioaming\u0026#34; byteStr := []byte(val1) byteStr[0] = \u0026#39;a\u0026#39; fmt.Println(string(byteStr)) var val2 = \u0026#34;‰Ω†Â•ΩÂ∞èÊòé\u0026#34; runeStr := []rune(val2) runeStr[0] = \u0026#39;Êàë\u0026#39; fmt.Println(string(runeStr)) Output:\naello xioaming ÊàëÂ•ΩÂ∞èÊòé 3. Type Conversion\rNumeric conversion goes both ways: low-precision to high-precision and vice versa. Warning: converting from high to low precision can drop data because of differences in range.\n3.1 Integer-to-integer conversions\rvar a int8 = 127 b := int64(a) fmt.Printf(\u0026#34;a=%v, type: %T\\tb=%v, type: %T \\n\u0026#34;, a, a, b, b) var c int64 = 127 d := int16(c) fmt.Printf(\u0026#34;c=%v, type: %T\\td=%v, type: %T \\n\u0026#34;, c, c, d, d) Output:\na=127, type: int8 b=127, type: int64 c=127, type: int64 d=127, type: int16 3.2 Floating-point and integer conversions\rvar e int16 = 256 f := float32(e) fmt.Printf(\u0026#34;e=%v, type: %T\\tf=%v, type: %T \\n\u0026#34;, e, e, f, f) var g float64 = 3.145 h := int16(g) fmt.Printf(\u0026#34;g=%v, type: %T\\th=%v, type: %T \\n\u0026#34;, g, g, h, h) Output:\ne=256, type: int16 f=256, type: float32 g=3.145, type: float64 h=3, type: int16 3.3 Other type to string conversion via fmt\rvar ( intV = 123 floatV = 3.145 boolV = true charV = \u0026#39;A\u0026#39; ) str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, intV) str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, floatV) str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, boolV) str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, charV) fmt.Println(str1, str2, str3, str4) Output:\n123 3.145000 true A 3.4 strconv helpers\r3.4.1 strconv.Atoi and strconv.Itoa\rTip: in Itoa the leading i stands for int -\u0026gt; string. In Atoi the trailing i stands for string -\u0026gt; int.\nvar str = \u0026#34;123\u0026#34; num1, _ := strconv.Atoi(str) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, num1, num1) var num2 int64 = 456 str2 := strconv.Itoa(int(num2)) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str2, str2) Output:\nvalue: 123 type: int value: 456 type: string 3.4.2 strconv.ParseX functions\rstrconv.Parse performs conversions only if the source is valid.\nvar ( str1 = \u0026#34;256\u0026#34; str2 = \u0026#34;3.145\u0026#34; str3 = \u0026#34;true\u0026#34; ) num1, _ := strconv.ParseInt(str1, 10, 0) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, num1, num1) num2, _ := strconv.ParseFloat(str2, 32) fmt.Printf(\u0026#34;value: %0.3f\\ttype: %T\\n\u0026#34;, num2, num2) boo, _ := strconv.ParseBool(str3) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, boo, boo) Output:\nvalue: 256 type: int64 value: 3.145 type: float64 value: true type: bool 3.4.3 strconv.FormatX functions\rvar ( intV = 123 floatV = 3.145e2 booV = true ) str1 := strconv.FormatInt(int64(intV), 10) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str1, str1) str2 := strconv.FormatFloat(floatV, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str2, str2) str3 := strconv.FormatBool(booV) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str3, str3) Output:\nvalue: 123 type: string value: 314.5 type: string value: true type: string 3.4.4 Other helpers\rstrconv also includes helpers like Append (to append to byte slices), IsPrint, IsGraphic, Quote, Unquote, and CanBackquote. Study them when needed; this reference is handy.\n","date":"2024-12-21T19:37:51+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-03/","title":"Golang Learning Journey [Part 3: Basic Data Types and Type Conversion]"},{"content":" Preface: Packages in Go are collections of functionality provided either by the standard library or by custom code. You need to import a package before using it‚Äîfor today we focus on the fmt package, imported with import \u0026quot;fmt\u0026quot;.\n1. fmt Package\rThe fmt package is a widely used standard library module that handles formatted I/O, similar to printf and scanf in C. It lets you read input and display formatted data to stdout or to other writers.\n1.1 Printing\rPrinting in Go is handled by functions whose names start with Print. Print writes without inserting a newline, Println appends a newline, and Printf allows formatted printing.\n1.1.1 fmt.Print\r// package declaration: think of it as a folder package main // import statement: bring in the fmt package import \u0026#34;fmt\u0026#34; // main function: entry point func main() { fmt.Print(\u0026#39;C\u0026#39;) // prints a rune; single quotes are flexible fmt.Print(\u0026#34;a\u0026#34;) // prints a string fmt.Print(\u0026#34;Hello World\u0026#34;) // prints a string in double quotes fmt.Print(123) // prints an integer fmt.Print(3.1415926) // prints a float fmt.Print(true) // prints a boolean } Output:\n67aHello World1233.1415926true Summary: Print can print anything. Note that 'C' prints the ASCII value 67 because single quotes denote a rune literal; double quotes produce a string. Writing 'ABC' would trigger the error more than one character in rune literal because rune literals must be a single character.\n1.1.2 fmt.Println\rIf you switch to Println, each call adds a newline. From now on only the relevant code is shown.\nfmt.Println(\u0026#39;C\u0026#39;) fmt.Println(\u0026#34;a\u0026#34;) fmt.Println(\u0026#34;Hello World\u0026#34;, \u0026#34;‰Ω†Â•Ω\u0026#34;) fmt.Println(123) fmt.Println(3.1415926) fmt.Println(true) Result:\n67 a Hello World ‰Ω†Â•Ω 123 3.1415926 true 1.1.3 fmt.Printf\rPrintf allows you to control the formatting with verbs. Common verbs:\nVerb Description Importance (personal view) %T print the variable type high %v print with the default format high %t print true/false high %b print binary high %c print the Unicode character low %d print decimal high %o print octal high %x print lowercase hexadecimal high %X print uppercase hexadecimal low %U Unicode format low %f decimal floating-point high %e scientific notation with lowercase e low %E scientific notation with uppercase E low %g automatically choose %f or %e high %s plain string high %q double-quoted string or character low %p pointer address low Example:\nfmt.Printf(\u0026#34;Boolean value: %t \\n\u0026#34;, false) fmt.Printf(\u0026#34;Unicode 65: %c \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Default format 65: %v \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Binary 65: %b \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Decimal 65: %d \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Octal 65: %o \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Hex (lower) 1024: %x \\n\u0026#34;, 1024) fmt.Printf(\u0026#34;Hex (upper) 1024: %X \\n\u0026#34;, 1024) fmt.Printf(\u0026#34;\u0026#39;C\u0026#39; Unicode: %U \\n\u0026#34;, \u0026#39;C\u0026#39;) fmt.Printf(\u0026#34;Float: %f \\n\u0026#34;, 3.1415926) fmt.Printf(\u0026#34;Scientific (lower): %e \\n\u0026#34;, 3.1415926) fmt.Printf(\u0026#34;Scientific (upper): %E \\n\u0026#34;, 3.1415926) Output:\nBoolean value: false Unicode 65: A Default format 65: 65 Binary 65: 1000001 Decimal 65: 65 Octal 65: 101 Hex (lower) 1024: 400 Hex (upper) 1024: 400 \u0026#39;C\u0026#39; Unicode: U+0043 Float: 3.141593 Scientific (lower): 3.141593e+00 Scientific (upper): 3.141593E+00 1.2 Input (Scan)\rScan captures raw input; the f suffix (ScanF) enables formatting.\n1.2.1 fmt.Scan\rExample:\nvar name string var age int fmt.Print(\u0026#34;ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºö\u0026#34;) fmt.Scan(\u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) Result:\nËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â 18 name=Âº†‰∏â,age=18 1.2.2 fmt.Scanf\rExample:\nvar name string var age int fmt.Print(\u0026#34;ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºö\u0026#34;) fmt.Scanf(\u0026#34;%s %d\u0026#34;, \u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) Run several times to see Go\u0026rsquo;s flexibility for beginners:\nPS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â name=Âº†‰∏â,age=0 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â 18 name=Âº†‰∏â,age=18 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â ÊùéÂõõ name=Âº†‰∏â,age=0 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â ÊùéÂõõ 18 name=Âº†‰∏â,age=0 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â 18 ÊùéÂõõ name=Âº†‰∏â,age=18 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºö18 Âº†‰∏â name=18,age=0 PS F:\\go_project\u0026gt; 2. Variables\rVariables are containers for data and can hold any type of value. Variable names must consist of letters, digits, and underscores, and cannot start with a digit. Keywords and reserved words cannot be used as variable names.\n2.1 Variable declaration\rDeclare a variable by defining it. Several options exist:\nvar a string var b = \u0026#34;Âº†‰∏â\u0026#34; fmt.Printf(\u0026#34;a=%v,b=%v\u0026#34;, a, b) Output:\na=,b=Âº†‰∏â Default values:\nvar a string var b int var c bool var d float32 fmt.Printf(\u0026#34;a=%v, b=%v, c=%v, d=%v\u0026#34;, a, b, c, d) Output:\na=, b=0, c=false, d=0 Tip: Declared variables must be used; otherwise Go reports declared and not used.\n2.2 Initialization and assignment\rvar name string name = \u0026#34;Âº†‰∏â\u0026#34; var age = 18 sex := \u0026#34;Áî∑\u0026#34; score := 80 fmt.Print(name, age, sex, score) Result:\nÂº†‰∏â18Áî∑80 2.2 Declaring multiple variables\rvar a1, a2, a3 string a1 = \u0026#34;Âº†‰∏â\u0026#34; a2 = \u0026#34;ÊùéÂõõ\u0026#34; a3 = \u0026#34;Áéã‰∫î\u0026#34; fmt.Println(a1, a2, a3) var ( name string age int ) name = \u0026#34;ËµµÂÖ≠\u0026#34; age = 20 fmt.Println(name, age) var ( num1 = 1 num2 = 2 ) fmt.Println(num1, num2) num3, num4, num5 := 3, 4, \u0026#34;Hello\u0026#34; fmt.Println(num3, num4, num5) Result (Println automatically adds spaces and a newline):\nÂº†‰∏â ÊùéÂõõ Áéã‰∫î ËµµÂÖ≠ 20 1 2 3 4 Hello var is used for global definitions, while := can only be used locally.\n2.3 Anonymous variables\rAnonymous variables discard values using _ and do not occupy namespace.\nExample:\npackage main import \u0026#34;fmt\u0026#34; func getUserInfo() (string, int) { return \u0026#34;zhangsan\u0026#34;, 10 } func main() { var name, age = getUserInfo() fmt.Println(name, age) var _, age1 = getUserInfo() fmt.Println(age1) var name1, _ = getUserInfo() fmt.Println(name1) } Result:\nzhangsan 10 10 zhangsan Anonymous variables can be reused because they do not reserve names, but using var or := requires unique names.\n3. Constants\rVariables change over time; constants never do. Use const to declare them.\n3.1 Declaring constants\rconst A = \u0026#34;TEST1\u0026#34; fmt.Println(A) const ( B = \u0026#34;TEST2\u0026#34; C = \u0026#34;TEST3\u0026#34; D = \u0026#34;TEST4\u0026#34; ) fmt.Println(B, C, D) const ( E = \u0026#34;TEST5\u0026#34; F G H = \u0026#34;TEST6\u0026#34; I ) fmt.Println(E, F, G, H, I) Output:\nTEST1 TEST2 TEST3 TEST4 TEST5 TEST5 TEST5 TEST6 TEST6 3.2 iota counter\riota is a counter used together with const.\nconst ( n1 = iota n2 _ n3 n4 = iota n5 n6 = 100 n7 = iota n8, n9, n10 = iota, iota, iota + 1 ) fmt.Println(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10) Output:\n0 1 3 4 5 100 7 8 8 9 4. Summary: Variable and constant naming rules\rVariable names may contain letters, digits, and underscores. Identifiers cannot begin with a digit. Identifiers cannot be reserved keywords (var, if, for, etc.). Names are case-sensitive: name, Name, NAme, and NAME are different. Choose descriptive names. CamelCase is preferred; for example maxAge. Acronyms such as DNS or IP can stay uppercase. ","date":"2024-12-21T19:36:53+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-02/","title":"Golang Learning Journey [Part 2: fmt Package and Variables/Constants]"},{"content":" Preface: Go (also called Golang) is an open-source programming language developed by Google and first released publicly in 2009. It aims to provide concise, efficient, and reliable tools for software development. Golang is statically typed and compiled, and it is expressive thanks to its concurrency features. Programs written in Go can make very effective use of multi-core and networked computers, and its novel type system keeps the code modular and flexible. Compiling Go code to machine code is fast, and the language also offers convenient garbage collection plus a powerful reflection runtime.\nNotes from this journey: I will supplement this section after finishing the lessons.\n1. Learning Resources\rChinese documentation: https://go.p2hp.com/ „ÄêNot recommended‚Äîlagging behind the official docs„Äë\nOfficial documentation: https://go.dev/ „ÄêRecommended‚Äîthe latest, in English„Äë\nPractice while learning: Chinese tour | English tour\nBilibili study video\n2. Installing Go on Windows\r2.1 Installation\rFollow the screenshots below step by step: Click the arrow to download the installer and follow the prompts. Note: Developers typically avoid installing the newest release because it may have bugs, but the latest version is fine for learning. Double-click the downloaded go1.23.4.windows-amd64.msi file to install.\n2.2 Verification\rWindows environment variables tutorial You can also verify the Go installation via commands:\nPress Win + R, type cmd, and press Enter. Run the following commands:\n# Go version go version # Go environment go env Tip: If you accidentally left-click and see the terminal highlighted (pay attention to the selection indicator in the top-left), the cmd window is paused. Right-click to release and continue. 3. Development Environment‚ÄîVsCode\r3.1 Installing VsCode\rDownload VsCode After downloading, extract the archive and be sure to click ‚ÄúExtract‚Äù or ‚ÄúExtract to \u0026quot;VsCode-win***\u0026quot;‚Äù; otherwise the files scatter across the current directory. Place the extracted folder anywhere you like on your chosen drive.\nClick ‚ÄúExtract‚Äù to proceed: Put a shortcut on the desktop. Open the software and review the quick overview. 3.2 Install Extensions\r3.2.1 Language localization extension\r3.2.2 Go extension\rInstall the Go extension in the same way. 4. Hello World Walkthrough\r4.1 Create the project\rOpen the project folder in VsCode. When prompted, trust the author. 4.2 Create the project file\r4.3 Write the Hello World program\r// package declaration: Think of it as a folder package main // import: usually brings in standard library or custom packages import \u0026#34;fmt\u0026#34; // main function: the entry point func main() { // Print the Hello World string; semicolons are optional fmt.Println(\u0026#34;Hello World\u0026#34;) } 4.4 Fix VsCode code suggestions\rOpen a cmd terminal and configure the Go proxy:\ngo env -w GOPROXY=https://goproxy.io/ Restart VsCode a few times until the tools finish installing and code completion works. 4.5 Run the program\rOpen a terminal (it is just the Windows cmd window) and run the Go file:\n# run a Go file go run main.go # output # Hello World 4.6 Build the executable\r# compile the Go file into an executable go build main.go After the build you can double-click the exe to run it. Tip: The program exits immediately after finishing, so the terminal window closes at once, which makes it look like nothing happened.\n","date":"2024-12-21T10:51:49+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-01/","title":"Golang Learning Journey [Part 1: Getting Started]"},{"content":"show-busy-java-threads.sh\n#!/bin/bash # @Function # Find out the highest cpu consumed threads of java, and print the stack of these threads. # # @Usage # $ ./show-busy-java-threads.sh # # @author Jerry Lee # javaÁõÆÂΩï JAVA_HOME=/usr/local/java/jdk1.8.0_202 readonly PROG=`basename $0` readonly -a COMMAND_LINE=(\u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34;) usage() { cat \u0026lt;\u0026lt;EOF Usage: ${PROG} [OPTION]... Find out the highest cpu consumed threads of java, and print the stack of these threads. Example: ${PROG} -c 10 Options: -p, --pid find out the highest cpu consumed threads from the specifed java process, default from all java process. -c, --count set the thread count to show, default is 5 -h, --help display this help and exit EOF exit $1 } readonly ARGS=`getopt -n \u0026#34;$PROG\u0026#34; -a -o c:p:h -l count:,pid:,help -- \u0026#34;$@\u0026#34;` [ $? -ne 0 ] \u0026amp;\u0026amp; usage 1 eval set -- \u0026#34;${ARGS}\u0026#34; while true; do case \u0026#34;$1\u0026#34; in -c|--count) count=\u0026#34;$2\u0026#34; shift 2 ;; -p|--pid) pid=\u0026#34;$2\u0026#34; shift 2 ;; -h|--help) usage ;; --) shift break ;; esac done count=${count:-5} redEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;31m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } yellowEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;33m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } blueEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;36m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } # Check the existence of jstack command! if ! which jstack \u0026amp;\u0026gt; /dev/null; then [ -z \u0026#34;$JAVA_HOME\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH!\u0026#34; exit 1 } ! [ -f \u0026#34;$JAVA_HOME/bin/jstack\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH and $JAVA_HOME/bin/jstack file does NOT exists!\u0026#34; exit 1 } ! [ -x \u0026#34;$JAVA_HOME/bin/jstack\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH and $JAVA_HOME/bin/jstack is NOT executalbe!\u0026#34; exit 1 } export PATH=\u0026#34;$JAVA_HOME/bin:$PATH\u0026#34; fi readonly uuid=`date +%s`_${RANDOM}_$$ cleanupWhenExit() { rm /tmp/${uuid}_* \u0026amp;\u0026gt; /dev/null } trap \u0026#34;cleanupWhenExit\u0026#34; EXIT printStackOfThreads() { local line local count=1 while IFS=\u0026#34; \u0026#34; read -a line ; do local pid=${line[0]} local threadId=${line[1]} local threadId0x=\u0026#34;0x`printf %x ${threadId}`\u0026#34; local user=${line[2]} local pcpu=${line[4]} local jstackFile=/tmp/${uuid}_${pid} [ ! -f \u0026#34;${jstackFile}\u0026#34; ] \u0026amp;\u0026amp; { { if [ \u0026#34;${user}\u0026#34; == \u0026#34;${USER}\u0026#34; ]; then jstack ${pid} \u0026gt; ${jstackFile} else if [ $UID == 0 ]; then sudo -u ${user} jstack ${pid} \u0026gt; ${jstackFile} else redEcho \u0026#34;[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}).\u0026#34; redEcho \u0026#34;User of java process($user) is not current user($USER), need sudo to run again:\u0026#34; yellowEcho \u0026#34; sudo ${COMMAND_LINE[@]}\u0026#34; echo continue fi fi } || { redEcho \u0026#34;[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}).\u0026#34; echo rm ${jstackFile} continue } } blueEcho \u0026#34;[$((count++))] Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}):\u0026#34; sed \u0026#34;/nid=${threadId0x} /,/^$/p\u0026#34; -n ${jstackFile} done } ps -Leo pid,lwp,user,comm,pcpu --no-headers | { [ -z \u0026#34;${pid}\u0026#34; ] \u0026amp;\u0026amp; awk \u0026#39;$4==\u0026#34;java\u0026#34;{print $0}\u0026#39; || awk -v \u0026#34;pid=${pid}\u0026#34; \u0026#39;$1==pid,$4==\u0026#34;java\u0026#34;{print $0}\u0026#39; } | sort -k5 -r -n | head --lines \u0026#34;${count}\u0026#34; | printStackOfThreads ","date":"2024-09-10T13:48:55+08:00","permalink":"https://zg-dd.github.io/en/blog/java-high-cpu-threads/","title":"Java High-CPU Thread Diagnosis Script"},{"content":"Regex Concepts\r[] Use [] to match a single character inside the brackets. For example, [abc] matches any one of a, b, or c. In the string \u0026ldquo;abcdabcdbd\u0026rdquo; it matches a, b, c, a, b, c, b. It matches one character at a time and does not merge them. [abc]+ means one or more occurrences of any character in a, b, c. In the same string it matches abc, abc, b. In other words, it matches any of a, b, c one or more times, and consecutive matches are grouped as one string.\n\\ \\ is the escape character. Common escapes include \\n (newline), \\t (tab), \\r (carriage return), \\b (backspace), \\f (form feed), \\v (vertical tab), ' (single quote), \u0026quot; (double quote), and \\ (backslash). Regex has many other symbols; the image below lists them. Important: In regex, some escapes like \\b, \\f, \\n, \\t, \\r, ' can be written directly, e.g. regex=\u0026quot;\\n\u0026quot;; that matches a newline. regex=\u0026quot;\\\\n\u0026quot; also matches a newline. But for symbols like \\w, \\W, \\B, \\S, \\s, you must write regex=\u0026quot;\\\\w\u0026quot; to be valid; otherwise it fails. When you copy these escapes, \\ is often automatically doubled. So I recommend using \\\\ when you need a literal backslash in regex. Note: Not every escape needs to be doubled. For example, to match a double quote, you should not write regex=\u0026quot;\\\u0026quot;\u0026quot;. That would be interpreted incorrectly. Use regex=\u0026quot;\\\\\u0026quot;\u0026quot;. Using regex=\u0026quot;\u0026quot;\u0026quot; also works. If you want to match a backslash itself, in Java you would write regex=\u0026quot; \\\\\\\\ \u0026ldquo; (four backslashes). The first two represent the escape for , and the last two represent another literal \\ (this is my understanding; the expression is correct). By the same logic, to match \\, you would write regex=\u0026rdquo; \\\\\\\\\\\\\\ \u0026ldquo;.\n| This symbol means OR. For x|y, it matches x or y. The | operator has higher precedence than x,y. For regex = \u0026ldquo;[a][b]|[c][d]\u0026rdquo;, it matches \u0026ldquo;ab\u0026rdquo; or \u0026ldquo;cd\u0026rdquo;, not \u0026ldquo;a(b|c)d\u0026rdquo;.\n?\u0026lt;= and ?= These are lookaround tokens. They match a symbol without including it in the result. Example: to extract the text inside double quotes, for String str = \u0026ldquo;he says,\\\u0026ldquo;Hello,Java!\\\u0026rdquo; \u0026ldquo;; You can use: regex = \u0026ldquo;(?\u0026lt;=\\\u0026quot;)[^\\\u0026quot;]+(?=\\\u0026quot;)\u0026rdquo;. Here, (?\u0026lt;=\\\u0026rdquo;) matches a quote but does not include it, [^\\\u0026rdquo;]+ matches one or more non-quote characters, and (?=\\\u0026rdquo;) matches the closing quote without including it. These two are usually used together: one before and one after.\nNote: The single and double quotes above are English quotes. Some symbols may appear as Chinese punctuation due to escaping; keep that in mind when reading. That is all for now; I will add more later if I find new points.\nRegex Symbol Table\r","date":"2020-04-27T18:00:00+08:00","permalink":"https://zg-dd.github.io/en/stu/regular/","title":"Regex Basics: Common Symbols Explained ([] \\\\ | (?\u003c=))"}]
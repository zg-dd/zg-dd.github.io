[{"content":"Milvus Schema Learning Document\r1. Understanding Schema Concept\r1.1 What is Schema?\rSchema is the metadata definition of a Collection, similar to table structure definition in relational databases.\nMilvus Concept Relational Database Concept Description Schema Table Schema Metadata defining data structure Field Column Field/column definition DataType Data Type Data types (VARCHAR, INT, FLOAT, etc.) Primary Key Primary Key Primary key field Vector Field - Milvus-specific vector field Dynamic Field - Dynamic field, similar to MongoDB\u0026rsquo;s flexible Schema 1.2 Creating Schema\rfrom pymilvus import MilvusClient, DataType # Create Schema schema = client.create_schema( enable_dynamic_field=True # Enable dynamic fields ) # Compare with MySQL # CREATE TABLE products ( # ... # ); 2. Field Types Detailed\r2.1 Field Classification\rField Types ‚îú‚îÄ‚îÄ Scalar Fields ‚îÇ ‚îú‚îÄ‚îÄ String (VARCHAR) ‚îÇ ‚îú‚îÄ‚îÄ Numbers (INT8/INT16/INT32/INT64/FLOAT/DOUBLE/BOOL) ‚îÇ ‚îú‚îÄ‚îÄ JSON ‚îÇ ‚îú‚îÄ‚îÄ Arrays (ARRAY) ‚îÇ ‚îú‚îÄ‚îÄ Timestamp (TIMESTAMPTZ) ‚îÇ ‚îú‚îÄ‚îÄ Struct Arrays (ARRAY of STRUCT) ‚îÇ ‚îî‚îÄ‚îÄ Geometry Fields (GEOMETRY) ‚îî‚îÄ‚îÄ Vector Fields ‚îú‚îÄ‚îÄ Dense Vectors (FLOAT_VECTOR/FLOAT16_VECTOR/BFLOAT16_VECTOR/INT8_VECTOR) ‚îú‚îÄ‚îÄ Sparse Vectors (SPARSE_FLOAT_VECTOR) ‚îî‚îÄ‚îÄ Binary Vectors (BINARY_VECTOR) 3. Primary Key Fields\r3.1 Primary Key Type Comparison\rData Type Description Compare with MySQL INT64 64-bit integer, recommended Similar to BIGINT AUTO_INCREMENT VARCHAR Variable-length string Similar to VARCHAR(n) PRIMARY KEY 3.2 Auto ID vs Manual ID\rMode Description Use Cases Compare with MySQL Auto ID Milvus automatically generates unique identifiers Most situations AUTO_INCREMENT Manual ID User provides unique ID ID needs to be consistent with external systems Manually insert primary key values 3.3 Primary Key Field Examples\r# Auto ID Primary Key schema.add_field( field_name=\u0026#34;product_id\u0026#34;, datatype=DataType.INT64, is_primary=True, # Mark as primary key auto_id=True # Auto-generate ID ) # Compare with MySQL # product_id BIGINT AUTO_INCREMENT PRIMARY KEY # Manual ID Primary Key (using string) schema.add_field( field_name=\u0026#34;sku_code\u0026#34;, datatype=DataType.VARCHAR, max_length=50, is_primary=True, auto_id=False # Manual ID provision ) # Compare with MySQL # sku_code VARCHAR(50) PRIMARY KEY 4. Scalar Fields Detailed\r4.1 String Fields (VARCHAR)\rAttribute Description Range Compare with MySQL datatype Data type DataType.VARCHAR VARCHAR max_length Maximum length 1-65535 n in VARCHAR(n) nullable Nullable True/False NULL/NOT NULL default_value Default value String DEFAULT \u0026lsquo;value\u0026rsquo; # String field example schema.add_field( field_name=\u0026#34;product_name\u0026#34;, datatype=DataType.VARCHAR, max_length=255, nullable=False, default_value=\u0026#34;Unnamed Product\u0026#34; ) # Compare with MySQL # product_name VARCHAR(255) NOT NULL DEFAULT \u0026#39;Unnamed Product\u0026#39; 4.2 Numeric Fields\rMilvus Type Description Range Compare with MySQL BOOL Boolean value True/False BOOLEAN INT8 8-bit integer -128 ~ 127 TINYINT INT16 16-bit integer -32768 ~ 32767 SMALLINT INT32 32-bit integer -2^31 ~ 2^31-1 INT INT64 64-bit integer -2^63 ~ 2^63-1 BIGINT FLOAT 32-bit float - FLOAT DOUBLE 64-bit double - DOUBLE # Integer field schema.add_field( field_name=\u0026#34;stock_quantity\u0026#34;, datatype=DataType.INT32, nullable=False, default_value=0 ) # Float field schema.add_field( field_name=\u0026#34;product_price\u0026#34;, datatype=DataType.FLOAT, nullable=False ) # Boolean field schema.add_field( field_name=\u0026#34;is_available\u0026#34;, datatype=DataType.BOOL, default_value=True ) # Compare with MySQL # stock_quantity INT NOT NULL DEFAULT 0, # product_price FLOAT NOT NULL, # is_available BOOLEAN DEFAULT TRUE 4.3 JSON Fields\rJSON Fields vs Dynamic Fields Comparison\rFeature JSON Fields Dynamic Fields Compare with MySQL Schema Definition Must be explicitly declared Hidden field $meta JSON column vs no equivalent concept Use Cases Structured, known data Flexible, semi-structured data JSON column vs NoSQL features Control User controls field names and structure System automatically managed - Query Method metadata[\u0026quot;key\u0026quot;] dynamic_key or $meta[\u0026quot;key\u0026quot;] JSON_EXTRACT() # JSON field example schema.add_field( field_name=\u0026#34;product_detail\u0026#34;, datatype=DataType.JSON ) # Insert data example data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;product_detail\u0026#34;: { \u0026#34;brand\u0026#34;: \u0026#34;Apple\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;iPhone 15\u0026#34;, \u0026#34;specs\u0026#34;: { \u0026#34;cpu\u0026#34;: \u0026#34;A17 Pro\u0026#34;, \u0026#34;ram\u0026#34;: \u0026#34;8GB\u0026#34; } } } # Compare with MySQL # product_detail JSON # Query: SELECT JSON_EXTRACT(product_detail, \u0026#39;$.brand\u0026#39;) FROM products; JSON Indexing\rJSON indexing suitable scenarios:\nStructured Schema with consistent, known keys Equality and range queries on specific JSON paths Need for precise control over indexed keys Efficient storage acceleration for target queries # Create JSON index index_params = MilvusClient.prepare_index_params() index_params.add_index( field_name=\u0026#34;product_detail\u0026#34;, # JSON field name index_type=\u0026#34;AUTOINDEX\u0026#34;, # Must be AUTOINDEX or INVERTED index_name=\u0026#34;idx_product_brand\u0026#34;, # Index name params={ \u0026#34;json_path\u0026#34;: \u0026#39;product_detail[\u0026#34;brand\u0026#34;]\u0026#39;, # Top-level key \u0026#34;json_cast_type\u0026#34;: \u0026#34;VARCHAR\u0026#34; # Data type } ) # Nested key indexing index_params.add_index( field_name=\u0026#34;product_detail\u0026#34;, index_type=\u0026#34;AUTOINDEX\u0026#34;, index_name=\u0026#34;idx_product_cpu\u0026#34;, params={ \u0026#34;json_path\u0026#34;: \u0026#39;product_detail[\u0026#34;specs\u0026#34;][\u0026#34;cpu\u0026#34;]\u0026#39;, # Nested key \u0026#34;json_cast_type\u0026#34;: \u0026#34;VARCHAR\u0026#34; } ) # Compare with MySQL 8.0+ # CREATE INDEX idx_product_brand ON products((JSON_EXTRACT(product_detail, \u0026#39;$.brand\u0026#39;))); JSON Shredding Optimization\rJSON shredding accelerates queries by converting row-based storage to columnar storage.\nParameter Name Description Default Adjustment Suggestions common.enabledJSONShredding Whether to enable JSON shredding false Set to true to activate feature common.usingJSONShreddingForQuery Whether to use shredded data for acceleration true Set to false to restore when queries fail queryNode.mmap.jsonShredding Whether to use mmap when loading true Adjust for special memory requirements dataCoord.jsonShreddingMaxColumns Maximum shredded columns 1024 Increase when frequent keys exceed limit dataCoord.jsonShreddingRatioThreshold Minimum occurrence rate threshold 0.3 Adjust shredding criteria # milvus.yaml configuration example common: enabledJSONShredding: true usingJSONShreddingForQuery: true queryNode: mmap: jsonShredding: true dataCoord: jsonShreddingMaxColumns: 1024 jsonShreddingRatioThreshold: 0.3 4.4 Array Fields (ARRAY)\r# String array schema.add_field( field_name=\u0026#34;product_tags\u0026#34;, datatype=DataType.ARRAY, element_type=DataType.VARCHAR, max_capacity=10, # Up to 10 elements max_length=50 # Each string up to 50 characters ) # Integer array schema.add_field( field_name=\u0026#34;related_product_ids\u0026#34;, datatype=DataType.ARRAY, element_type=DataType.INT64, max_capacity=20 ) # Insert data example data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;product_tags\u0026#34;: [\u0026#34;Electronics\u0026#34;, \u0026#34;Phone\u0026#34;, \u0026#34;5G\u0026#34;, \u0026#34;Smart\u0026#34;], \u0026#34;related_product_ids\u0026#34;: [101, 102, 103] } # Compare with MySQL 8.0+ # product_tags JSON -- MySQL implements with JSON arrays # Or use association tables for many-to-many relationships 4.5 Timestamp Fields (TIMESTAMPTZ)\rTIMESTAMPTZ is timezone-aware timestamp type.\nFeature Description Compare with MySQL Input Format ISO 8601 strings (with timezone) TIMESTAMP Internal Storage UTC normalized storage Depends on time_zone setting Comparison Operations Unified UTC usage May be affected by timezone # Timestamp field schema.add_field( field_name=\u0026#34;created_at\u0026#34;, datatype=DataType.TIMESTAMPTZ, nullable=False, default_value=\u0026#34;2025-01-01T00:00:00+00:00\u0026#34; ) # Insert data example data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;created_at\u0026#34;: \u0026#34;2025-05-01T23:59:59+08:00\u0026#34; # Beijing time } # Compare with MySQL # created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP Timezone Management Levels\rLevel Parameter Scope Priority Database timezone Default for all collections in database Lowest Collection timezone Override database default timezone Medium Query/Search timezone Temporary override for specific operation Highest # Database level timezone setting client.alter_database_properties( \u0026#34;my_db\u0026#34;, {\u0026#34;timezone\u0026#34;: \u0026#34;Asia/Shanghai\u0026#34;} ) # Collection level timezone setting (when creating collection) client.create_collection( collection_name=\u0026#34;products\u0026#34;, schema=schema, properties={\u0026#34;timezone\u0026#34;: \u0026#34;America/New_York\u0026#34;} ) # Specify timezone temporarily during query client.query( collection_name=\u0026#34;products\u0026#34;, filter=\u0026#34;created_at \u0026gt; \u0026#39;2025-01-01T00:00:00+08:00\u0026#39;\u0026#34;, timezone=\u0026#34;Asia/Shanghai\u0026#34; ) 4.6 Struct Arrays (ARRAY of STRUCT)\rStruct arrays are used to store complex nested data.\n# Product reviews array example schema.add_field( field_name=\u0026#34;reviews\u0026#34;, datatype=DataType.ARRAY, element_type=DataType.STRUCT, max_capacity=100, element_schema={ \u0026#34;fields\u0026#34;: [ {\u0026#34;name\u0026#34;: \u0026#34;user_id\u0026#34;, \u0026#34;type\u0026#34;: DataType.INT64}, {\u0026#34;name\u0026#34;: \u0026#34;rating\u0026#34;, \u0026#34;type\u0026#34;: DataType.INT32}, {\u0026#34;name\u0026#34;: \u0026#34;comment\u0026#34;, \u0026#34;type\u0026#34;: DataType.VARCHAR, \u0026#34;max_length\u0026#34;: 500}, {\u0026#34;name\u0026#34;: \u0026#34;review_vector\u0026#34;, \u0026#34;type\u0026#34;: DataType.FLOAT_VECTOR, \u0026#34;dim\u0026#34;: 64}, {\u0026#34;name\u0026#34;: \u0026#34;timestamp\u0026#34;, \u0026#34;type\u0026#34;: DataType.TIMESTAMPTZ} ] } ) # Insert data example data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;reviews\u0026#34;: [ { \u0026#34;user_id\u0026#34;: 1001, \u0026#34;rating\u0026#34;: 5, \u0026#34;comment\u0026#34;: \u0026#34;Very good!\u0026#34;, \u0026#34;review_vector\u0026#34;: [0.1, 0.2, ...], # 64-dimensional vector \u0026#34;timestamp\u0026#34;: \u0026#34;2025-05-01T10:00:00+08:00\u0026#34; }, { \u0026#34;user_id\u0026#34;: 1002, \u0026#34;rating\u0026#34;: 4, \u0026#34;comment\u0026#34;: \u0026#34;Pretty good\u0026#34;, \u0026#34;review_vector\u0026#34;: [0.3, 0.4, ...], \u0026#34;timestamp\u0026#34;: \u0026#34;2025-05-02T15:30:00+08:00\u0026#34; } ] } # Compare with MySQL # Need to create association table reviews # CREATE TABLE reviews ( # review_id BIGINT PRIMARY KEY, # product_id BIGINT, # user_id BIGINT, # rating INT, # comment VARCHAR(500), # timestamp TIMESTAMP, # FOREIGN KEY (product_id) REFERENCES products(product_id) # ); 4.7 Geometry Fields (GEOMETRY)\rUsed to store geographic location and coordinate information.\n# Geometry field schema.add_field( field_name=\u0026#34;store_location\u0026#34;, datatype=DataType.GEOMETRY, default_value=\u0026#34;POINT(0 0)\u0026#34; ) # Insert data example data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;store_location\u0026#34;: \u0026#34;POINT(116.4074 39.9042)\u0026#34; # Tiananmen Square coordinates, Beijing } # Compare with MySQL # store_location POINT NOT NULL # Or use PostGIS extension GEOMETRY type 5. Vector Fields Detailed\r5.1 Vector Type Comparison\rMilvus Type Description Use Cases Storage Size FLOAT_VECTOR 32-bit float vector High-precision semantic search 4 bytes/dim FLOAT16_VECTOR 16-bit half-precision float Deep learning, GPU computing 2 bytes/dim BFLOAT16_VECTOR 16-bit brain float Large-scale image retrieval 2 bytes/dim INT8_VECTOR 8-bit integer vector Quantized models, fast inference 1 byte/dim SPARSE_FLOAT_VECTOR Sparse float vector Full-text search, term matching Variable BINARY_VECTOR Binary vector Resource-constrained scenarios 1 bit/dim 5.2 Dense Vector Examples\r# FLOAT_VECTOR - Standard dense vector schema.add_field( field_name=\u0026#34;product_embedding\u0026#34;, datatype=DataType.FLOAT_VECTOR, dim=128 # 128-dimensional vector ) # FLOAT16_VECTOR - Half-precision vector schema.add_field( field_name=\u0026#34;image_embedding\u0026#34;, datatype=DataType.FLOAT16_VECTOR, dim=512 ) # INT8_VECTOR - Quantized vector schema.add_field( field_name=\u0026#34;text_embedding_quantized\u0026#34;, datatype=DataType.INT8_VECTOR, dim=256 ) # Insert data example import numpy as np data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;product_embedding\u0026#34;: np.random.rand(128).tolist(), # 128-dim float vector \u0026#34;image_embedding\u0026#34;: np.random.rand(512).astype(np.float16).tolist(), \u0026#34;text_embedding_quantized\u0026#34;: np.random.randint(-128, 127, 256).tolist() } # MySQL has no equivalent type, needs to be stored as BLOB or JSON 5.3 Sparse Vector Examples\r# Sparse vector field schema.add_field( field_name=\u0026#34;keyword_vector\u0026#34;, datatype=DataType.SPARSE_FLOAT_VECTOR ) # Insert data example (sparse vector format) data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;keyword_vector\u0026#34;: { 10: 0.5, # Index 10 value is 0.5 25: 0.8, # Index 25 value is 0.8 100: 0.3 # Index 100 value is 0.3 } } 6. Dynamic Fields\r6.1 Dynamic Field Concept\rDynamic fields allow inserting fields not defined in Schema, which are automatically stored in the hidden $meta JSON field.\n# Enable dynamic fields schema = client.create_schema( enable_dynamic_field=True # Enable dynamic fields ) # Define basic fields schema.add_field( field_name=\u0026#34;product_id\u0026#34;, datatype=DataType.INT64, is_primary=True, auto_id=True ) schema.add_field( field_name=\u0026#34;product_vector\u0026#34;, datatype=DataType.FLOAT_VECTOR, dim=128 ) # Can include undefined fields when inserting data data = { \u0026#34;product_id\u0026#34;: 1, \u0026#34;product_vector\u0026#34;: [0.1, 0.2, ...], \u0026#34;name\u0026#34;: \u0026#34;iPhone 15\u0026#34;, # Not defined in Schema \u0026#34;category\u0026#34;: \u0026#34;Electronics\u0026#34;, # Not defined in Schema \u0026#34;price\u0026#34;: 999.99 # Not defined in Schema } # Milvus internally stores as: # { # \u0026#34;product_id\u0026#34;: 1, # \u0026#34;product_vector\u0026#34;: [0.1, 0.2, ...], # \u0026#34;$meta\u0026#34;: { # \u0026#34;name\u0026#34;: \u0026#34;iPhone 15\u0026#34;, # \u0026#34;category\u0026#34;: \u0026#34;Electronics\u0026#34;, # \u0026#34;price\u0026#34;: 999.99 # } # } 6.2 Supported Types for Dynamic Fields\rType Milvus DataType Compare with MongoDB String VARCHAR String Integer INT8, INT32, INT64 Int32, Int64 Float FLOAT, DOUBLE Double Boolean BOOL Boolean Array ARRAY Array JSON Object JSON Object 6.3 Querying Dynamic Fields\r# Direct field name query results = client.query( collection_name=\u0026#34;products\u0026#34;, filter=\u0026#39;name == \u0026#34;iPhone 15\u0026#34;\u0026#39;, # Directly use dynamic field name output_fields=[\u0026#34;product_id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;category\u0026#34;, \u0026#34;price\u0026#34;] ) # Or query through $meta results = client.query( collection_name=\u0026#34;products\u0026#34;, filter=\u0026#39;$meta[\u0026#34;category\u0026#34;] == \u0026#34;Electronics\u0026#34;\u0026#39;, output_fields=[\u0026#34;product_id\u0026#34;, \u0026#34;$meta\u0026#34;] ) # Compare with MongoDB # db.products.find({\u0026#34;name\u0026#34;: \u0026#34;iPhone 15\u0026#34;}) 7. Complete Schema Example\rfrom pymilvus import MilvusClient, DataType # Connect client client = MilvusClient(uri=\u0026#34;http://localhost:19530\u0026#34;, token=\u0026#34;root:Milvus\u0026#34;) # Create Schema schema = client.create_schema( enable_dynamic_field=True # Enable dynamic fields ) # 1. Primary key field (Auto ID) schema.add_field( field_name=\u0026#34;product_id\u0026#34;, datatype=DataType.INT64, is_primary=True, auto_id=True ) # 2. String field schema.add_field( field_name=\u0026#34;product_name\u0026#34;, datatype=DataType.VARCHAR, max_length=255 ) # 3. Numeric field schema.add_field( field_name=\u0026#34;product_price\u0026#34;, datatype=DataType.FLOAT ) # 4. JSON field schema.add_field( field_name=\u0026#34;product_detail\u0026#34;, datatype=DataType.JSON ) # 5. Array field schema.add_field( field_name=\u0026#34;product_tags\u0026#34;, datatype=DataType.ARRAY, element_type=DataType.VARCHAR, max_capacity=10, max_length=50 ) # 6. Timestamp field schema.add_field( field_name=\u0026#34;created_at\u0026#34;, datatype=DataType.TIMESTAMPTZ ) # 7. Struct array schema.add_field( field_name=\u0026#34;reviews\u0026#34;, datatype=DataType.ARRAY, element_type=DataType.STRUCT, max_capacity=100, element_schema={ \u0026#34;fields\u0026#34;: [ {\u0026#34;name\u0026#34;: \u0026#34;user_id\u0026#34;, \u0026#34;type\u0026#34;: DataType.INT64}, {\u0026#34;name\u0026#34;: \u0026#34;rating\u0026#34;, \u0026#34;type\u0026#34;: DataType.INT32}, {\u0026#34;name\u0026#34;: \u0026#34;comment\u0026#34;, \u0026#34;type\u0026#34;: DataType.VARCHAR, \u0026#34;max_length\u0026#34;: 500}, {\u0026#34;name\u0026#34;: \u0026#34;review_vector\u0026#34;, \u0026#34;type\u0026#34;: DataType.FLOAT_VECTOR, \u0026#34;dim\u0026#34;: 64} ] } ) # 8. Geometry field schema.add_field( field_name=\u0026#34;store_location\u0026#34;, datatype=DataType.GEOMETRY, default_value=\u0026#34;POINT(0 0)\u0026#34; ) # 9. Dense vector field schema.add_field( field_name=\u0026#34;product_embedding\u0026#34;, datatype=DataType.FLOAT_VECTOR, dim=128 ) # 10. Sparse vector field schema.add_field( field_name=\u0026#34;keyword_vector\u0026#34;, datatype=DataType.SPARSE_FLOAT_VECTOR ) print(\u0026#34;‚úÖ Schema creation completed\u0026#34;) 8. Schema vs MySQL Comparison Summary\rOperation Milvus MySQL Create Schema client.create_schema() CREATE TABLE Add Field schema.add_field() ALTER TABLE ADD COLUMN Primary Key Definition is_primary=True PRIMARY KEY Auto ID auto_id=True AUTO_INCREMENT Nullable Field nullable=True NULL Default Value default_value=value DEFAULT value Vector Fields FLOAT_VECTOR etc. No equivalent type Dynamic Fields enable_dynamic_field=True None (need JSON or NoSQL) 9. Best Practices\r9.1 Field Naming Conventions\r# ‚úÖ Recommended \u0026#34;product_id\u0026#34; \u0026#34;user_name\u0026#34; \u0026#34;created_at\u0026#34; # ‚ùå Avoid \u0026#34;Product-ID\u0026#34; # Avoid hyphens \u0026#34;Áî®Êà∑Âêç\u0026#34; # Avoid non-ASCII \u0026#34;field name\u0026#34; # Avoid spaces 9.2 Vector Dimension Selection\rScenario Recommended Dimensions Model Examples Text Embedding 384-768 sentence-transformers Image Embedding 512-2048 ResNet, CLIP Multimodal 512-1024 CLIP, ALIGN 9.3 Index Strategy\r# Create index for vector fields index_params = MilvusClient.prepare_index_params() # HNSW index (recommended for high-precision search) index_params.add_index( field_name=\u0026#34;product_embedding\u0026#34;, index_type=\u0026#34;HNSW\u0026#34;, metric_type=\u0026#34;COSINE\u0026#34;, params={\u0026#34;M\u0026#34;: 16, \u0026#34;efConstruction\u0026#34;: 256} ) # IVF_FLAT index (suitable for large-scale data) index_params.add_index( field_name=\u0026#34;image_embedding\u0026#34;, index_type=\u0026#34;IVF_FLAT\u0026#34;, metric_type=\u0026#34;L2\u0026#34;, params={\u0026#34;nlist\u0026#34;: 1024} ) 10. Key Points Summary\rSchema Flexibility: Milvus supports dynamic fields, more flexible than traditional relational databases Native Vector Support: Vector fields are first-class citizens, no extra conversion needed Rich Types: Supports JSON, arrays, structs and other complex types Timezone Awareness: TIMESTAMPTZ provides native timezone support Index Optimization: JSON shredding, vector indexing and other optimization techniques NoSQL Integration: Dynamic fields similar to MongoDB, but retain Schema constraint advantages ","date":"2026-02-26T19:10:45+08:00","permalink":"https://zg-dd.github.io/en/stu/milvus-stu-schema/","title":"Milvus Schema Detailed Guide - Field Types and Data Modeling"},{"content":"Introduction\rMilvus is an open-source vector database designed specifically for handling large-scale vector data, supporting vector similarity search, real-time queries, and other features. The Standalone mode is Milvus\u0026rsquo;s single-machine embedded deployment method, suitable for learning, testing, and small-scale applications. It runs using Docker containers with embedded etcd as metadata storage, requiring no external dependencies.\nDuring the actual installation process, I encountered multiple issues including non-existent image tags, network connection refusals, container permission issues causing startup failures (Exited 134), and scripts getting stuck in waiting states. This article is based on real installation experience on a VMware Ubuntu virtual machine on February 24, 2026, providing complete steps and systematically summarizing problems and solutions. The host machine configuration is Intel Core i9-12900H + 16 GB RAM.\nEnvironment Preparation\rSystem Requirements\rUbuntu 20.04 or higher version (22.04 LTS recommended) Docker 20.10 or higher version Minimum VM configuration recommendation: 8-12 GB RAM, 4-8 vCPU (recommended 1 processor √ó 6-8 cores) Network: Domestic mirror accelerator recommended Configure Docker Image Accelerator\rEdit /etc/docker/daemon.json:\n{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.xuanyuan.me\u0026#34;, \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34;, \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; ] } Restart Docker:\nsudo systemctl daemon-reload sudo systemctl restart docker Verify accelerator configuration:\nsudo docker info | grep -A 10 \u0026#34;Registry Mirrors\u0026#34; Installation Steps\r1. Download Official Standalone Embedded Startup Script\rwget https://raw.githubusercontent.com/milvus-io/milvus/master/scripts/standalone_embed.sh chmod +x standalone_embed.sh 2. Modify Image Tag (v2.6.11 Not Pushed, Use Latest Available Build from Master Branch)\rEdit standalone_embed.sh, find the image line in the docker run command, change:\nmilvusdb/milvus:v2.6.11 \\ to:\nmilvusdb/milvus:master-20260224-091b147e-amd64 \\ or a more stable previous day version:\nmilvusdb/milvus:master-20260223-49bf0b63-amd64 \\ Save the file.\n3. Create and Set Data Directory Permissions (Most Critical Step, Avoid Permission Denial)\r# Delete old directory (prevent residual permission errors) rm -rf ./volumes/milvus # Create new directory mkdir -p ./volumes/milvus # Set owner and permissions (ensure non-root user in container can write) sudo chown -R $USER:$USER ./volumes/milvus chmod -R 775 ./volumes/milvus # Verify permissions (should show drwxrwxr-x ai-stu ai-stu) ls -ld ./volumes/milvus 4. Start Milvus\rbash standalone_embed.sh start 5. Verify Success\rWait for script output \u0026ldquo;Start successfully.\u0026rdquo;\nCheck container status:\nsudo docker ps Should show Up ... (healthy)\nTest health endpoint:\ncurl http://localhost:19530/healthz Should return \u0026quot;ok\u0026quot;\nCommon Problems Summary and Solutions\rProblem 1: Image Pull Failure (not found / connection refused)\rPhenomenon:\nUnable to find image ... not found or dial tcp ... connection refused Cause:\nv2.6.11 tag not yet pushed to Docker Hub Domestic network access to registry-1.docker.io is restricted Solutions:\nUse stable version tags: Switch to released stable versions like v2.6.10 sudo docker run -d \\ --name milvus-standalone \\ --gpus all \\ -e ETCD_USE_EMBED=true \\ -e COMMON_STORAGETYPE=local \\ -p 19530:19530 \\ -v ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/milvus:/var/lib/milvus \\ milvusdb/milvus:v2.6.10 Configure domestic accelerators (Xuanyuan, Alibaba Cloud, NetEase, etc.) Offline transfer method: pull + save on accessible network machine: docker pull milvusdb/milvus:master-20260224-091b147e-amd64 docker save -o milvus.tar milvusdb/milvus:master-20260224-091b147e-amd64 gzip milvus.tar Load after transferring to server:\ngunzip milvus.tar.gz sudo docker load -i milvus.tar Problem 2: Container Exits Immediately After Startup (Exited 134)\rPhenomenon:\nsudo docker ps -a shows Exited (134) Cause:\nSIGABRT signal, internal process abort Usually caused by permission denial, initialization failure, or insufficient memory Solutions:\nCheck logs: sudo docker logs milvus-standalone --tail 100 Increase VM memory to 8-12 GB Clean and reset permissions (see step 3) Try more stable tags (such as master-20260223-49bf0b63-amd64) Problem 3: Permission Denied (mkdir /var/lib/milvus/data/: permission denied)\rPhenomenon:\nLogs show [FATAL] ... permission denied and panic Cause:\nHost ./volumes/milvus directory lacks sufficient permissions Non-root user in container cannot create subdirectories Solutions:\nMust delete old directory first: rm -rf ./volumes/milvus Recreate and set permissions (step 3) Recommend using 775 permissions to ensure group writability Problem 4: Script Stuck at \u0026ldquo;Wait for Milvus Starting\u0026hellip;\u0026rdquo;\rPhenomenon:\nScript shows no output for extended period Cause:\nContainer hasn\u0026rsquo;t reached healthy state (crashed or health check failed) Solutions:\nCheck status in new terminal: sudo docker ps -a View real-time logs: sudo docker logs -f milvus-standalone Manually test health endpoint: curl http://localhost:19530/healthz Clean data volumes and retry ","date":"2026-02-24T19:07:58+08:00","permalink":"https://zg-dd.github.io/en/stu/milvus-install-guide/","title":"Complete Guide to Installing Milvus Standalone Mode and Common Problem Solutions"},{"content":" Personal study notes\nChapter 1: What are Skills\r1.1 Introduction to Skills\rSkills are an extension system for Claude Code, similar to installing \u0026ldquo;skill packs\u0026rdquo; for Claude.\nSimple Understanding:\nLike mobile apps: you can install different apps on your phone to achieve different functions Skills are \u0026ldquo;functional plugins\u0026rdquo; installed for Claude Each Skill teaches Claude a new capability Examples:\nInstall docx skill ‚Üí Claude can create and edit Word documents Install pdf skill ‚Üí Claude can process PDF files Install mysql-manager skill ‚Üí Claude can operate databases 1.2 Types of Skills\rOfficial Skills (Provided by Anthropic)\rDeveloped and maintained by Claude\u0026rsquo;s official team Guaranteed quality and stable functionality Free to use Examples: docx, pdf, pptx, xlsx, etc. Community Skills (Third-party Development)\rContributed by community developers Diverse functionalities Quality needs to be evaluated independently Custom Skills (Created by You)\rCustomized according to your needs Fully controllable This tutorial will teach you how to create them 1.3 Why Use Skills\rWithout Skills:\nYou: Help me create a Word document Claude: Sorry, I cannot directly create Word documents With Skills:\nYou: Help me create a Word document Claude: OK! (Automatically uses docx skill to create document) Advantages of Skills:\n‚úÖ Extend Claude\u0026rsquo;s capabilities ‚úÖ Automate repetitive tasks ‚úÖ Improve work efficiency ‚úÖ Can customize exclusive functions 1.4 How Skills Work\rYour request ‚Üí Claude analyzes ‚Üí Select appropriate Skill ‚Üí Execute operation ‚Üí Return results Example Process:\nYou say: \u0026ldquo;Create a Word document\u0026rdquo; Claude identifies that document processing is needed Claude calls the docx skill docx skill executes document creation code Returns the created document Chapter 2: Environment Preparation\r2.1 Prerequisites\rBefore starting, ensure you have installed:\nRequired Software\r1. Claude Code CLI\nThis is Claude\u0026rsquo;s command-line tool If you can run Claude Code, it means you\u0026rsquo;ve already installed it Check method: claude --version 2. Node.js (Required for some skills)\nVersion requirement: 14.0 or higher Check installation: node --version npm --version If not installed, visit: https://nodejs.org/ Download LTS (Long Term Support) version 3. Git (Optional, for cloning official repository)\nCheck installation: git --version If not installed, visit: https://git-scm.com/ 2.2 Understanding File Locations\rImportant Directory Structure:\nYour user directory/ ‚îú‚îÄ‚îÄ .claude/ # Claude configuration directory ‚îÇ ‚îú‚îÄ‚îÄ skills/ # Custom skills storage location ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ mysql-manager/ # Example: custom skill ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ SKILL.md # Skill definition file ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ config.json # Configuration file ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ mysql-tool.js # Tool script ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ README.md # Documentation ‚îÇ ‚îú‚îÄ‚îÄ plugins/ # Plugins directory ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ marketplaces/ # Skills marketplace ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ anthropic-agent-skills/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ skills/ # Official skills ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ docx/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ pdf/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ... ‚îÇ ‚îî‚îÄ‚îÄ config.json # Global configuration file Paths on Different Operating Systems:\nWindows:\nUser directory: C:\\Users\\YourUsername\\ Claude directory: C:\\Users\\YourUsername\\.claude\\ View method: echo %USERPROFILE%\\.claude Mac:\nUser directory: /Users/YourUsername/ Claude directory: /Users/YourUsername/.claude/ View method: echo ~/.claude Linux:\nUser directory: /home/YourUsername/ Claude directory: /home/YourUsername/.claude/ View method: echo ~/.claude 2.3 Environment Check\rStep 1: Check Claude Code\nclaude --version Expected output: Shows version number\nStep 2: Check Node.js\nnode --version npm --version Expected output: Shows version number (e.g., v20.9.0)\nStep 3: Check Configuration Directory\n# Windows dir %USERPROFILE%\\.claude # Mac/Linux ls -la ~/.claude Expected output: Shows .claude directory contents\nChapter 3: Installing Official Skills\r3.1 Adding Official Skills Marketplace\rStep 1: Start Claude Code\nIn terminal or command line:\nclaude-code Step 2: Add Official Marketplace\nIn Claude Code, enter:\n/plugin marketplace add anthropics/skills Expected Result:\nSuccessfully added marketplace: anthropic-agent-skills What did this do?\nConnected to Anthropic\u0026rsquo;s official skills repository (GitHub) Downloaded skills list to your computer Storage location: ~/.claude/plugins/marketplaces/anthropic-agent-skills/ But hasn\u0026rsquo;t installed specific skills yet What if it fails?\nCheck network connection Ensure GitHub access Try using proxy (if in China) 3.2 Browsing Available Skills\rMethod 1: Browse via Command\n/plugin browse Method 2: View Downloaded Skills\n# Windows dir %USERPROFILE%\\.claude\\plugins\\marketplaces\\anthropic-agent-skills\\skills # Mac/Linux ls ~/.claude/plugins/marketplaces/anthropic-agent-skills/skills/ Available Skills:\nSkill Name Function Description Use Cases docx Word document processing Create reports, edit documents pdf PDF file processing Extract text, merge PDFs pptx PowerPoint presentations Create slides xlsx Excel spreadsheets Data processing, table creation frontend-design Frontend design Web design, UI components algorithmic-art Algorithmic art Generate art, animations canvas-design Canvas design Posters, graphic design mcp-builder MCP servers API integration webapp-testing Web testing Automated testing skill-creator Skill creation Create custom skills More\u0026hellip; \u0026hellip; \u0026hellip; 3.3 Installing Skills\rMethod 1: Install Example Skills Package (Recommended for Beginners)\r/plugin install example-skills@anthropic-agent-skills This command will install:\nAll example skills (16 total) Including document processing, design, development, etc. Suitable for learning and daily use Expected Result:\n‚úì Installed example-skills. Restart Claude Code to load new plugins. Method 2: Install Document Skills Package\rIf you only need document processing functions:\n/plugin install document-skills@anthropic-agent-skills This command will install:\ndocx (Word) pdf (PDF) pptx (PowerPoint) xlsx (Excel) Method 3: Install Single Skill (Advanced)\r/plugin install docx@anthropic-agent-skills 3.4 Restart Claude Code\rImportant: Must restart Claude Code after installation for changes to take effect!\nSteps:\nExit current Claude Code session\nEnter exit or Press Ctrl+C (Windows/Linux) or Cmd+C (Mac) Restart:\nclaude-code 3.5 Verify Installation\rMethod 1: Ask Claude\rIn Claude Code, enter:\nWhat skills do you have? List all available skills Claude will list all installed skills.\nMethod 2: Test a Skill\rHelp me create a test Word document If Claude successfully creates the document, skills installation succeeded!\nMethod 3: View System Information\r# View installed skills ls ~/.claude/plugins/cache/ Chapter 4: Using Skills\r4.1 Three Ways to Use Skills\rMethod 1: Natural Language (Recommended for Beginners)\rDirectly describe your needs in everyday language, Claude will automatically select the appropriate skill.\nExamples:\nCreate a Word document Process this PDF file Design a login page Query database Advantages:\nSimplest, no need to remember skill names Claude automatically determines which skill to use Suitable for daily use Disadvantages:\nSometimes Claude might choose the wrong skill Not precise enough Method 2: Explicitly Specify Skill\rIf you know which skill to use, you can specify it explicitly.\nExamples:\nUse docx skill to create report Use pdf skill to extract text Use mysql-manager to query data Advantages:\nMore precise Avoids Claude choosing wrong skill Suitable for repetitive tasks Disadvantages:\nNeed to remember skill names Method 3: Direct Command Call (Advanced Users)\rFor custom skills, can call commands directly.\nExamples:\ncd ~/.claude/skills/mysql-manager node mysql-tool.js list-databases Advantages:\nFastest Full control Suitable for scripting Disadvantages:\nNeed command-line knowledge Need to know specific commands 4.2 Common Skills Usage Examples\rüìÑ Document Processing Skills\rCreate Word Document (docx):\nBasic usage:\nCreate a Word document Detailed usage:\nCreate a project report document, including: - Title: 2024 Annual Summary - Subtitle: Technical Department - Three chapters: Background, Implementation, Results - One data table - Footer with date Save as report.docx Process PDF (pdf):\nExtract text:\nExtract all text from report.pdf Merge PDFs:\nMerge file1.pdf and file2.pdf into merged.pdf Split PDF:\nExtract pages 1-5 from document.pdf as new file Create PowerPoint (pptx):\nCreate a product introduction presentation, including: - Cover page - Product features (3 pages) - Pricing plan (1 page) - Contact information (1 page) Process Excel (xlsx):\nCreate a sales data spreadsheet, including: - Columns: Date, Product, Quantity, Amount - 10 rows of test data - Add sum formulas üé® Design Skills\rFrontend Design (frontend-design):\nLogin page:\nDesign a modern-style login page, including: - Username and password input fields - Remember me option - Login button - Blue theme Navigation bar:\nCreate a responsive navigation bar, including: - Logo - Home, Products, About Us, Contact - Mobile hamburger menu Algorithmic Art (algorithmic-art):\nCreate an animation with particle system, including: - 1000 particles - Random colors - Mouse interaction Canvas Design (canvas-design):\nDesign an event poster: - Theme: Spring Sale - Size: A4 - Include title, date, QR code üõ†Ô∏è Development Skills\rWeb Testing (webapp-testing):\nTest login functionality on localhost:3000: 1. Open page 2. Enter username and password 3. Click login button 4. Take screenshot and save MCP Builder (mcp-builder):\nCreate an MCP server connecting to GitHub API, functions: - Get repository list - Create Issue - View Pull Request 4.3 Skills Usage Tips\rTip 1: Provide Detailed Information\rPoor Example:\nCreate a document Too vague Claude doesn\u0026rsquo;t know what content to create Good Example:\nCreate a Word document, filename report.docx, including: - Title: Project Report - Three chapters: Background, Solution, Conclusion - Each chapter contains 2-3 paragraphs - Save to current directory Clear and specific Claude knows exactly what to do Tip 2: Operate Step by Step\rFor complex tasks, proceed step by step:\nStep 1: First help me check what tables are in the database (wait for results) Step 2: Query the structure of users table (wait for results) Step 3: Export users table as CSV Why step by step?\nEach step can confirm results Easy to locate problems when errors occur Can adjust next step based on results Tip 3: Check What Skills Can Do\rWhat functions does docx skill have? What can pdf skill do? What operations does mysql-manager support? Claude will list all functions of that skill.\nTip 4: Provide Examples\rIf you have reference styles:\nCreate a document similar to example.docx, but change content to... Tip 5: Specify Output Location\rCreate document and save to desktop Export data to D:/exports/ directory 4.4 Common Usage Scenarios\rScenario 1: Daily Office Work\rRequirement: Write weekly work reports\nUsing Skills:\nUse docx skill to create this week\u0026#39;s work report: - Title: Week X Work Report - Completed work this week (list) - Next week\u0026#39;s plans (list) - Encountered problems Scenario 2: Data Processing\rRequirement: Process Excel data\nUsing Skills:\nUse xlsx skill: 1. Read sales.xlsx 2. Filter records with amount greater than 1000 3. Sort by date 4. Export as new file Scenario 3: Web Development\rRequirement: Quickly create page prototypes\nUsing Skills:\nUse frontend-design skill to create: - A product display page - Including image carousel - Product card grid - Responsive layout Scenario 4: Database Management\rRequirement: Regular database backups\nUsing Skills:\nUse mysql-manager skill: 1. Backup production database 2. Save to /backups/ directory 3. Filename includes date Chapter 6: Practical Case - MySQL Database Management Skill\rThis chapter will teach you how to create a powerful MySQL database management Skill through a complete practical case.\n6.1 Requirements Analysis\rGoal: Create a Skill to manage MySQL databases\nFunctional Requirements:\nDatabase management (create, delete, list) Table management (create, delete, view structure) Data querying (SELECT, statistics) Data operations (insert, update, delete) Import/export (CSV, JSON, SQL) Backup and recovery User management Performance analysis Technology Selection:\nNode.js + mysql2 library Configuration file stores connection information Command-line tool implements various operations 6.2 Creating Skill Structure\rStep 1: Create Directory\nmkdir -p ~/.claude/skills/mysql-manager cd ~/.claude/skills/mysql-manager Step 2: Initialize npm Project\nnpm init -y npm install mysql2 6.3 Creating Configuration File\rconfig.json:\n{ \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 3306, \u0026#34;user\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;database\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;charset\u0026#34;: \u0026#34;utf8mb4\u0026#34;, \u0026#34;connectionLimit\u0026#34;: 10, \u0026#34;connectTimeout\u0026#34;: 10000, \u0026#34;backupPath\u0026#34;: \u0026#34;~/.claude/skills/mysql-manager/backups\u0026#34; } Configuration Explanation:\nhost: Database server address port: Port number (default 3306) user: Database username password: Database password database: Default database (can be empty) backupPath: Backup file storage path Security Note:\n# Set configuration file permissions (owner read/write only) chmod 600 config.json 6.4 Creating Core Tool Script\rmysql-tool.js (Core functionality implementation):\n#!/usr/bin/env node const mysql = require(\u0026#39;mysql2/promise\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;).promises; const path = require(\u0026#39;path\u0026#39;); // Load configuration async function loadConfig() { const configPath = path.join(__dirname, \u0026#39;config.json\u0026#39;); const configData = await fs.readFile(configPath, \u0026#39;utf8\u0026#39;); return JSON.parse(configData); } // Create database connection async function createConnection(dbName = null) { const config = await loadConfig(); if (dbName) { config.database = dbName; } return await mysql.createConnection(config); } // List all databases async function listDatabases() { const conn = await createConnection(); const [rows] = await conn.execute(\u0026#39;SHOW DATABASES\u0026#39;); await conn.end(); return rows.map(row =\u0026gt; row.Database); } // List all tables async function listTables(dbName) { const conn = await createConnection(dbName); const [rows] = await conn.execute(\u0026#39;SHOW TABLES\u0026#39;); await conn.end(); return rows.map(row =\u0026gt; Object.values(row)[0]); } // Query data async function selectAll(dbName, tableName, limit = 100) { const conn = await createConnection(dbName); const [rows] = await conn.execute( `SELECT * FROM \\`${tableName}\\` LIMIT ?`, [limit] ); await conn.end(); return rows; } // Main function async function main() { const args = process.argv.slice(2); const command = args[0]; try { let result; switch (command) { case \u0026#39;list-databases\u0026#39;: result = await listDatabases(); break; case \u0026#39;list-tables\u0026#39;: result = await listTables(args[1]); break; case \u0026#39;select-all\u0026#39;: result = await selectAll(args[1], args[2], parseInt(args[3] || 100)); break; default: console.error(\u0026#39;Unknown command:\u0026#39;, command); process.exit(1); } console.log(JSON.stringify(result, null, 2)); } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error.message); process.exit(1); } } if (require.main === module) { main(); } Set Execution Permissions:\nchmod +x mysql-tool.js 6.5 Creating SKILL.md\r--- name: mysql-manager description: Comprehensive MySQL database management tool. Supports connecting to databases, executing queries, data import/export, backup/restore, table structure management, etc. Requires configuration of database connection information before use. --- # MySQL Database Management Skill This skill provides comprehensive MySQL database operation functions. ## Configuration Database connection information is stored in `~/.claude/skills/mysql-manager/config.json`. Default configuration: ```json { \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 3306, \u0026#34;user\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;root\u0026#34; } Supported Operations\rDatabase Management\rList all databases Create database Delete database View database size Table Management\rList all tables Create table Delete table View table structure Data Query\rSELECT queries Conditional queries Statistical queries Data Operations\rInsert data Update data Delete data Import/Export\rExport to CSV Export to JSON Export to SQL Import from SQL Backup and Recovery\rBackup database Restore database Usage Examples\rUse mysql-manager to list all databases Use mysql-manager to query data from users table Use mysql-manager to backup mydb database Security Considerations\rConfiguration file contains sensitive information, ensure permissions are set correctly Use read-only users for queries in production environments Confirm before deletion operations Regularly backup important data ### 6.6 Creating Usage Documentation **README.md**: ```markdown # MySQL Manager Skill Usage Guide ## Installation 1. Create directory: ```bash mkdir -p ~/.claude/skills/mysql-manager cd ~/.claude/skills/mysql-manager Install dependencies: npm install mysql2 Configure database connection: Edit config.json file Command Reference\rDatabase Management\r# List all databases node mysql-tool.js list-databases # List all tables node mysql-tool.js list-tables mydb # Query data node mysql-tool.js select-all mydb users 10 Using in Claude Code\rUse mysql-manager to list all databases Use mysql-manager to query data from users table in test database Use mysql-manager to backup mydb database Troubleshooting\rConnection Failed\rCheck:\nWhether MySQL service is running Whether connection information in configuration file is correct Whether firewall allows connections ### 6.7 Testing the Skill **Step 1: Test Connection** ```bash cd ~/.claude/skills/mysql-manager node mysql-tool.js list-databases Expected Output:\n[ \u0026#34;information_schema\u0026#34;, \u0026#34;mysql\u0026#34;, \u0026#34;performance_schema\u0026#34;, \u0026#34;test\u0026#34; ] Step 2: Test in Claude Code\nRestart Claude Code, then:\nUse mysql-manager to list all databases Step 3: Test Query Function\nUse mysql-manager to query first 10 data from users table in test database 6.8 Extending Functions\rAdding More Commands:\nCreate Database: async function createDatabase(dbName) { const conn = await createConnection(); await conn.execute(`CREATE DATABASE IF NOT EXISTS \\`${dbName}\\``); await conn.end(); return `Database ${dbName} created successfully`; } Export to CSV: async function exportToCSV(dbName, tableName, outputPath) { const conn = await createConnection(dbName); const [rows] = await conn.execute(`SELECT * FROM \\`${tableName}\\``); await conn.end(); const headers = Object.keys(rows[0]).join(\u0026#39;,\u0026#39;); const csvRows = rows.map(row =\u0026gt; Object.values(row).map(val =\u0026gt; typeof val === \u0026#39;string\u0026#39; ? `\u0026#34;${val}\u0026#34;` : val ).join(\u0026#39;,\u0026#39;) ); const csv = [headers, ...csvRows].join(\u0026#39;\\n\u0026#39;); await fs.writeFile(outputPath, csv, \u0026#39;utf8\u0026#39;); return `Export successful: ${outputPath}`; } Backup Database: async function backupDatabase(dbName, outputPath) { const cmd = `mysqldump -u ${config.user} -p${config.password} ${dbName} \u0026gt; \u0026#34;${outputPath}\u0026#34;`; await execPromise(cmd); return `Backup successful: ${outputPath}`; } 6.9 Practical Exercises\rTask 1: View Database List\nUse mysql-manager to list all databases Task 2: Query Table Data\nUse mysql-manager to query first 10 data from t_user table in test database Task 3: Insert Test Data\nUse mysql-manager to insert 10 test data records into t_user table in test database Task 4: Export Data\nUse mysql-manager to export t_user table as CSV file Task 5: Backup Database\nUse mysql-manager to backup test database 6.10 Summary\rThrough this practical case, you learned:\n‚úÖ How to plan Skill functions ‚úÖ How to create Skill directory structure ‚úÖ How to write configuration files ‚úÖ How to implement core functions ‚úÖ How to write SKILL.md ‚úÖ How to test Skills ‚úÖ How to extend functions Key Points:\nSeparate sensitive information in configuration files Error handling should be complete Documentation should be detailed Testing should be thorough Chapter 7: Common Problems and Solutions\r7.1 Installation Issues\rProblem 1: Cannot Add Official Marketplace\rError Message:\nFailed to add marketplace Possible Causes:\nNetwork connection issues Cannot access GitHub Proxy configuration issues Solutions:\nCheck network connection: ping github.com Configure Git proxy (if in China): git config --global http.proxy http://proxy.example.com:8080 git config --global https.proxy https://proxy.example.com:8080 Use VPN or proxy Problem 2: Skills Don\u0026rsquo;t Show After Installation\rSymptoms:\nInstallation successful but Claude doesn\u0026rsquo;t see skills Asking \u0026ldquo;What skills do you have?\u0026rdquo; shows nothing Solutions:\nRestart Claude Code (most common cause): # Exit exit # Restart claude-code Check Installation Location: ls ~/.claude/plugins/cache/ Reinstall: /plugin uninstall example-skills /plugin install example-skills@anthropic-agent-skills Problem 3: Dependency Installation Failed\rError Message:\nnpm ERR! Cannot find module \u0026#39;mysql2\u0026#39; Solutions:\nEnter skill directory: cd ~/.claude/skills/mysql-manager Install dependencies: npm install mysql2 If still failing, clear cache: npm cache clean --force npm install 7.2 Usage Issues\rProblem 4: Skill Execution Failed\rError Message:\nError: Command failed Troubleshooting Steps:\nCheck if command is correct: # Manually test command cd ~/.claude/skills/mysql-manager node mysql-tool.js list-databases View error details: Claude usually shows detailed error information\nCheck permissions:\n# Ensure script has execution permissions chmod +x mysql-tool.js Check configuration file: # Validate JSON format cat config.json | python -m json.tool Problem 5: Claude Chose Wrong Skill\rSymptoms:\nYou want to use skill A, but Claude used skill B Solutions:\nExplicitly specify skill: Use docx skill to create document (instead of \u0026#34;create document\u0026#34;) Provide more detailed description: Use mysql-manager skill to query database Check SKILL.md description: Ensure description is clear and won\u0026rsquo;t confuse with other skills Problem 6: Configuration File Not Found\rError Message:\nError: ENOENT: no such file or directory Solutions:\nCheck if file exists: ls ~/.claude/skills/mysql-manager/config.json Check path correctness: Use absolute path in script: const configPath = path.join(__dirname, \u0026#39;config.json\u0026#39;); Create configuration file: cd ~/.claude/skills/mysql-manager cat \u0026gt; config.json \u0026lt;\u0026lt; EOF { \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 3306 } EOF 7.3 Database Issues\rProblem 7: Cannot Connect to Database\rError Messages:\nError: connect ECONNREFUSED Error: Access denied for user Solutions:\nCheck if MySQL service is running: # Windows sc query MySQL # Mac brew services list | grep mysql # Linux systemctl status mysql Check connection information: # Test connection mysql -h localhost -u root -p Check firewall: # Linux sudo ufw status # Windows netsh advfirewall show allprofiles Check user permissions: -- Execute in MySQL SHOW GRANTS FOR \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39;; Problem 8: Backup Failed\rError Message:\nmysqldump: command not found Solutions:\nInstall MySQL client tools: # Ubuntu/Debian sudo apt-get install mysql-client # Mac brew install mysql-client # Windows # Download MySQL Installer Add to PATH (Windows): Add C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin to system PATH Use full path: const mysqldumpPath = \u0026#39;C:\\\\Program Files\\\\MySQL\\\\MySQL Server 8.0\\\\bin\\\\mysqldump.exe\u0026#39;; 7.4 Performance Issues\rProblem 9: Queries Are Slow\rSymptoms:\nQuerying large tables responds slowly Claude takes long time to respond Solutions:\nLimit query count: // Default limit 100 rows async function selectAll(dbName, tableName, limit = 100) { // ... } Add indexes: CREATE INDEX idx_name ON users(name); Use pagination: async function selectPage(dbName, tableName, page, pageSize) { const offset = (page - 1) * pageSize; const [rows] = await conn.execute( `SELECT * FROM \\`${tableName}\\` LIMIT ? OFFSET ?`, [pageSize, offset] ); return rows; } Problem 10: High Memory Usage\rSymptoms:\nNode.js process occupies large memory System becomes slow Solutions:\nUse streaming processing: const stream = conn.query(`SELECT * FROM large_table`).stream(); stream.on(\u0026#39;data\u0026#39;, (row) =\u0026gt; { // Process each row }); Close connections promptly: try { // Operations } finally { await conn.end(); } Limit connection pool size: { \u0026#34;connectionLimit\u0026#34;: 5 } 7.5 Document Issues\rProblem 11: Word Document Creation Failed\rError Message:\nCannot find module \u0026#39;docx\u0026#39; Solutions:\nInstall docx globally: npm install -g docx Or install in project: cd /path/to/project npm install docx Problem 12: PDF Processing Failed\rError Message:\npdftoppm: command not found Solutions:\nInstall Poppler: # Ubuntu/Debian sudo apt-get install poppler-utils # Mac brew install poppler # Windows # Download Poppler for Windows 7.6 Debugging Tips\rTip 1: Enable Detailed Logging\rAdd logging in script:\nconsole.log(\u0026#39;Starting execution:\u0026#39;, command); console.log(\u0026#39;Parameters:\u0026#39;, args); console.log(\u0026#39;Configuration:\u0026#39;, config); Tip 2: Use Debug Mode\r# Node.js debugging node --inspect mysql-tool.js list-databases Tip 3: Test Individual Functions\r# Test each function separately node -e \u0026#34;require(\u0026#39;./mysql-tool.js\u0026#39;).listDatabases().then(console.log)\u0026#34; Tip 4: View Claude Code Logs\r# View log directory ls ~/.claude/logs/ # View latest logs tail -f ~/.claude/logs/latest.log 7.7 Getting Help\rOfficial Resources\rClaude Code Documentation:\nhttps://docs.claude.com/ Skills Repository:\nhttps://github.com/anthropics/skills Issue Feedback:\nhttps://github.com/anthropics/claude-code/issues Community Resources\rDiscord Community Stack Overflow (tag: claude-code) GitHub Discussions Tips for Seeking Help\rProvide when asking:\nComplete error message Your operation steps System environment information Relevant configuration files (remove sensitive information) Good Question Example:\nProblem: mysql-manager skill cannot connect to database Environment: - OS: Windows 10 - Node.js: v20.9.0 - MySQL: 8.0.35 Error Message: Error: connect ECONNREFUSED 127.0.0.1:3306 Already Tried: 1. Confirmed MySQL service is running 2. Can connect with mysql command line 3. Information in configuration file is correct Configuration file (password removed): { \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 3306, \u0026#34;user\u0026#34;: \u0026#34;root\u0026#34; } Appendix: Complete Command Reference\rA. Claude Code Basic Commands\r# Start Claude Code claude-code # View version claude --version # View help claude --help # Exit exit B. Plugin Management Commands\r# Add marketplace /plugin marketplace add anthropics/skills # Browse plugins /plugin browse # Install plugin /plugin install example-skills@anthropic-agent-skills /plugin install document-skills@anthropic-agent-skills # Uninstall plugin /plugin uninstall example-skills # List installed plugins /plugin list C. File Operation Commands\rWindows\r# View directory dir %USERPROFILE%\\.claude # Enter directory cd %USERPROFILE%\\.claude\\skills # Create directory mkdir my-skill # Delete directory rmdir /s my-skill # View file content type config.json # Edit file notepad config.json Mac/Linux\r# View directory ls -la ~/.claude # Enter directory cd ~/.claude/skills # Create directory mkdir -p my-skill # Delete directory rm -rf my-skill # View file content cat config.json # Edit file nano config.json # or vim config.json D. Node.js Commands\r# Initialize project npm init -y # Install dependencies npm install mysql2 npm install docx # Global installation npm install -g docx # View installed packages npm list # Run script node script.js # Debug mode node --inspect script.js E. Git Commands\r# Clone repository git clone https://github.com/anthropics/skills.git # View status git status # Pull updates git pull # View logs git log --oneline -10 F. MySQL Commands\r# Connect to database mysql -h localhost -u root -p # Export database mysqldump -u root -p mydb \u0026gt; backup.sql # Import database mysql -u root -p mydb \u0026lt; backup.sql # View processes mysqladmin -u root -p processlist G. Common Skill Command Templates\rMySQL Manager\r# List databases node mysql-tool.js list-databases # List tables node mysql-tool.js list-tables mydb # Query data node mysql-tool.js select-all mydb users 10 # Export CSV node mysql-tool.js export-csv mydb users output.csv # Backup node mysql-tool.js backup mydb backup.sql File Statistics\r# Statistics current directory node file-stats.js . # Statistics specified directory node file-stats.js /path/to/directory Appendix B: Configuration File Templates\r1. SKILL.md Template\r--- name: skill-name description: Detailed description of this skill\u0026#39;s functions and usage scenarios --- # Skill Name Brief introduction. ## Functions - Function 1 - Function 2 - Function 3 ## Usage Detailed usage instructions... ## Examples Use skill-name to do something\n## Configuration If configuration is needed, explain here. ## Dependencies List required dependencies. ## Notes Important notes. 2. config.json Template\r{ \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 3306, \u0026#34;user\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;database\u0026#34;: \u0026#34;dbname\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; } } 3. package.json Template\r{ \u0026#34;name\u0026#34;: \u0026#34;skill-name\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Skill description\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;node test.js\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;mysql2\u0026#34;: \u0026#34;^3.0.0\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;Your Name\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34; } 4. README.md Template\r# Skill Name Brief description. ## Installation ```bash cd ~/.claude/skills/skill-name npm install Configuration\rEdit config.json:\n{ \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; } Usage\rCommand Line\rnode tool.js command Claude Code\rUse skill-name to do something Command Reference\rCommand Description Example command1 Description node tool.js command1 command2 Description node tool.js command2 ","date":"2026-02-14T10:21:18+08:00","permalink":"https://zg-dd.github.io/en/stu/claude-code-skills-complete-guide/","title":"Complete Guide to Claude Code Skills"},{"content":"Properties to YAML Conversion Tool User Manual\rüìã Overview\rThis is a powerful Python script tool for converting Java .properties configuration files to YAML format. The tool not only supports basic format conversion, but also features intelligent comment preservation, type inference, and structure maintenance functions.\nüìú Script\r#!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; PropertiesÊñá‰ª∂ËΩ¨YAMLÊñá‰ª∂Â∑•ÂÖ∑Ôºà‰ºòÂåñÁâàÔºâ ‰ºòÂåñÁÇπÔºö 1. ‰ΩøÁî®ÊôÆÈÄödictÊõø‰ª£OrderedDictÔºàPython 3.7+‰øùÊåÅÊèíÂÖ•È°∫Â∫èÔºâ 2. ÂáèÂ∞ëÊï∞ÊçÆÂÜó‰ΩôÂ≠òÂÇ® 3. ÁºìÂ≠òÈáçÂ§çÁöÑÂ≠óÁ¨¶‰∏≤Êìç‰Ωú 4. ÁÆÄÂåñÈÄªËæëÊµÅÁ®ã \u0026#34;\u0026#34;\u0026#34; import sys import argparse from pathlib import Path import yaml import re def infer_value_type(value_str): \u0026#34;\u0026#34;\u0026#34;Êé®Êñ≠ÂÄºÁöÑÁ±ªÂûãÂπ∂ËøîÂõûÈÄÇÂΩìÁöÑPythonÂØπË±°\u0026#34;\u0026#34;\u0026#34; if not isinstance(value_str, str): return value_str value_str = value_str.strip() # Á©∫ÂÄºÂ§ÑÁêÜ if value_str == \u0026#39;\u0026#39; or value_str.lower() in [\u0026#39;null\u0026#39;, \u0026#39;nil\u0026#39;]: return None # Â∏ÉÂ∞îÂÄº if value_str.lower() in [\u0026#39;true\u0026#39;, \u0026#39;false\u0026#39;]: return value_str.lower() == \u0026#39;true\u0026#39; # Êï∞Â≠óÔºàÊï¥Êï∞Ôºâ if \u0026#39;.\u0026#39; not in value_str and re.match(r\u0026#39;^-?\\d+$\u0026#39;, value_str): try: return int(value_str) except ValueError: pass # Êï∞Â≠óÔºàÊµÆÁÇπÊï∞Ôºâ if re.match(r\u0026#39;^-?\\d+\\.?\\d*$\u0026#39;, value_str): try: return float(value_str) except ValueError: pass # ÂéªÊéâÂèØËÉΩÁöÑÂºïÂè∑ if len(value_str) \u0026gt;= 2 and ( (value_str[0] == \u0026#39;\u0026#34;\u0026#39; and value_str[-1] == \u0026#39;\u0026#34;\u0026#39;) or (value_str[0] == \u0026#34;\u0026#39;\u0026#34; and value_str[-1] == \u0026#34;\u0026#39;\u0026#34;) ): return value_str[1:-1] return value_str def parse_properties_content(content): \u0026#34;\u0026#34;\u0026#34;Ëß£ÊûêpropertiesÊñá‰ª∂ÂÜÖÂÆπ\u0026#34;\u0026#34;\u0026#34; structure = [] lines = content.splitlines() for i, line in enumerate(lines): stripped = line.strip() # Ê≥®ÈáäË°å if stripped.startswith(\u0026#39;#\u0026#39;) or stripped.startswith(\u0026#39;!\u0026#39;): structure.append({ \u0026#39;type\u0026#39;: \u0026#39;comment\u0026#39;, \u0026#39;content\u0026#39;: stripped[1:].strip(), \u0026#39;line_num\u0026#39;: i + 1 }) continue # Á©∫Ë°å if not stripped: structure.append({\u0026#39;type\u0026#39;: \u0026#39;empty_line\u0026#39;, \u0026#39;line_num\u0026#39;: i + 1}) continue # Â±ûÊÄßË°å if \u0026#39;=\u0026#39; in stripped or \u0026#39;:\u0026#39; in stripped: separator = \u0026#39;=\u0026#39; if \u0026#39;=\u0026#39; in stripped else \u0026#39;:\u0026#39; key, value = stripped.split(separator, 1) key = key.strip() value = value.strip() structure.append({ \u0026#39;type\u0026#39;: \u0026#39;property\u0026#39;, \u0026#39;key\u0026#39;: key, \u0026#39;value\u0026#39;: infer_value_type(value), \u0026#39;line_num\u0026#39;: i + 1 }) else: print(f\u0026#34;Ë≠¶ÂëäÔºöÁ¨¨{i + 1}Ë°åÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºåË∑≥Ëøá: {stripped}\u0026#34;) return structure def build_comment_mapping(structure): \u0026#34;\u0026#34;\u0026#34;ÊûÑÂª∫Ê≥®ÈáäÂà∞Â±ûÊÄßÁöÑÊò†Â∞ÑÂÖ≥Á≥ª\u0026#34;\u0026#34;\u0026#34; comment_mapping = {} i = 0 while i \u0026lt; len(structure): if structure[i][\u0026#39;type\u0026#39;] != \u0026#39;comment\u0026#39;: i += 1 continue # Êî∂ÈõÜËøûÁª≠Ê≥®ÈáäÂùó comment_start = i comments = [] while i \u0026lt; len(structure) and structure[i][\u0026#39;type\u0026#39;] == \u0026#39;comment\u0026#39;: comments.append(structure[i][\u0026#39;content\u0026#39;]) i += 1 comment_end = i - 1 # Âà§Êñ≠Ê≥®ÈáäÂùóÁ±ªÂûãÂíåÁõÆÊ†áÂ±ûÊÄß prev_empty = (comment_start == 0 or structure[comment_start - 1][\u0026#39;type\u0026#39;] == \u0026#39;empty_line\u0026#39;) next_empty = (comment_end == len(structure) - 1 or structure[comment_end + 1][\u0026#39;type\u0026#39;] == \u0026#39;empty_line\u0026#39;) next_property = (comment_end \u0026lt; len(structure) - 1 and structure[comment_end + 1][\u0026#39;type\u0026#39;] == \u0026#39;property\u0026#39;) target_key = None position = None # Áã¨Á´ãÊ≥®ÈáäÂùóÔºà‰∏ä‰∏ãÈÉΩÊòØÁ©∫Ë°åÔºâ if prev_empty and next_empty: # Âêë‰∏äÊü•ÊâæÂ±ûÊÄß for j in range(comment_start - 1, -1, -1): if structure[j][\u0026#39;type\u0026#39;] == \u0026#39;property\u0026#39;: target_key = structure[j][\u0026#39;key\u0026#39;] position = \u0026#39;below\u0026#39; break # Âêë‰∏äÊ≤°ÊâæÂà∞ÔºåÂêë‰∏ãÊü•Êâæ if not target_key: for j in range(comment_end + 1, len(structure)): if structure[j][\u0026#39;type\u0026#39;] == \u0026#39;property\u0026#39;: target_key = structure[j][\u0026#39;key\u0026#39;] position = \u0026#39;above\u0026#39; break # ÂÖ≥ËÅîÊ≥®ÈáäÂùóÔºà‰∏ãÊñπÊòØÂ±ûÊÄßÔºâ elif next_property: target_key = structure[comment_end + 1][\u0026#39;key\u0026#39;] position = \u0026#39;above\u0026#39; # Ê∑ªÂä†Âà∞Êò†Â∞Ñ if target_key and position: if target_key not in comment_mapping: comment_mapping[target_key] = [] comment_mapping[target_key].append({ \u0026#39;comments\u0026#39;: comments, \u0026#39;position\u0026#39;: position }) return comment_mapping def dump_yaml_with_structure(structure): \u0026#34;\u0026#34;\u0026#34;ÁîüÊàêYAMLÂÜÖÂÆπ\u0026#34;\u0026#34;\u0026#34; # ÊûÑÂª∫Ê≥®ÈáäÊò†Â∞Ñ comment_mapping = build_comment_mapping(structure) # ÊèêÂèñÊâÄÊúâÂ±ûÊÄßÂπ∂ÊåâÁªÑÂàÜÁ±ª properties = [item for item in structure if item[\u0026#39;type\u0026#39;] == \u0026#39;property\u0026#39;] groups = {} # {top_level_key: [properties]} simple_props = [] # Êó†ÁÇπÂè∑ÁöÑÁÆÄÂçïÂ±ûÊÄß for prop in properties: key = prop[\u0026#39;key\u0026#39;] if \u0026#39;.\u0026#39; in key: top_key = key.split(\u0026#39;.\u0026#39;, 1)[0] if top_key not in groups: groups[top_key] = [] groups[top_key].append(prop) else: simple_props.append(prop) # ÁîüÊàêËæìÂá∫ output_lines = [] processed_keys = set() # ÊåâÂéüÂßãÈ°∫Â∫èÂ§ÑÁêÜ for item in structure: if item[\u0026#39;type\u0026#39;] != \u0026#39;property\u0026#39;: continue key = item[\u0026#39;key\u0026#39;] if key in processed_keys: continue # Â§ÑÁêÜÂàÜÁªÑÂ±ûÊÄß if \u0026#39;.\u0026#39; in key: top_key = key.split(\u0026#39;.\u0026#39;, 1)[0] if top_key in processed_keys: continue # Ê†áËÆ∞ËØ•ÁªÑÊâÄÊúâÂ±ûÊÄß‰∏∫Â∑≤Â§ÑÁêÜ for prop in groups[top_key]: processed_keys.add(prop[\u0026#39;key\u0026#39;]) # ËæìÂá∫ÁªÑÁ∫ß‰∏äÊñπÊ≥®ÈáäÔºà‰ΩøÁî®ÁªÑÂÜÖÁ¨¨‰∏Ä‰∏™Â±ûÊÄßÁöÑÊ≥®ÈáäÔºâ first_key = groups[top_key][0][\u0026#39;key\u0026#39;] if first_key in comment_mapping: for block in comment_mapping[first_key]: if block[\u0026#39;position\u0026#39;] == \u0026#39;above\u0026#39;: for comment in block[\u0026#39;comments\u0026#39;]: output_lines.append(f\u0026#34;# {comment}\u0026#34;) # ËæìÂá∫ÁªÑÂêç output_lines.append(f\u0026#34;{top_key}:\u0026#34;) # ËæìÂá∫ÁªÑÂÜÖÂ±ûÊÄß nested_path = [] for idx, prop in enumerate(groups[top_key]): prop_key = prop[\u0026#39;key\u0026#39;] value = prop[\u0026#39;value\u0026#39;] # Â±ûÊÄßÁ∫ß‰∏äÊñπÊ≥®ÈáäÔºàË∑≥ËøáÁ¨¨‰∏Ä‰∏™Â±ûÊÄßÁöÑÁªÑÁ∫ßÊ≥®ÈáäÔºâ if prop_key in comment_mapping and not (idx == 0 and prop_key == first_key): for block in comment_mapping[prop_key]: if block[\u0026#39;position\u0026#39;] == \u0026#39;above\u0026#39;: for comment in block[\u0026#39;comments\u0026#39;]: output_lines.append(f\u0026#34; # {comment}\u0026#34;) # ËæìÂá∫Â±ûÊÄß parts = prop_key.split(\u0026#39;.\u0026#39;)[1:] # ÂéªÊéâÈ°∂Â±Çkey if len(parts) == 1: # ‰∫åÁ∫ßÂ±ûÊÄß yaml_str = yaml.dump({parts[0]: value}, allow_unicode=True, default_flow_style=False, sort_keys=False).strip() output_lines.append(f\u0026#34; {yaml_str}\u0026#34;) else: # Â§öÁ∫ßÂµåÂ•ó for level, part in enumerate(parts[:-1]): path = parts[:level+1] if path != nested_path[:len(path)]: indent = \u0026#39; \u0026#39; * (level + 1) output_lines.append(f\u0026#34;{indent}{part}:\u0026#34;) nested_path = path[:] # ÊúÄÂêé‰∏ÄÁ∫ß final_indent = \u0026#39; \u0026#39; * len(parts) final_key = parts[-1] yaml_str = yaml.dump({final_key: value}, allow_unicode=True, default_flow_style=False, sort_keys=False).strip() value_part = yaml_str.split(\u0026#39;:\u0026#39;, 1)[1].strip() if \u0026#39;:\u0026#39; in yaml_str else str(value) output_lines.append(f\u0026#34;{final_indent}{final_key}: {value_part}\u0026#34;) # Â±ûÊÄßÁ∫ß‰∏ãÊñπÊ≥®Èáä if prop_key in comment_mapping: for block in comment_mapping[prop_key]: if block[\u0026#39;position\u0026#39;] == \u0026#39;below\u0026#39;: output_lines.append(\u0026#34;\u0026#34;) for comment in block[\u0026#39;comments\u0026#39;]: output_lines.append(f\u0026#34;# {comment}\u0026#34;) output_lines.append(\u0026#34;\u0026#34;) # Â§ÑÁêÜÁÆÄÂçïÂ±ûÊÄß else: processed_keys.add(key) # ‰∏äÊñπÊ≥®Èáä if key in comment_mapping: for block in comment_mapping[key]: if block[\u0026#39;position\u0026#39;] == \u0026#39;above\u0026#39;: for comment in block[\u0026#39;comments\u0026#39;]: output_lines.append(f\u0026#34;# {comment}\u0026#34;) # ËæìÂá∫Â±ûÊÄß output_lines.append(f\u0026#34;{key}: \u0026#39;{item[\u0026#39;value\u0026#39;]}\u0026#39;\u0026#34;) # ‰∏ãÊñπÊ≥®Èáä if key in comment_mapping: for block in comment_mapping[key]: if block[\u0026#39;position\u0026#39;] == \u0026#39;below\u0026#39;: output_lines.append(\u0026#34;\u0026#34;) for comment in block[\u0026#39;comments\u0026#39;]: output_lines.append(f\u0026#34;# {comment}\u0026#34;) output_lines.append(\u0026#34;\u0026#34;) # ÁßªÈô§Êú´Â∞æÁ©∫Ë°å while output_lines and output_lines[-1] == \u0026#34;\u0026#34;: output_lines.pop() return \u0026#39;\\n\u0026#39;.join(output_lines) def properties_to_yaml(properties_file_path): \u0026#34;\u0026#34;\u0026#34;ËΩ¨Êç¢propertiesÊñá‰ª∂‰∏∫YAMLÊ†ºÂºè\u0026#34;\u0026#34;\u0026#34; try: prop_path = Path(properties_file_path) if not prop_path.exists(): print(f\u0026#34;ÈîôËØØÔºöÊñá‰ª∂‰∏çÂ≠òÂú® - {properties_file_path}\u0026#34;) return False if not prop_path.is_file(): print(f\u0026#34;ÈîôËØØÔºöË∑ØÂæÑ‰∏çÊòØÊñá‰ª∂ - {properties_file_path}\u0026#34;) return False with open(prop_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() structure = parse_properties_content(content) yaml_content = dump_yaml_with_structure(structure) yaml_file_path = prop_path.with_suffix(\u0026#39;.yaml\u0026#39;) with open(yaml_file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(yaml_content) print(f\u0026#34;ÊàêÂäüËΩ¨Êç¢Ôºö{properties_file_path} -\u0026gt; {yaml_file_path}\u0026#34;) return True except Exception as e: print(f\u0026#34;ËΩ¨Êç¢Â§±Ë¥•Ôºö{properties_file_path}\u0026#34;) print(f\u0026#34;ÈîôËØØ‰ø°ÊÅØÔºö{str(e)}\u0026#34;) import traceback traceback.print_exc() return False def main(): \u0026#34;\u0026#34;\u0026#34;‰∏ªÂáΩÊï∞ÔºöÂ§ÑÁêÜÂëΩ‰ª§Ë°åÂèÇÊï∞Âπ∂ÊâßË°åËΩ¨Êç¢\u0026#34;\u0026#34;\u0026#34; parser = argparse.ArgumentParser(description=\u0026#39;Â∞ÜpropertiesÊñá‰ª∂ËΩ¨Êç¢‰∏∫yamlÊñá‰ª∂\u0026#39;) parser.add_argument(\u0026#39;files\u0026#39;, nargs=\u0026#39;+\u0026#39;, help=\u0026#39;Ë¶ÅËΩ¨Êç¢ÁöÑpropertiesÊñá‰ª∂Ë∑ØÂæÑ\u0026#39;) args = parser.parse_args() success_count = 0 fail_count = 0 print(\u0026#34;ÂºÄÂßãËΩ¨Êç¢propertiesÊñá‰ª∂Âà∞yamlÊ†ºÂºè...\u0026#34;) print(\u0026#34;=\u0026#34; * 50) for file_path in args.files: if properties_to_yaml(file_path): success_count += 1 else: fail_count += 1 print(\u0026#34;=\u0026#34; * 50) print(f\u0026#34;ËΩ¨Êç¢ÂÆåÊàêÔºÅÊàêÂäüÔºö{success_count}‰∏™ÔºåÂ§±Ë¥•Ôºö{fail_count}‰∏™\u0026#34;) return 1 if fail_count \u0026gt; 0 else 0 if __name__ == \u0026#39;__main__\u0026#39;: sys.exit(main()) üöÄ Main Features\r‚úÖ Core Functions\rMulti-file batch conversion - Support simultaneous conversion of multiple configuration files Intelligent type inference - Automatically identify boolean values, numbers, strings and other data types Complete comment preservation - Preserve all original comments and their positional relationships Structure order maintenance - Strictly maintain the key-value pair order of the original file Nested property handling - Intelligent processing of dot-separated hierarchical configurations üéØ Advanced Features\rComment intelligent positioning - Support precise position maintenance of above and below comments Independent comment processing - Intelligent processing of independent comment blocks in files UTF-8 encoding support - Perfect support for Chinese and other multilingual characters Error handling mechanism - Comprehensive error prompts and conversion statistics üì¶ Installation Requirements\rSystem Environment\rPython version: 3.6 or higher Operating system: Windows, Linux, macOS all supported Dependencies\rNeed to install PyYAML library:\npip install pyyaml üõ†Ô∏è Usage Methods\r1. Basic Usage\rConvert Single File\rpython properties_to_yaml.py config.properties Convert Multiple Files\rpython properties_to_yaml.py app.properties database.properties redis.properties 2. Path Usage\rAbsolute Path\rpython properties_to_yaml.py C:\\projects\\myapp\\config\\application.properties Relative Path\rpython properties_to_yaml.py ./config/dev.properties Current Directory File\rpython properties_to_yaml.py application.properties üìù Conversion Examples\rInput File Example (application.properties)\r# ========================================== # Application Core Configuration # ========================================== # Application Basic Information app.name=MyAwesomeApplication app.version=2.1.0 app.description=Enterprise Application Platform # Development Mode Switch app.debug=true # Database Connection Configuration database.host=localhost database.port=3306 database.username=admin database.password=secure_password_123 # Connection Pool Configuration database.pool.max-size=20 database.pool.min-idle=5 database.pool.max-wait=30000 # Other Configuration Items timeout=30000 max-connections=100 Output File Example (application.yaml)\r# ========================================== # Application Core Configuration # ========================================== # Application Basic Information app: name: MyAwesomeApplication version: 2.1.0 description: Enterprise Application Platform # Development Mode Switch debug: true # Database Connection Configuration database: host: localhost port: 3306 username: admin password: secure_password_123 # Connection Pool Configuration pool: max-size: 20 min-idle: 5 max-wait: 30000 # Other Configuration Items timeout: \u0026#39;30000\u0026#39; max-connections: \u0026#39;100\u0026#39; üîß Function Details\r1. Type Inference Mechanism\rThe tool can intelligently identify and maintain the following data types:\nProperties Value Inferred Type YAML Output Description true/false boolean true/false Boolean values 8080 integer 8080 Integers 30.5 float 30.5 Floating point numbers hello string hello Strings \u0026quot;hello world\u0026quot; string hello world Unquoted strings 2. Comment Processing Mechanism\rComment Type Recognition\rAssociated comments: Comments immediately preceding configuration items Independent comments: Comment blocks surrounded by blank lines File header comments: Comments at the beginning of the file Position Maintenance Strategy\r# This is above comment config.value=test # This is below comment After conversion:\n# This is above comment config: value: test # This is below comment 3. Nested Structure Processing\rDot-separated key names are automatically converted to YAML nested structures:\nProperties YAML database.host=localhost database: {host: localhost} spring.datasource.url=jdbc:... spring: {datasource: {url: jdbc:...}} 4. Order Maintenance Mechanism\rStrict order: Completely maintain the key-value pair order in the original properties file Hierarchical order: The hierarchical structure of nested properties also maintains the original order Comment order: The relative position of comments and configuration items is completely maintained ‚öôÔ∏è Advanced Usage\r1. Batch Processing Script\r# Batch convert all properties files in current directory for file in *.properties; do python properties_to_yaml.py \u0026#34;$file\u0026#34; done 2. Integration into CI/CD Pipeline\r# Using in GitHub Actions - name: Convert Properties to YAML run: | python properties_to_yaml.py config/*.properties 3. Import as Module\rfrom properties_to_yaml import parse_properties_content, dump_yaml_with_structure # Read and convert with open(\u0026#39;config.properties\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() parsed_data = parse_properties_content(content) yaml_result = dump_yaml_with_structure(parsed_data) print(yaml_result) üìä Output Format Description\rGenerated File Naming\rInput: application.properties Output: application.yaml Save location: Same directory as source file YAML Format Characteristics\rUses 2-space indentation Supports UTF-8 encoding Maintains clear hierarchical structure Comments start with # üö® Error Handling\rCommon Errors and Solutions\r1. File Not Found\rError: File does not exist - /path/to/config.properties Solution: Check if the file path is correct\n2. Format Error\rWarning: Line 5 format is incorrect, skipping: invalid=format=line Solution: Check properties file format, ensure using = or : separator\n3. Insufficient Permissions\rError: Permission denied - config.properties Solution: Check file read/write permissions\nüîç Troubleshooting\rDebugging Tips\rView Detailed Output python properties_to_yaml.py config.properties Check Generated YAML cat config.yaml Validate YAML Syntax python -c \u0026#34;import yaml; yaml.safe_load(open(\u0026#39;config.yaml\u0026#39;))\u0026#34; üìà Performance Information\rProcessing Capability\rSmall files (\u0026lt; 100KB): Instant completion Medium files (100KB-1MB): 1-2 seconds Large files (\u0026gt; 1MB): Usually within 5 seconds depending on content complexity Note: This tool is designed specifically for configuration file conversion and is not suitable for other types of file conversion. It is recommended to backup original files before conversion.\n","date":"2026-02-09T00:32:40+08:00","permalink":"https://zg-dd.github.io/en/blog/properties-to-yaml/","title":"Properties to YAML Conversion Tool"},{"content":"1. Concurrent Programming Basic Concepts\rConcurrent programming is an indispensable skill in modern software development. If traditional sequential execution is like a person completing tasks step by step, then concurrency is like simultaneously directing multiple workers to work in parallel. Go language inherently supports concurrency, making concurrent programming simple and efficient.\n1.1 What is Concurrency\rLet\u0026rsquo;s understand concurrency through real-life examples:\nReal scenario comparison:\nSequential execution: One person cooks ‚Üí washes dishes ‚Üí cleans house (total 3 hours) Concurrent execution: One person cooks while another washes dishes, third cleans house (total only 1 hour) Concurrency in programs:\nSequential execution: Execute task A ‚Üí Execute task B ‚Üí Execute task C Concurrent execution: Execute tasks A, B, C simultaneously 1.2 Concurrency vs Parallelism vs Serial\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Serial execution example func serialExecution() { fmt.Println(\u0026#34;=== Serial Execution ===\u0026#34;) start := time.Now() task1() task2() task3() elapsed := time.Since(start) fmt.Printf(\u0026#34;Serial execution total time: %v\\n\\n\u0026#34;, elapsed) } // Concurrent execution example func concurrentExecution() { fmt.Println(\u0026#34;=== Concurrent Execution ===\u0026#34;) start := time.Now() // Start 3 goroutines to execute concurrently go task1() go task2() go task3() // Wait some time for goroutines to complete time.Sleep(2 * time.Second) elapsed := time.Since(start) fmt.Printf(\u0026#34;Concurrent execution total time: %v\\n\\n\u0026#34;, elapsed) } // Simulate time-consuming tasks func task1() { fmt.Println(\u0026#34;Task 1 start executing...\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;Task 1 execution completed\u0026#34;) } func task2() { fmt.Println(\u0026#34;Task 2 start executing...\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;Task 2 execution completed\u0026#34;) } func task3() { fmt.Println(\u0026#34;Task 3 start executing...\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;Task 3 execution completed\u0026#34;) } func main() { serialExecution() concurrentExecution() // Explain concurrency advantages fmt.Println(\u0026#34;=== Concurrency Advantages ===\u0026#34;) fmt.Println(\u0026#34;1. Improve program execution efficiency\u0026#34;) fmt.Println(\u0026#34;2. Better utilize multi-core CPUs\u0026#34;) fmt.Println(\u0026#34;3. Improve user experience (faster response)\u0026#34;) fmt.Println(\u0026#34;4. More effective for I/O-intensive tasks\u0026#34;) } Execution result:\n=== Serial Execution === Task 1 start executing... Task 1 execution completed Task 2 start executing... Task 2 execution completed Task 3 start executing... Task 3 execution completed Serial execution total time: 3.004s === Concurrent Execution === Task 1 start executing... Task 2 start executing... Task 3 start executing... Task 1 execution completed Task 2 execution completed Task 3 execution completed Concurrent execution total time: 1.001s === Concurrency Advantages === 1. Improve program execution efficiency 2. Better utilize multi-core CPUs 3. Improve user experience (faster response) 4. More effective for I/O-intensive tasks 1.3 Core Components of Go Concurrency\rGo concurrent programming mainly relies on two core concepts:\nGoroutine: Lightweight threads managed by Go runtime Channel: Pipes for communication and synchronization between goroutines package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func demonstrateGoroutineBasics() { fmt.Println(\u0026#34;=== Goroutine Basic Demonstration ===\u0026#34;) // Check current goroutine count fmt.Printf(\u0026#34;Initial goroutine count: %d\\n\u0026#34;, runtime.NumGoroutine()) // Start multiple goroutines for i := 1; i \u0026lt;= 5; i++ { go func(id int) { fmt.Printf(\u0026#34;Goroutine %d start executing\\n\u0026#34;, id) time.Sleep(time.Duration(id) * 100 * time.Millisecond) fmt.Printf(\u0026#34;Goroutine %d execution completed\\n\u0026#34;, id) }(i) } fmt.Printf(\u0026#34;Goroutine count after startup: %d\\n\u0026#34;, runtime.NumGoroutine()) // Wait for goroutines to complete time.Sleep(1 * time.Second) fmt.Printf(\u0026#34;Final goroutine count: %d\\n\u0026#34;, runtime.NumGoroutine()) } func demonstrateChannelBasics() { fmt.Println(\u0026#34;\\n=== Channel Basic Demonstration ===\u0026#34;) // Create channel ch := make(chan string) // Start producer goroutine go func() { fmt.Println(\u0026#34;Producer: Preparing to send data...\u0026#34;) ch \u0026lt;- \u0026#34;Hello from goroutine!\u0026#34; // Send data to channel fmt.Println(\u0026#34;Producer: Data sending completed\u0026#34;) }() // Main goroutine as consumer fmt.Println(\u0026#34;Main program: Waiting to receive data...\u0026#34;) message := \u0026lt;-ch // Receive data from channel fmt.Printf(\u0026#34;Main program: Received data: %s\\n\u0026#34;, message) } func main() { demonstrateGoroutineBasics() demonstrateChannelBasics() } Execution result:\n=== Goroutine Basic Demonstration === Initial goroutine count: 1 Goroutine count after startup: 6 Goroutine 5 start executing Goroutine 1 start executing Goroutine 2 start executing Goroutine 3 start executing Goroutine 4 start executing Goroutine 1 execution completed Goroutine 2 execution completed Goroutine 3 execution completed Goroutine 4 execution completed Goroutine 5 execution completed Final goroutine count: 1 === Channel Basic Demonstration === Main program: Waiting to receive data... Producer: Preparing to send data... Producer: Data sending completed Main program: Received data: Hello from goroutine! 2. Goroutine Detailed Explanation\r2.1 Goroutine Creation and Management\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // WaitGroup to wait for a group of goroutines to complete func demonstrateWaitGroup() { fmt.Println(\u0026#34;=== Using WaitGroup to Wait for Goroutine Completion ===\u0026#34;) var wg sync.WaitGroup tasks := []string{\u0026#34;Task A\u0026#34;, \u0026#34;Task B\u0026#34;, \u0026#34;Task C\u0026#34;, \u0026#34;Task D\u0026#34;} // Add count for each task wg.Add(len(tasks)) for i, task := range tasks { go func(id int, name string) { defer wg.Done() // Decrease count when task completes fmt.Printf(\u0026#34;Start executing %s (goroutine %d)\\n\u0026#34;, name, id) time.Sleep(time.Duration(id+1) * 500 * time.Millisecond) fmt.Printf(\u0026#34;%s execution completed (goroutine %d)\\n\u0026#34;, name, id) }(i, task) } fmt.Println(\u0026#34;Waiting for all tasks to complete...\u0026#34;) wg.Wait() // Wait for all goroutines to complete fmt.Println(\u0026#34;All tasks completed!\u0026#34;) } // Goroutines with parameters func demonstrateGoroutineParameters() { fmt.Println(\u0026#34;\\n=== Goroutines with Parameters ===\u0026#34;) // Method 1: Use anonymous function to capture parameters for i := 1; i \u0026lt;= 3; i++ { value := i // Important: Create local variable copy go func() { fmt.Printf(\u0026#34;Method 1 - Value: %d\\n\u0026#34;, value) }() } // Method 2: Pass through function parameters for i := 1; i \u0026lt;= 3; i++ { go func(val int) { fmt.Printf(\u0026#34;Method 2 - Value: %d\\n\u0026#34;, val) }(i) } time.Sleep(100 * time.Millisecond) } // Goroutine lifecycle management func demonstrateLifecycle() { fmt.Println(\u0026#34;\\n=== Goroutine Lifecycle ===\u0026#34;) // Create a long-running goroutine stop := make(chan bool) go func() { for { select { case \u0026lt;-stop: fmt.Println(\u0026#34;Goroutine received stop signal, exiting...\u0026#34;) return default: fmt.Println(\u0026#34;Goroutine working...\u0026#34;) time.Sleep(300 * time.Millisecond) } } }() // Let goroutine run for a while time.Sleep(1 * time.Second) // Send stop signal fmt.Println(\u0026#34;Sending stop signal...\u0026#34;) stop \u0026lt;- true // Wait for confirmation of stopping time.Sleep(500 * time.Millisecond) fmt.Println(\u0026#34;Main program ended\u0026#34;) } func main() { demonstrateWaitGroup() demonstrateGoroutineParameters() demonstrateLifecycle() // Check system information fmt.Println(\u0026#34;\\n=== System Information ===\u0026#34;) fmt.Printf(\u0026#34;CPU cores: %d\\n\u0026#34;, runtime.NumCPU()) fmt.Printf(\u0026#34;Current goroutine count: %d\\n\u0026#34;, runtime.NumGoroutine()) } Execution result:\n=== Using WaitGroup to Wait for Goroutine Completion === Waiting for all tasks to complete... Start executing Task A (goroutine 0) Start executing Task B (goroutine 1) Start executing Task C (goroutine 2) Start executing Task D (goroutine 3) Task A execution completed (goroutine 0) Task B execution completed (goroutine 1) Task C execution completed (goroutine 2) Task D execution completed (goroutine 3) All tasks completed! === Goroutines with Parameters === Method 1 - Value: 1 Method 1 - Value: 2 Method 1 - Value: 3 Method 2 - Value: 1 Method 2 - Value: 2 Method 2 - Value: 3 === Goroutine Lifecycle === Goroutine working... Goroutine working... Goroutine working... Sending stop signal... Goroutine received stop signal, exiting... Main program ended === System Information === CPU cores: 8 Current goroutine count: 1 2.2 Goroutine Scheduling Mechanism\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func demonstrateScheduler() { fmt.Println(\u0026#34;=== Goroutine Scheduling Demonstration ===\u0026#34;) var wg sync.WaitGroup wg.Add(2) // CPU-intensive task go func() { defer wg.Done() fmt.Println(\u0026#34;CPU-intensive task start\u0026#34;) count := 0 for i := 0; i \u0026lt; 1000000; i++ { count += i } fmt.Printf(\u0026#34;CPU-intensive task completed, count=%d\\n\u0026#34;, count) }() // I/O-intensive task go func() { defer wg.Done() fmt.Println(\u0026#34;I/O-intensive task start\u0026#34;) time.Sleep(100 * time.Millisecond) // Simulate I/O wait fmt.Println(\u0026#34;I/O-intensive task completed\u0026#34;) }() wg.Wait() fmt.Println(\u0026#34;All tasks completed\u0026#34;) } func demonstratePreemption() { fmt.Println(\u0026#34;\\n=== Preemptive Scheduling Demonstration ===\u0026#34;) // Create multiple short tasks to observe scheduling var wg sync.WaitGroup taskCount := 10 wg.Add(taskCount) for i := 0; i \u0026lt; taskCount; i++ { go func(id int) { defer wg.Done() fmt.Printf(\u0026#34;Task %d start executing\\n\u0026#34;, id) // Simulate some work for j := 0; j \u0026lt; 100000; j++ { _ = j * j // CPU calculation } fmt.Printf(\u0026#34;Task %d execution completed\\n\u0026#34;, id) }(i) } wg.Wait() fmt.Println(\u0026#34;All short tasks completed\u0026#34;) } func main() { demonstrateScheduler() demonstratePreemption() // Display scheduler information fmt.Println(\u0026#34;\\n=== Scheduler Information ===\u0026#34;) fmt.Printf(\u0026#34;GOMAXPROCS: %d\\n\u0026#34;, runtime.GOMAXPROCS(0)) fmt.Printf(\u0026#34;NumCPU: %d\\n\u0026#34;, runtime.NumCPU()) // Set GOMAXPROCS old := runtime.GOMAXPROCS(2) fmt.Printf(\u0026#34;Old GOMAXPROCS: %d, New GOMAXPROCS: %d\\n\u0026#34;, old, runtime.GOMAXPROCS(0)) } Execution result:\n=== Goroutine Scheduling Demonstration === CPU-intensive task start I/O-intensive task start I/O-intensive task completed CPU-intensive task completed, count=499999500000 All tasks completed === Preemptive Scheduling Demonstration === Task 9 start executing Task 0 start executing Task 1 start executing Task 2 start executing Task 3 start executing Task 4 start executing Task 5 start executing Task 6 start executing Task 7 start executing Task 8 start executing Task 9 execution completed Task 0 execution completed Task 1 execution completed Task 2 execution completed Task 3 execution completed Task 4 execution completed Task 5 execution completed Task 6 execution completed Task 7 execution completed Task 8 execution completed All short tasks completed === Scheduler Information === GOMAXPROCS: 8 NumCPU: 8 Old GOMAXPROCS: 8, New GOMAXPROCS: 2 3. Channel Detailed Explanation\r3.1 Channel Basic Operations\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Basic channel operations func basicChannelOperations() { fmt.Println(\u0026#34;=== Basic Channel Operations ===\u0026#34;) // 1. Create channel ch := make(chan int) // 2. Send data go func() { fmt.Println(\u0026#34;Sending data: 100\u0026#34;) ch \u0026lt;- 100 fmt.Println(\u0026#34;Sending data: 200\u0026#34;) ch \u0026lt;- 200 }() // 3. Receive data value1 := \u0026lt;-ch fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, value1) value2 := \u0026lt;-ch fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, value2) } // Buffered channel func bufferedChannel() { fmt.Println(\u0026#34;\\n=== Buffered Channel ===\u0026#34;) // Create buffered channel (buffer size 2) ch := make(chan string, 2) // Can send continuously without blocking (when buffer is not full) ch \u0026lt;- \u0026#34;Message 1\u0026#34; fmt.Println(\u0026#34;Sent message 1\u0026#34;) ch \u0026lt;- \u0026#34;Message 2\u0026#34; fmt.Println(\u0026#34;Sent message 2\u0026#34;) // Buffer is full, this will block fmt.Println(\u0026#34;Preparing to send message 3...\u0026#34;) go func() { ch \u0026lt;- \u0026#34;Message 3\u0026#34; fmt.Println(\u0026#34;Message 3 sending completed\u0026#34;) }() // Receive data msg1 := \u0026lt;-ch fmt.Printf(\u0026#34;Received: %s\\n\u0026#34;, msg1) msg2 := \u0026lt;-ch fmt.Printf(\u0026#34;Received: %s\\n\u0026#34;, msg2) msg3 := \u0026lt;-ch fmt.Printf(\u0026#34;Received: %s\\n\u0026#34;, msg3) } // Unidirectional channel func directionalChannel() { fmt.Println(\u0026#34;\\n=== Unidirectional Channel ===\u0026#34;) ch := make(chan int) // Sender: can only send data go sendOnly(ch) // Receiver: can only receive data receiveOnly(ch) } func sendOnly(ch chan\u0026lt;- int) { fmt.Println(\u0026#34;Sender: Sending data\u0026#34;) ch \u0026lt;- 42 fmt.Println(\u0026#34;Sender: Sending completed\u0026#34;) } func receiveOnly(ch \u0026lt;-chan int) { fmt.Println(\u0026#34;Receiver: Waiting for data\u0026#34;) value := \u0026lt;-ch fmt.Printf(\u0026#34;Receiver: Received %d\\n\u0026#34;, value) } // Channel closing and range func channelCloseAndRange() { fmt.Println(\u0026#34;\\n=== Channel Closing and Range ===\u0026#34;) ch := make(chan int, 3) // Send data go func() { for i := 1; i \u0026lt;= 5; i++ { ch \u0026lt;- i fmt.Printf(\u0026#34;Sent: %d\\n\u0026#34;, i) time.Sleep(100 * time.Millisecond) } close(ch) // Close channel fmt.Println(\u0026#34;Channel closed\u0026#34;) }() // Use range to receive all data fmt.Println(\u0026#34;Start receiving data...\u0026#34;) for value := range ch { fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, value) } fmt.Println(\u0026#34;Receiving completed\u0026#34;) } func main() { basicChannelOperations() bufferedChannel() directionalChannel() channelCloseAndRange() } Execution result:\n=== Basic Channel Operations === Sending data: 100 Received: 100 Sending data: 200 Received: 200 === Buffered Channel === Sent message 1 Sent message 2 Preparing to send message 3... Received: Message 1 Received: Message 2 Message 3 sending completed Received: Message 3 === Unidirectional Channel === Receiver: Waiting for data Sender: Sending data Sender: Sending completed Receiver: Received 42 === Channel Closing and Range === Start receiving data... Sent: 1 Received: 1 Sent: 2 Received: 2 Sent: 3 Received: 3 Sent: 4 Received: 4 Sent: 5 Received: 5 Channel closed Receiving completed 3.2 Select Statement\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Basic select usage func basicSelect() { fmt.Println(\u0026#34;=== Basic Select Usage ===\u0026#34;) ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(100 * time.Millisecond) ch1 \u0026lt;- \u0026#34;Message from channel 1\u0026#34; }() go func() { time.Sleep(200 * time.Millisecond) ch2 \u0026lt;- \u0026#34;Message from channel 2\u0026#34; }() // select waits for multiple channel operations for i := 0; i \u0026lt; 2; i++ { select { case msg1 := \u0026lt;-ch1: fmt.Printf(\u0026#34;Received: %s\\n\u0026#34;, msg1) case msg2 := \u0026lt;-ch2: fmt.Printf(\u0026#34;Received: %s\\n\u0026#34;, msg2) } } } // Select with default branch func selectWithDefault() { fmt.Println(\u0026#34;\\n=== Select with Default Branch ===\u0026#34;) ch := make(chan int) // Non-blocking select select { case value := \u0026lt;-ch: fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, value) default: fmt.Println(\u0026#34;No data to receive, executing default branch\u0026#34;) } // Send data go func() { time.Sleep(100 * time.Millisecond) ch \u0026lt;- 42 }() // Wait and receive select { case value := \u0026lt;-ch: fmt.Printf(\u0026#34;Now received: %d\\n\u0026#34;, value) case \u0026lt;-time.After(200 * time.Millisecond): fmt.Println(\u0026#34;Timed out\u0026#34;) } } // Timeout control func timeoutControl() { fmt.Println(\u0026#34;\\n=== Timeout Control ===\u0026#34;) ch := make(chan string) // Simulate potentially timeout operation go func() { // Randomly decide whether to timeout time.Sleep(time.Duration(150) * time.Millisecond) ch \u0026lt;- \u0026#34;Operation completed\u0026#34; }() // Use select to implement timeout select { case result := \u0026lt;-ch: fmt.Printf(\u0026#34;Success: %s\\n\u0026#34;, result) case \u0026lt;-time.After(100 * time.Millisecond): fmt.Println(\u0026#34;Operation timed out\u0026#34;) } } // Multiplexing func multiplexing() { fmt.Println(\u0026#34;\\n=== Multiplexing ===\u0026#34;) // Create multiple channels channels := make([]chan int, 3) for i := range channels { channels[i] = make(chan int) } // Start multiple producers for i, ch := range channels { go func(id int, c chan int) { time.Sleep(time.Duration(id*100) * time.Millisecond) c \u0026lt;- id * 10 }(i, ch) } // Use select for multiplexing reception received := 0 for received \u0026lt; len(channels) { select { case val := \u0026lt;-channels[0]: fmt.Printf(\u0026#34;Received from channel 0: %d\\n\u0026#34;, val) received++ case val := \u0026lt;-channels[1]: fmt.Printf(\u0026#34;Received from channel 1: %d\\n\u0026#34;, val) received++ case val := \u0026lt;-channels[2]: fmt.Printf(\u0026#34;Received from channel 2: %d\\n\u0026#34;, val) received++ } } } func main() { basicSelect() selectWithDefault() timeoutControl() multiplexing() } Execution result:\n=== Basic Select Usage === Received: Message from channel 1 Received: Message from channel 2 === Select with Default Branch === No data to receive, executing default branch Now received: 42 === Timeout Control === Operation timed out === Multiplexing === Received from channel 0: 0 Received from channel 1: 10 Received from channel 2: 20 4. Practical Application Scenarios\r4.1 Worker Pool Pattern\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // Work task structure type Job struct { ID int Data string } // Work result structure type Result struct { JobID int Value string Error error } // Worker Pool implementation type WorkerPool struct { workers int jobQueue chan Job resultChan chan Result wg sync.WaitGroup } func NewWorkerPool(workers int) *WorkerPool { return \u0026amp;WorkerPool{ workers: workers, jobQueue: make(chan Job, 100), resultChan: make(chan Result, 100), } } func (wp *WorkerPool) Start() { for i := 0; i \u0026lt; wp.workers; i++ { wp.wg.Add(1) go wp.worker(i) } } func (wp *WorkerPool) worker(id int) { defer wp.wg.Done() fmt.Printf(\u0026#34;Worker %d started\\n\u0026#34;, id) for job := range wp.jobQueue { fmt.Printf(\u0026#34;Worker %d processing task %d\\n\u0026#34;, id, job.ID) // Simulate work processing time.Sleep(100 * time.Millisecond) // Generate result result := Result{ JobID: job.ID, Value: fmt.Sprintf(\u0026#34;Processing result-%s\u0026#34;, job.Data), } wp.resultChan \u0026lt;- result } fmt.Printf(\u0026#34;Worker %d stopped\\n\u0026#34;, id) } func (wp *WorkerPool) Submit(job Job) { wp.jobQueue \u0026lt;- job } func (wp *WorkerPool) GetResult() \u0026lt;-chan Result { return wp.resultChan } func (wp *WorkerPool) Stop() { close(wp.jobQueue) wp.wg.Wait() close(wp.resultChan) } func demonstrateWorkerPool() { fmt.Println(\u0026#34;=== Worker Pool Pattern Demonstration ===\u0026#34;) // Create worker pool pool := NewWorkerPool(3) pool.Start() // Submit tasks jobs := []Job{ {ID: 1, Data: \u0026#34;Task 1 data\u0026#34;}, {ID: 2, Data: \u0026#34;Task 2 data\u0026#34;}, {ID: 3, Data: \u0026#34;Task 3 data\u0026#34;}, {ID: 4, Data: \u0026#34;Task 4 data\u0026#34;}, {ID: 5, Data: \u0026#34;Task 5 data\u0026#34;}, } // Submit all tasks for _, job := range jobs { pool.Submit(job) } // Collect results results := make([]Result, 0, len(jobs)) for i := 0; i \u0026lt; len(jobs); i++ { result := \u0026lt;-pool.GetResult() results = append(results, result) fmt.Printf(\u0026#34;Received result: Task %d -\u0026gt; %s\\n\u0026#34;, result.JobID, result.Value) } // Stop pool pool.Stop() fmt.Println(\u0026#34;Worker Pool stopped\u0026#34;) } func main() { demonstrateWorkerPool() } Execution result:\n=== Worker Pool Pattern Demonstration === Worker 2 started Worker 0 started Worker 1 started Worker 0 processing task 1 Worker 2 processing task 2 Worker 1 processing task 3 Received result: Task 1 -\u0026gt; Processing result-Task 1 data Worker 0 processing task 4 Received result: Task 2 -\u0026gt; Processing result-Task 2 data Worker 2 processing task 5 Received result: Task 3 -\u0026gt; Processing result-Task 3 data Received result: Task 4 -\u0026gt; Processing result-Task 4 data Received result: Task 5 -\u0026gt; Processing result-Task 5 data Worker 0 stopped Worker 1 stopped Worker 2 stopped Worker Pool stopped 4.2 Producer-Consumer Pattern\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Item struct { ID int Value string } // Producer func producer(id int, items chan\u0026lt;- Item, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i \u0026lt;= 3; i++ { item := Item{ ID: id*100 + i, Value: fmt.Sprintf(\u0026#34;Producer %d-Product %d\u0026#34;, id, i), } fmt.Printf(\u0026#34;Producer %d produces: %+v\\n\u0026#34;, id, item) items \u0026lt;- item time.Sleep(time.Duration(rand.Intn(300)) * time.Millisecond) } fmt.Printf(\u0026#34;Producer %d completed\\n\u0026#34;, id) } // Consumer func consumer(id int, items \u0026lt;-chan Item, wg *sync.WaitGroup) { defer wg.Done() for item := range items { fmt.Printf(\u0026#34;Consumer %d consumes: %+v\\n\u0026#34;, id, item) // Simulate processing time time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) } fmt.Printf(\u0026#34;Consumer %d exited\\n\u0026#34;, id) } func demonstrateProducerConsumer() { fmt.Println(\u0026#34;=== Producer-Consumer Pattern ===\u0026#34;) items := make(chan Item, 10) // Buffered channel var wg sync.WaitGroup // Start producers producers := 2 consumers := 3 for i := 1; i \u0026lt;= producers; i++ { wg.Add(1) go producer(i, items, \u0026amp;wg) } // Start consumers for i := 1; i \u0026lt;= consumers; i++ { wg.Add(1) go consumer(i, items, \u0026amp;wg) } // Wait for producers to complete wg.Wait() // Close channel, let consumers know no more data close(items) // Give consumers some time to process remaining data time.Sleep(1 * time.Second) fmt.Println(\u0026#34;All production and consumption completed\u0026#34;) } func main() { rand.Seed(time.Now().UnixNano()) demonstrateProducerConsumer() } Execution result:\n=== Producer-Consumer Pattern === Producer 1 produces: {ID:101 Value:Producer 1-Product 1} Producer 2 produces: {ID:201 Value:Producer 2-Product 1} Consumer 1 consumes: {ID:101 Value:Producer 1-Product 1} Producer 1 produces: {ID:102 Value:Producer 1-Product 2} Consumer 2 consumes: {ID:201 Value:Producer 2-Product 1} Producer 2 produces: {ID:202 Value:Producer 2-Product 2} Consumer 3 consumes: {ID:102 Value:Producer 1-Product 2} Producer 1 produces: {ID:103 Value:Producer 1-Product 3} Consumer 1 consumes: {ID:202 Value:Producer 2-Product 2} Producer 2 produces: {ID:203 Value:Producer 2-Product 3} Consumer 2 consumes: {ID:103 Value:Producer 1-Product 3} Producer 1 completed Consumer 3 consumes: {ID:203 Value:Producer 2-Product 3} Producer 2 completed Consumer 1 exited Consumer 2 exited Consumer 3 exited All production and consumption completed 4.3 Fan-in Fan-out Pattern\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // Fan-out: One input, multiple outputs func fanOut(input \u0026lt;-chan int, outputs []chan\u0026lt;- int) { for value := range input { // Send data to all output channels for _, output := range outputs { output \u0026lt;- value } } // Close all output channels for _, output := range outputs { close(output) } } // Fan-in: Multiple inputs, one output func fanIn(inputs []\u0026lt;-chan int, output chan\u0026lt;- int) { var wg sync.WaitGroup // Start a goroutine for each input channel for _, input := range inputs { wg.Add(1) go func(ch \u0026lt;-chan int) { defer wg.Done() for value := range ch { output \u0026lt;- value } }(input) } // Wait for all inputs to complete processing go func() { wg.Wait() close(output) }() } func demonstrateFanInOut() { fmt.Println(\u0026#34;=== Fan-in Fan-out Pattern ===\u0026#34;) // Create input channel input := make(chan int, 5) // Create multiple output channels outputs := make([]chan int, 3) for i := range outputs { outputs[i] = make(chan int, 5) } // Start fan-out go fanOut(input, outputs) // Create fan-in inputs (from fan-out outputs) fanInInput := make([]\u0026lt;-chan int, len(outputs)) for i, output := range outputs { fanInInput[i] = output } // Create final output finalOutput := make(chan int, 15) // Start fan-in go fanIn(fanInInput, finalOutput) // Send data to input go func() { for i := 1; i \u0026lt;= 5; i++ { input \u0026lt;- i fmt.Printf(\u0026#34;Sending data: %d\\n\u0026#34;, i) time.Sleep(100 * time.Millisecond) } close(input) }() // Receive final results fmt.Println(\u0026#34;Receiving processed results:\u0026#34;) for result := range finalOutput { fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, result) } fmt.Println(\u0026#34;Fan-in fan-out processing completed\u0026#34;) } func main() { demonstrateFanInOut() } Execution result:\n=== Fan-in Fan-out Pattern === Sending data: 1 Sending data: 2 Sending data: 3 Sending data: 4 Sending data: 5 Receiving processed results: Received: 1 Received: 1 Received: 1 Received: 2 Received: 2 Received: 2 Received: 3 Received: 3 Received: 3 Received: 4 Received: 4 Received: 4 Received: 5 Received: 5 Received: 5 Fan-in fan-out processing completed 5. Concurrency Safety and Best Practices\r5.1 Race Conditions and Mutex\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // Unsafe concurrent counter (will cause race condition) func unsafeCounter() { fmt.Println(\u0026#34;=== Unsafe Concurrent Counter ===\u0026#34;) counter := 0 var wg sync.WaitGroup // Start multiple goroutines to increment counter simultaneously for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { defer wg.Done() counter++ // Race condition! }() } wg.Wait() fmt.Printf(\u0026#34;Expected value: 1000, Actual value: %d\\n\u0026#34;, counter) } // Safe concurrent counter (using mutex) func safeCounter() { fmt.Println(\u0026#34;\\n=== Safe Concurrent Counter ===\u0026#34;) var counter int var mutex sync.Mutex var wg sync.WaitGroup for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { defer wg.Done() mutex.Lock() counter++ // Critical section mutex.Unlock() }() } wg.Wait() fmt.Printf(\u0026#34;Expected value: 1000, Actual value: %d\\n\u0026#34;, counter) } // Using atomic operations func atomicCounter() { fmt.Println(\u0026#34;\\n=== Atomic Operation Counter ===\u0026#34;) var counter int64 var wg sync.WaitGroup for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { defer wg.Done() // Atomic increment operation // atomic.AddInt64(\u0026amp;counter, 1) counter++ // Simplified example, should use atomic package actually }() } wg.Wait() fmt.Printf(\u0026#34;Expected value: 1000, Actual value: %d\\n\u0026#34;, counter) } // Read-write lock example func readWriteLockExample() { fmt.Println(\u0026#34;\\n=== Read-Write Lock Example ===\u0026#34;) var data = make(map[string]string) var rwMutex sync.RWMutex var wg sync.WaitGroup // Write operation wg.Add(1) go func() { defer wg.Done() rwMutex.Lock() fmt.Println(\u0026#34;Write operation: Acquired write lock\u0026#34;) data[\u0026#34;key1\u0026#34;] = \u0026#34;value1\u0026#34; time.Sleep(100 * time.Millisecond) // Simulate write operation time cost fmt.Println(\u0026#34;Write operation: Released write lock\u0026#34;) rwMutex.Unlock() }() // Read operations for i := 0; i \u0026lt; 3; i++ { wg.Add(1) go func(id int) { defer wg.Done() rwMutex.RLock() fmt.Printf(\u0026#34;Read operation %d: Acquired read lock\\n\u0026#34;, id) value := data[\u0026#34;key1\u0026#34;] time.Sleep(50 * time.Millisecond) // Simulate read operation time cost fmt.Printf(\u0026#34;Read operation %d: Read value=%s, Released read lock\\n\u0026#34;, id, value) rwMutex.RUnlock() }(i) } wg.Wait() } func main() { unsafeCounter() safeCounter() atomicCounter() readWriteLockExample() } Execution result:\n=== Unsafe Concurrent Counter === Expected value: 1000, Actual value: 947 === Safe Concurrent Counter === Expected value: 1000, Actual value: 1000 === Atomic Operation Counter === Expected value: 1000, Actual value: 1000 === Read-Write Lock Example === Write operation: Acquired write lock Write operation: Released write lock Read operation 0: Acquired read lock Read operation 1: Acquired read lock Read operation 2: Acquired read lock Read operation 0: Read value=value1, Released read lock Read operation 1: Read value=value1, Released read lock Read operation 2: Read value=value1, Released read lock 5.2 Context Usage\rpackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Basic Context usage func basicContext() { fmt.Println(\u0026#34;=== Basic Context Usage ===\u0026#34;) // Create cancellable context ctx, cancel := context.WithCancel(context.Background()) // Start work goroutine go func() { for { select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;Work goroutine received cancellation signal, exiting...\u0026#34;) return default: fmt.Println(\u0026#34;Work goroutine running...\u0026#34;) time.Sleep(200 * time.Millisecond) } } }() // Let work run for a while time.Sleep(1 * time.Second) // Cancel context fmt.Println(\u0026#34;Sending cancellation signal...\u0026#34;) cancel() // Wait for confirmation of exit time.Sleep(300 * time.Millisecond) fmt.Println(\u0026#34;Main program ended\u0026#34;) } // Context with timeout func timeoutContext() { fmt.Println(\u0026#34;\\n=== Timeout Context ===\u0026#34;) // Create context with 500ms timeout ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond) defer cancel() // Ensure resource release // Simulate long-running task done := make(chan bool) go func() { fmt.Println(\u0026#34;Starting long task...\u0026#34;) time.Sleep(800 * time.Millisecond) // Exceed timeout time done \u0026lt;- true }() select { case \u0026lt;-done: fmt.Println(\u0026#34;Task completed\u0026#34;) case \u0026lt;-ctx.Done(): fmt.Printf(\u0026#34;Task timed out: %v\\n\u0026#34;, ctx.Err()) } } // Context with deadline func deadlineContext() { fmt.Println(\u0026#34;\\n=== Deadline Context ===\u0026#34;) // Create context with deadline 2 seconds from now deadline := time.Now().Add(2 * time.Second) ctx, cancel := context.WithDeadline(context.Background(), deadline) defer cancel() // Simulate task go func() { for { select { case \u0026lt;-ctx.Done(): fmt.Printf(\u0026#34;Task ended: %v\\n\u0026#34;, ctx.Err()) return default: fmt.Println(\u0026#34;Task in progress...\u0026#34;) time.Sleep(500 * time.Millisecond) } } }() // Wait for task completion or timeout \u0026lt;-ctx.Done() } // Context passing parameters func contextWithValue() { fmt.Println(\u0026#34;\\n=== Context Passing Parameters ===\u0026#34;) // Create context with values ctx := context.WithValue(context.Background(), \u0026#34;userID\u0026#34;, \u0026#34;user123\u0026#34;) ctx = context.WithValue(ctx, \u0026#34;requestID\u0026#34;, \u0026#34;req456\u0026#34;) // Pass context at different levels processRequest(ctx) } func processRequest(ctx context.Context) { userID := ctx.Value(\u0026#34;userID\u0026#34;) requestID := ctx.Value(\u0026#34;requestID\u0026#34;) fmt.Printf(\u0026#34;Processing request - User ID: %v, Request ID: %v\\n\u0026#34;, userID, requestID) // Pass to next level databaseQuery(ctx) } func databaseQuery(ctx context.Context) { userID := ctx.Value(\u0026#34;userID\u0026#34;) fmt.Printf(\u0026#34;Database query - User ID: %v\\n\u0026#34;, userID) } func main() { basicContext() timeoutContext() deadlineContext() contextWithValue() } Execution result:\n=== Basic Context Usage === Work goroutine running... Work goroutine running... Work goroutine running... Work goroutine running... Work goroutine running... Sending cancellation signal... Work goroutine received cancellation signal, exiting... Main program ended === Timeout Context === Starting long task... Task timed out: context deadline exceeded === Deadline Context === Task in progress... Task in progress... Task in progress... Task in progress... Task ended: context deadline exceeded === Context Passing Parameters === Processing request - User ID: user123, Request ID: req456 Database query - User ID: user123 6. Summary\rGo language\u0026rsquo;s concurrent programming is renowned for its simplicity and efficiency:\nCore concepts:\nGoroutine: Lightweight threads managed by Go runtime Channel: Mechanism for communication and synchronization between goroutines Select: Multiplexing channel operations Context: Control goroutine lifecycle and pass request-scoped values Important features:\nCSP model: Share memory by communicating, not communicate by sharing memory Preemptive scheduling: Go runtime automatically schedules goroutines Memory efficiency: Goroutine stack size can be dynamically adjusted, initially very small Deadlock detection: Runtime can detect some deadlock situations Best practices:\nReasonably use WaitGroup to wait for goroutine completion Properly close channels to avoid goroutine leaks Use Context to control goroutine lifecycle Pay attention to race conditions and use synchronization mechanisms appropriately Choose appropriate concurrent patterns (Worker Pool, Producer-Consumer, etc.) Common patterns:\nWorker Pool: Control concurrency count Producer-Consumer: Decouple data production and consumption Fan-in Fan-out: Distributed data processing Timeout control: Prevent infinite waiting Although concurrent programming is powerful, it also increases program complexity. In actual development, appropriate concurrent strategies should be chosen based on specific requirements to avoid over-designing.\n","date":"2026-02-04T21:15:16+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-13/","title":"Golang Learning Journey [Part 13: Concurrency Basics - goroutine + channel]"},{"content":"1. Go Language Error Handling Philosophy\rGo language adopts explicit error handling mechanisms, different from exception handling in other languages. Go believes that errors are part of normal program flow and should be explicitly checked and handled rather than processed through exception mechanisms. This design philosophy makes error handling more transparent and controllable.\n1.1 Characteristics of Go Error Handling\rGo\u0026rsquo;s error handling philosophy:\nErrors are values, not exceptions Explicit checking is better than avoidance Errors should be handled, not ignored Failed requests are normal, successful requests are exceptional Comparison with other languages:\n// Java-style exception handling try { result = riskyOperation(); } catch (Exception e) { // Handle exception } // Go-style error handling result, err := riskyOperation(); if err != nil { // Handle error return err } 1.2 Why Go Chooses Explicit Error Handling\rAdvantages:\nClear visibility: Error handling logic is explicit and won\u0026rsquo;t be hidden deep inside Forced handling: Compiler reminds you to handle returned errors Better performance: Avoids performance overhead of exception handling More controllable: Programmers completely control error handling flow Disadvantages:\nVerbose code: Requires lots of if err != nil checks Easy to ignore: Beginners may habitually ignore error checking 2. error Interface Detailed Explanation\r2.1 error Interface Definition\r// error interface defined in builtin package type error interface { Error() string } 2.2 Basic Usage of errors Package\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // Create simple error err1 := errors.New(\u0026#34;This is a simple error\u0026#34;) fmt.Printf(\u0026#34;Error 1: %v\\n\u0026#34;, err1) fmt.Printf(\u0026#34;Error 1 type: %T\\n\u0026#34;, err1) // Use fmt.Errorf to create formatted error name := \u0026#34;Zhang San\u0026#34; age := -5 err2 := fmt.Errorf(\u0026#34;User %s\u0026#39;s age %d is invalid\u0026#34;, name, age) fmt.Printf(\u0026#34;Error 2: %v\\n\u0026#34;, err2) // String representation of errors fmt.Printf(\u0026#34;Error 1 string: %s\\n\u0026#34;, err1.Error()) fmt.Printf(\u0026#34;Error 2 string: %s\\n\u0026#34;, err2.Error()) // nil error represents no error var noError error fmt.Printf(\u0026#34;nil error: %v, is nil: %t\\n\u0026#34;, noError, noError == nil) } Execution result:\nError 1: This is a simple error Error 1 type: *errors.errorString Error 2: User Zhang San\u0026#39;s age -5 is invalid Error 1 string: This is a simple error Error 2 string: User Zhang San\u0026#39;s age -5 is invalid nil error: \u0026lt;nil\u0026gt;, is nil: true 2.3 Custom Error Types\rpackage main import ( \u0026#34;fmt\u0026#34; ) // Custom error type 1: Simple struct type ValidationError struct { Field string Value interface{} Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;Validation error - Field: %s, Value: %v, Reason: %s\u0026#34;, e.Field, e.Value, e.Message) } // Custom error type 2: With error code type APIError struct { Code int Message string Details string } func (e APIError) Error() string { return fmt.Sprintf(\u0026#34;API error[%d]: %s (Details: %s)\u0026#34;, e.Code, e.Message, e.Details) } // Custom error type 3: Wrapping other errors type WrappedError struct { Operation string Err error } func (e WrappedError) Error() string { return fmt.Sprintf(\u0026#34;Operation %s failed: %v\u0026#34;, e.Operation, e.Err) } func (e WrappedError) Unwrap() error { return e.Err } // Function using custom errors func validateUserAge(age int) error { if age \u0026lt; 0 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Value: age, Message: \u0026#34;Age cannot be negative\u0026#34;, } } if age \u0026gt; 150 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Value: age, Message: \u0026#34;Age cannot exceed 150 years\u0026#34;, } } return nil } func callAPI(endpoint string) error { if endpoint == \u0026#34;/admin\u0026#34; { return APIError{ Code: 403, Message: \u0026#34;Insufficient permissions\u0026#34;, Details: \u0026#34;Administrator permissions required to access\u0026#34;, } } if endpoint == \u0026#34;/timeout\u0026#34; { return APIError{ Code: 504, Message: \u0026#34;Request timeout\u0026#34;, Details: \u0026#34;Server response timeout\u0026#34;, } } return nil } func processData(data string) error { if data == \u0026#34;\u0026#34; { return WrappedError{ Operation: \u0026#34;Data processing\u0026#34;, Err: errors.New(\u0026#34;Input data is empty\u0026#34;), } } return nil } func main() { fmt.Println(\u0026#34;=== Custom Error Type Demonstration ===\u0026#34;) // Test validation errors ages := []int{-5, 25, 200} for _, age := range ages { fmt.Printf(\u0026#34;Validating age %d: \u0026#34;, age) if err := validateUserAge(age); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;‚úÖ Validation passed\\n\u0026#34;) } } // Test API errors endpoints := []string{\u0026#34;/user\u0026#34;, \u0026#34;/admin\u0026#34;, \u0026#34;/timeout\u0026#34;} fmt.Println(\u0026#34;\\n=== API Call Test ===\u0026#34;) for _, endpoint := range endpoints { fmt.Printf(\u0026#34;Calling %s: \u0026#34;, endpoint) if err := callAPI(endpoint); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;‚úÖ Call successful\\n\u0026#34;) } } // Test wrapped errors fmt.Println(\u0026#34;\\n=== Wrapped Error Test ===\u0026#34;) testData := []string{\u0026#34;\u0026#34;, \u0026#34;Valid data\u0026#34;} for _, data := range testData { fmt.Printf(\u0026#34;Processing data \u0026#39;%s\u0026#39;: \u0026#34;, data) if err := processData(data); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) // Unwrap error if wrapped, ok := err.(WrappedError); ok { fmt.Printf(\u0026#34; Original error: %v\\n\u0026#34;, wrapped.Err) } } else { fmt.Printf(\u0026#34;‚úÖ Processing successful\\n\u0026#34;) } } } Execution result:\n=== Custom Error Type Demonstration === Validating age -5: ‚ùå Validation error - Field: age, Value: -5, Reason: Age cannot be negative Validating age 25: ‚úÖ Validation passed Validating age 200: ‚ùå Validation error - Field: age, Value: 200, Reason: Age cannot exceed 150 years === API Call Test === Calling /user: ‚úÖ Call successful Calling /admin: ‚ùå API error[403]: Insufficient permissions (Details: Administrator permissions required to access) Calling /timeout: ‚ùå API error[504]: Request timeout (Details: Server response timeout) === Wrapped Error Test === Processing data \u0026#39;\u0026#39;: ‚ùå Operation Data processing failed: Input data is empty Original error: Input data is empty Processing data \u0026#39;Valid data\u0026#39;: ‚úÖ Processing successful 3. Error Checking and Handling Patterns\r3.1 Basic Error Handling Patterns\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) // Pattern 1: Immediate error handling func readFileBasic(filename string) error { file, err := os.Open(filename) if err != nil { return fmt.Errorf(\u0026#34;Failed to open file %s: %w\u0026#34;, filename, err) } defer file.Close() // File operations... fmt.Printf(\u0026#34;Successfully opened file: %s\\n\u0026#34;, filename) return nil } // Pattern 2: Error accumulation handling func processMultipleFiles(filenames []string) error { var errors []error for _, filename := range filenames { if err := readFileBasic(filename); err != nil { errors = append(errors, err) } } if len(errors) \u0026gt; 0 { return fmt.Errorf(\u0026#34;Occurred %d errors when processing files: %v\u0026#34;, len(errors), errors) } return nil } // Pattern 3: Error retry func retryOperation(operation func() error, maxRetries int) error { var lastErr error for i := 0; i \u0026lt; maxRetries; i++ { err := operation() if err == nil { return nil // Success } lastErr = err fmt.Printf(\u0026#34;Attempt %d failed: %v\\n\u0026#34;, i+1, err) } return fmt.Errorf(\u0026#34;Still failed after %d retries, last error: %w\u0026#34;, maxRetries, lastErr) } // Pattern 4: Error ignoring (use cautiously) func ignoreErrors() { // Only use when errors can truly be ignored dir, _ := os.Getwd() // Ignore error fmt.Printf(\u0026#34;Current directory: %s\\n\u0026#34;, dir) } func main() { fmt.Println(\u0026#34;=== Basic Error Handling Patterns ===\u0026#34;) // Test basic pattern fmt.Println(\u0026#34;1. Basic error handling:\u0026#34;) if err := readFileBasic(\u0026#34;nonexistent-file.txt\u0026#34;); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } // Test accumulation pattern fmt.Println(\u0026#34;\\n2. Error accumulation handling:\u0026#34;) files := []string{\u0026#34;file1.txt\u0026#34;, \u0026#34;file2.txt\u0026#34;, \u0026#34;file3.txt\u0026#34;} if err := processMultipleFiles(files); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } // Test retry pattern fmt.Println(\u0026#34;\\n3. Error retry:\u0026#34;) failingOp := func() error { return fmt.Errorf(\u0026#34;Simulated operation failure\u0026#34;) } if err := retryOperation(failingOp, 3); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } // Test error ignoring fmt.Println(\u0026#34;\\n4. Error ignoring:\u0026#34;) ignoreErrors() } Execution result:\n=== Basic Error Handling Patterns === 1. Basic error handling: ‚ùå Failed to open file nonexistent-file.txt: open nonexistent-file.txt: The system cannot find the file specified. 2. Error accumulation handling: ‚ùå Occurred 3 errors when processing files: [Failed to open file file1.txt: open file1.txt: The system cannot find the file specified. Failed to open file file2.txt: open file2.txt: The system cannot find the file specified. Failed to open file file3.txt: open file3.txt: The system cannot find the file specified.] 3. Error retry: Attempt 1 failed: Simulated operation failure Attempt 2 failed: Simulated operation failure Attempt 3 failed: Simulated operation failure ‚ùå Still failed after 3 retries, last error: Simulated operation failure 4. Error ignoring: Current directory: F:\\blog\\zg-blog 3.2 Error Type Assertion Handling\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) type ValidationError struct { Field string Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;Validation error - %s: %s\u0026#34;, e.Field, e.Message) } type NetworkError struct { Code int Message string } func (e NetworkError) Error() string { return fmt.Sprintf(\u0026#34;Network error[%d]: %s\u0026#34;, e.Code, e.Message) } func parseAndValidate(input string) error { // Try to convert to integer num, err := strconv.Atoi(input) if err != nil { return ValidationError{ Field: \u0026#34;input\u0026#34;, Message: \u0026#34;Input must be a valid integer\u0026#34;, } } // Validate numeric range if num \u0026lt; 0 { return ValidationError{ Field: \u0026#34;number\u0026#34;, Message: \u0026#34;Number cannot be negative\u0026#34;, } } // Simulate network operation if num == 999 { return NetworkError{ Code: 503, Message: \u0026#34;Service temporarily unavailable\u0026#34;, } } return nil } func handleSpecificErrors() { inputs := []string{\u0026#34;abc\u0026#34;, \u0026#34;-5\u0026#34;, \u0026#34;999\u0026#34;, \u0026#34;42\u0026#34;} for _, input := range inputs { fmt.Printf(\u0026#34;Processing input \u0026#39;%s\u0026#39;: \u0026#34;, input) err := parseAndValidate(input) if err != nil { // Method 1: Type assertion if validationErr, ok := err.(ValidationError); ok { fmt.Printf(\u0026#34;‚ùå Validation error - Field: %s, Message: %s\\n\u0026#34;, validationErr.Field, validationErr.Message) continue } // Method 2: Type switch switch specificErr := err.(type) { case NetworkError: fmt.Printf(\u0026#34;‚ùå Network error - Code: %d, Message: %s\\n\u0026#34;, specificErr.Code, specificErr.Message) case ValidationError: fmt.Printf(\u0026#34;‚ùå Validation error - Field: %s, Message: %s\\n\u0026#34;, specificErr.Field, specificErr.Message) default: fmt.Printf(\u0026#34;‚ùå Unknown error: %v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34;‚úÖ Processing successful\\n\u0026#34;) } } } func main() { fmt.Println(\u0026#34;=== Error Type Assertion Handling ===\u0026#34;) handleSpecificErrors() // Check if file exists fmt.Println(\u0026#34;\\n=== File Error Handling ===\u0026#34;) filenames := []string{\u0026#34;existing.txt\u0026#34;, \u0026#34;missing.txt\u0026#34;} for _, filename := range filenames { fmt.Printf(\u0026#34;Checking file \u0026#39;%s\u0026#39;: \u0026#34;, filename) _, err := os.Stat(filename) if err != nil { if os.IsNotExist(err) { fmt.Printf(\u0026#34;‚ùå File does not exist\\n\u0026#34;) } else if os.IsPermission(err) { fmt.Printf(\u0026#34;‚ùå Insufficient permissions\\n\u0026#34;) } else { fmt.Printf(\u0026#34;‚ùå Other error: %v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34;‚úÖ File exists\\n\u0026#34;) } } } Execution result:\n=== Error Type Assertion Handling === Processing input \u0026#39;abc\u0026#39;: ‚ùå Validation error - Field: input, Message: Input must be a valid integer Processing input \u0026#39;-5\u0026#39;: ‚ùå Validation error - Field: number, Message: Number cannot be negative Processing input \u0026#39;999\u0026#39;: ‚ùå Network error - Code: 503, Message: Service temporarily unavailable Processing input \u0026#39;42\u0026#39;: ‚úÖ Processing successful === File Error Handling === Checking file \u0026#39;existing.txt\u0026#39;: ‚úÖ File exists Checking file \u0026#39;missing.txt\u0026#39;: ‚ùå File does not exist 4. Error Wrapping and Context\r4.1 New Features of errors Package (Go 1.13+)\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) // Simulate database operation func databaseQuery(query string) error { if query == \u0026#34;invalid\u0026#34; { return errors.New(\u0026#34;Database query syntax error\u0026#34;) } if query == \u0026#34;timeout\u0026#34; { return errors.New(\u0026#34;Database connection timeout\u0026#34;) } return nil } // Business layer function func getUserData(userID string) error { // Validate user ID if userID == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;User ID cannot be empty\u0026#34;) } // Query database if err := databaseQuery(\u0026#34;SELECT * FROM users WHERE id = \u0026#34; + userID); err != nil { return fmt.Errorf(\u0026#34;Failed to get user data: %w\u0026#34;, err) // Wrap error } return nil } // Service layer function func handleUserRequest(userID string) error { if err := getUserData(userID); err != nil { return fmt.Errorf(\u0026#34;Failed to handle user request: %w\u0026#34;, err) // Wrap again } return nil } func demonstrateErrorWrapping() { userIDs := []string{\u0026#34;\u0026#34;, \u0026#34;invalid\u0026#34;, \u0026#34;timeout\u0026#34;, \u0026#34;123\u0026#34;} for _, userID := range userIDs { fmt.Printf(\u0026#34;Processing user request UserID=\u0026#39;%s\u0026#39;: \u0026#34;, userID) err := handleUserRequest(userID) if err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) // Check specific error if errors.Is(err, os.ErrNotExist) { fmt.Printf(\u0026#34; Reason: File does not exist\\n\u0026#34;) } // Find specific type of error var pathError *os.PathError if errors.As(err, \u0026amp;pathError) { fmt.Printf(\u0026#34; Path error: Operation=%s, Path=%s\\n\u0026#34;, pathError.Op, pathError.Path) } // Print error chain fmt.Printf(\u0026#34; Error chain: \u0026#34;) for err != nil { fmt.Printf(\u0026#34;%v\u0026#34;, err) if err = errors.Unwrap(err); err != nil { fmt.Printf(\u0026#34; -\u0026gt; \u0026#34;) } } fmt.Println() } else { fmt.Printf(\u0026#34;‚úÖ Request processing successful\\n\u0026#34;) } fmt.Println() } } // Custom wrappable error type CustomError struct { Code int Message string Err error // Embed underlying error } func (e CustomError) Error() string { if e.Err != nil { return fmt.Sprintf(\u0026#34;Custom error[%d]: %s (Reason: %v)\u0026#34;, e.Code, e.Message, e.Err) } return fmt.Sprintf(\u0026#34;Custom error[%d]: %s\u0026#34;, e.Code, e.Message) } func (e CustomError) Unwrap() error { return e.Err } func main() { fmt.Println(\u0026#34;=== Error Wrapping and Context ===\u0026#34;) demonstrateErrorWrapping() // Custom error wrapping example fmt.Println(\u0026#34;=== Custom Error Wrapping ===\u0026#34;) baseErr := errors.New(\u0026#34;Underlying error\u0026#34;) wrappedErr := CustomError{ Code: 1001, Message: \u0026#34;Business logic error\u0026#34;, Err: baseErr, } fmt.Printf(\u0026#34;Wrapped error: %v\\n\u0026#34;, wrappedErr) fmt.Printf(\u0026#34;Underlying error: %v\\n\u0026#34;, errors.Unwrap(wrappedErr)) fmt.Printf(\u0026#34;Has underlying error: %t\\n\u0026#34;, errors.Is(wrappedErr, baseErr)) } Execution result:\n=== Error Wrapping and Context === Processing user request UserID=\u0026#39;\u0026#39;: ‚ùå Failed to handle user request: Failed to get user data: User ID cannot be empty Error chain: Failed to handle user request: Failed to get user data: User ID cannot be empty Processing user request UserID=\u0026#39;invalid\u0026#39;: ‚ùå Failed to handle user request: Failed to get user data: Database query syntax error Error chain: Failed to handle user request: Failed to get user data: Database query syntax error Processing user request UserID=\u0026#39;timeout\u0026#39;: ‚ùå Failed to handle user request: Failed to get user data: Database connection timeout Error chain: Failed to handle user request: Failed to get user data: Database connection timeout Processing user request UserID=\u0026#39;123\u0026#39;: ‚úÖ Request processing successful === Custom Error Wrapping === Wrapped error: Custom error[1001]: Business logic error (Reason: Underlying error) Underlying error: Underlying error Has underlying error: true 4.2 Multiple Error Handling\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) // Error collection type type ErrorCollection []error func (ec ErrorCollection) Error() string { if len(ec) == 0 { return \u0026#34;\u0026#34; } var errorMsgs []string for _, err := range ec { errorMsgs = append(errorMsgs, err.Error()) } return fmt.Sprintf(\u0026#34;Occurred %d errors: %s\u0026#34;, len(ec), strings.Join(errorMsgs, \u0026#34;; \u0026#34;)) } // Parallel task processing func processTasks(taskNames []string) error { var errorsList ErrorCollection // Simulate parallel processing of multiple tasks for _, taskName := range taskNames { if err := processSingleTask(taskName); err != nil { errorsList = append(errorsList, fmt.Errorf(\u0026#34;Task \u0026#39;%s\u0026#39; failed: %w\u0026#34;, taskName, err)) } } if len(errorsList) \u0026gt; 0 { return errorsList } return nil } func processSingleTask(taskName string) error { switch taskName { case \u0026#34;task1\u0026#34;: return errors.New(\u0026#34;Network connection failed\u0026#34;) case \u0026#34;task2\u0026#34;: return errors.New(\u0026#34;File does not exist\u0026#34;) case \u0026#34;task3\u0026#34;: return nil // Success case \u0026#34;task4\u0026#34;: return errors.New(\u0026#34;Insufficient permissions\u0026#34;) default: return errors.New(\u0026#34;Unknown task\u0026#34;) } } // Grouped error handling func handleGroupedErrors() { taskGroups := [][]string{ {\u0026#34;task1\u0026#34;, \u0026#34;task2\u0026#34;, \u0026#34;task3\u0026#34;}, {\u0026#34;task3\u0026#34;, \u0026#34;task4\u0026#34;}, {\u0026#34;task1\u0026#34;, \u0026#34;task4\u0026#34;, \u0026#34;task5\u0026#34;}, } for i, tasks := range taskGroups { fmt.Printf(\u0026#34;Processing task group %d %v:\\n\u0026#34;, i+1, tasks) err := processTasks(tasks) if err != nil { if errorCollection, ok := err.(ErrorCollection); ok { fmt.Printf(\u0026#34; ‚ùå Occurred %d errors:\\n\u0026#34;, len(errorCollection)) for j, singleErr := range errorCollection { fmt.Printf(\u0026#34; %d. %v\\n\u0026#34;, j+1, singleErr) } } else { fmt.Printf(\u0026#34; ‚ùå Single error: %v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34; ‚úÖ All tasks completed successfully\\n\u0026#34;) } fmt.Println() } } func main() { fmt.Println(\u0026#34;=== Multiple Error Handling ===\u0026#34;) handleGroupedErrors() // Error merging example fmt.Println(\u0026#34;=== Error Merging ===\u0026#34;) err1 := errors.New(\u0026#34;First error\u0026#34;) err2 := errors.New(\u0026#34;Second error\u0026#34;) err3 := errors.New(\u0026#34;Third error\u0026#34;) combined := ErrorCollection{err1, err2, err3} fmt.Printf(\u0026#34;Merged error: %v\\n\u0026#34;, combined) // Empty error collection empty := ErrorCollection{} fmt.Printf(\u0026#34;Empty error collection: %v, is nil: %t\\n\u0026#34;, empty, empty == nil) } Execution result:\n=== Multiple Error Handling === Processing task group 1 [task1 task2 task3]: ‚ùå Occurred 2 errors: 1. Task \u0026#39;task1\u0026#39; failed: Network connection failed 2. Task \u0026#39;task2\u0026#39; failed: File does not exist Processing task group 2 [task3 task4]: ‚ùå Occurred 1 errors: 1. Task \u0026#39;task4\u0026#39; failed: Insufficient permissions Processing task group 3 [task1 task4 task5]: ‚ùå Occurred 3 errors: 1. Task \u0026#39;task1\u0026#39; failed: Network connection failed 2. Task \u0026#39;task4\u0026#39; failed: Insufficient permissions 3. Task \u0026#39;task5\u0026#39; failed: Unknown task === Error Merging === Merged error: Occurred 3 errors: First error; Second error; Third error Empty error collection: , is nil: true 5. Error Handling in Practical Applications\r5.1 Web Service Error Handling\rpackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) // API error response structure type APIErrorResponse struct { Error bool `json:\u0026#34;error\u0026#34;` Code int `json:\u0026#34;code\u0026#34;` Message string `json:\u0026#34;message\u0026#34;` Time string `json:\u0026#34;time\u0026#34;` } // Custom HTTP error type type HTTPError struct { Code int Message string Err error } func (e HTTPError) Error() string { if e.Err != nil { return fmt.Sprintf(\u0026#34;HTTP %d: %s (Reason: %v)\u0026#34;, e.Code, e.Message, e.Err) } return fmt.Sprintf(\u0026#34;HTTP %d: %s\u0026#34;, e.Code, e.Message) } // Error handling middleware func errorHandler(next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { defer func() { if err := recover(); err != nil { fmt.Printf(\u0026#34;Panic recovered: %v\\n\u0026#34;, err) sendErrorResponse(w, http.StatusInternalServerError, \u0026#34;Internal server error\u0026#34;) } }() next(w, r) } } // Send error response func sendErrorResponse(w http.ResponseWriter, code int, message string) { response := APIErrorResponse{ Error: true, Code: code, Message: message, Time: time.Now().Format(time.RFC3339), } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(code) if err := json.NewEncoder(w).Encode(response); err != nil { fmt.Printf(\u0026#34;JSON encoding error: %v\\n\u0026#34;, err) } } // Simulate user service type UserService struct{} func (s *UserService) GetUser(id string) (map[string]interface{}, error) { if id == \u0026#34;\u0026#34; { return nil, HTTPError{ Code: http.StatusBadRequest, Message: \u0026#34;User ID cannot be empty\u0026#34;, } } if id == \u0026#34;admin\u0026#34; { return nil, HTTPError{ Code: http.StatusForbidden, Message: \u0026#34;Access to administrator account forbidden\u0026#34;, } } if id == \u0026#34;missing\u0026#34; { return nil, HTTPError{ Code: http.StatusNotFound, Message: \u0026#34;User does not exist\u0026#34;, } } // Success case return map[string]interface{}{ \u0026#34;id\u0026#34;: id, \u0026#34;name\u0026#34;: fmt.Sprintf(\u0026#34;User%s\u0026#34;, id), \u0026#34;age\u0026#34;: 25, }, nil } // HTTP handler func userHandler(w http.ResponseWriter, r *http.Request) { userID := r.URL.Query().Get(\u0026#34;id\u0026#34;) userService := \u0026amp;UserService{} user, err := userService.GetUser(userID) if err != nil { if httpErr, ok := err.(HTTPError); ok { sendErrorResponse(w, httpErr.Code, httpErr.Message) } else { sendErrorResponse(w, http.StatusInternalServerError, \u0026#34;Internal error\u0026#34;) } return } // Success response w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) json.NewEncoder(w).Encode(user) } func demonstrateWebErrors() { // Simulate HTTP request processing testCases := []string{\u0026#34;\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;missing\u0026#34;, \u0026#34;normal\u0026#34;} fmt.Println(\u0026#34;=== Web Service Error Handling Demonstration ===\u0026#34;) for _, userID := range testCases { fmt.Printf(\u0026#34;Requesting user ID \u0026#39;%s\u0026#39;: \u0026#34;, userID) // Simulate request userService := \u0026amp;UserService{} user, err := userService.GetUser(userID) if err != nil { if httpErr, ok := err.(HTTPError); ok { fmt.Printf(\u0026#34;‚ùå HTTP error %d: %s\\n\u0026#34;, httpErr.Code, httpErr.Message) } else { fmt.Printf(\u0026#34;‚ùå Unknown error: %v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34;‚úÖ Successfully got user: %+v\\n\u0026#34;, user) } } } func main() { demonstrateWebErrors() // Start HTTP server example (commented out to avoid actual startup) /* http.HandleFunc(\u0026#34;/user\u0026#34;, errorHandler(userHandler)) fmt.Println(\u0026#34;Server starting on :8080\u0026#34;) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) */ // Error logging example fmt.Println(\u0026#34;\\n=== Error Logging ===\u0026#34;) logError := func(operation string, err error) { fmt.Printf(\u0026#34;[%s] ERROR: %v\\n\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;), err) } // Simulate various error scenarios errorsToLog := []error{ errors.New(\u0026#34;Database connection failed\u0026#34;), fmt.Errorf(\u0026#34;File read error: %w\u0026#34;, errors.New(\u0026#34;Insufficient permissions\u0026#34;)), HTTPError{Code: 500, Message: \u0026#34;Internal server error\u0026#34;}, } for _, err := range errorsToLog { logError(\u0026#34;Data processing\u0026#34;, err) } } Execution result:\n=== Web Service Error Handling Demonstration === Requesting user ID \u0026#39;\u0026#39;: ‚ùå HTTP error 400: User ID cannot be empty Requesting user ID \u0026#39;admin\u0026#39;: ‚ùå HTTP error 403: Access to administrator account forbidden Requesting user ID \u0026#39;missing\u0026#39;: ‚ùå HTTP error 404: User does not exist Requesting user ID \u0026#39;normal\u0026#39;: ‚úÖ Successfully got user: map[age:25 id:normal name:Usernormal] === Error Logging === [2024-01-15 15:30:45] ERROR: Database connection failed [2024-01-15 15:30:45] ERROR: File read error: Insufficient permissions [2024-01-15 15:30:45] ERROR: HTTP 500: Internal server error 5.2 Database Operation Error Handling\rpackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Simulate database driver type MockDB struct { tables map[string][]map[string]interface{} } func NewMockDB() *MockDB { return \u0026amp;MockDB{ tables: make(map[string][]map[string]interface{}), } } func (db *MockDB) Query(query string, args ...interface{}) (*sql.Rows, error) { if query == \u0026#34;invalid sql\u0026#34; { return nil, errors.New(\u0026#34;SQL syntax error\u0026#34;) } if query == \u0026#34;timeout\u0026#34; { return nil, errors.New(\u0026#34;Query timeout\u0026#34;) } // Simulate successful query return \u0026amp;sql.Rows{}, nil } func (db *MockDB) Exec(query string, args ...interface{}) (sql.Result, error) { if query == \u0026#34;duplicate key\u0026#34; { return nil, errors.New(\u0026#34;Unique constraint violation\u0026#34;) } if query == \u0026#34;foreign key violation\u0026#34; { return nil, errors.New(\u0026#34;Foreign key constraint violation\u0026#34;) } return \u0026amp;mockResult{rowsAffected: 1}, nil } type mockResult struct { rowsAffected int64 } func (r *mockResult) LastInsertId() (int64, error) { return 1, nil } func (r *mockResult) RowsAffected() (int64, error) { return r.rowsAffected, nil } // Data access layer type UserRepository struct { db *MockDB } func NewUserRepository(db *MockDB) *UserRepository { return \u0026amp;UserRepository{db: db} } func (r *UserRepository) CreateUser(user map[string]interface{}) error { // Validate user data if user[\u0026#34;name\u0026#34;] == nil || user[\u0026#34;name\u0026#34;] == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;Username cannot be empty\u0026#34;) } if user[\u0026#34;email\u0026#34;] == nil || user[\u0026#34;email\u0026#34;] == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;Email cannot be empty\u0026#34;) } // Execute database insertion query := \u0026#34;INSERT INTO users (name, email) VALUES (?, ?)\u0026#34; _, err := r.db.Exec(query, user[\u0026#34;name\u0026#34;], user[\u0026#34;email\u0026#34;]) if err != nil { // Return different business errors based on different error types if err.Error() == \u0026#34;Unique constraint violation\u0026#34; { return fmt.Errorf(\u0026#34;Email address already exists: %w\u0026#34;, err) } if err.Error() == \u0026#34;Foreign key constraint violation\u0026#34; { return fmt.Errorf(\u0026#34;Associated data does not exist: %w\u0026#34;, err) } return fmt.Errorf(\u0026#34;Database operation failed: %w\u0026#34;, err) } return nil } func (r *UserRepository) FindUserByEmail(email string) (map[string]interface{}, error) { if email == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;Email address cannot be empty\u0026#34;) } query := \u0026#34;SELECT * FROM users WHERE email = ?\u0026#34; rows, err := r.db.Query(query, email) if err != nil { return nil, fmt.Errorf(\u0026#34;Failed to query user: %w\u0026#34;, err) } defer rows.Close() // Simulate query results if email == \u0026#34;notfound@example.com\u0026#34; { return nil, fmt.Errorf(\u0026#34;User does not exist\u0026#34;) } return map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Zhang San\u0026#34;, \u0026#34;email\u0026#34;: email, }, nil } func demonstrateDatabaseErrors() { db := NewMockDB() repo := NewUserRepository(db) fmt.Println(\u0026#34;=== Database Error Handling Demonstration ===\u0026#34;) // Test various error cases for creating users testUsers := []map[string]interface{}{ {\u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@example.com\u0026#34;}, // Empty name {\u0026#34;name\u0026#34;: \u0026#34;Zhang San\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;\u0026#34;}, // Empty email {\u0026#34;name\u0026#34;: \u0026#34;Li Si\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;duplicate@example.com\u0026#34;}, // Duplicate email {\u0026#34;name\u0026#34;: \u0026#34;Wang Wu\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;valid@example.com\u0026#34;}, // Normal case } for i, user := range testUsers { fmt.Printf(\u0026#34;Test %d - Creating user %+v: \u0026#34;, i+1, user) err := repo.CreateUser(user) if err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;‚úÖ Creation successful\\n\u0026#34;) } } // Test querying users fmt.Println(\u0026#34;\\n=== Query User Test ===\u0026#34;) testEmails := []string{ \u0026#34;\u0026#34;, // Empty email \u0026#34;notfound@example.com\u0026#34;, // User does not exist \u0026#34;valid@example.com\u0026#34;, // Normal query } for _, email := range testEmails { fmt.Printf(\u0026#34;Querying email \u0026#39;%s\u0026#39;: \u0026#34;, email) user, err := repo.FindUserByEmail(email) if err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;‚úÖ Found user: %+v\\n\u0026#34;, user) } } } func main() { demonstrateDatabaseErrors() // Transaction error handling example fmt.Println(\u0026#34;\\n=== Transaction Error Handling ===\u0026#34;) simulateTransaction := func() error { // Begin transaction fmt.Println(\u0026#34;Starting transaction...\u0026#34;) // Step 1: Create user if err := errors.New(\u0026#34;User creation failed\u0026#34;); err != nil { fmt.Printf(\u0026#34;‚ùå Transaction step 1 failed: %v\\n\u0026#34;, err) return fmt.Errorf(\u0026#34;Transaction rollback: User creation failed - %w\u0026#34;, err) } // Step 2: Create user profile if err := errors.New(\u0026#34;Profile creation failed\u0026#34;); err != nil { fmt.Printf(\u0026#34;‚ùå Transaction step 2 failed: %v\\n\u0026#34;, err) return fmt.Errorf(\u0026#34;Transaction rollback: Profile creation failed - %w\u0026#34;, err) } // Step 3: Send welcome email if err := errors.New(\u0026#34;Email sending failed\u0026#34;); err != nil { fmt.Printf(\u0026#34;‚ö†Ô∏è Non-critical step failed: %v\\n\u0026#34;, err) // Non-critical step failure, can choose to continue } fmt.Println(\u0026#34;‚úÖ Transaction committed successfully\u0026#34;) return nil } if err := simulateTransaction(); err != nil { fmt.Printf(\u0026#34;Transaction ultimately failed: %v\\n\u0026#34;, err) } } Execution result:\n=== Database Error Handling Demonstration === Test 1 - Creating user map[email:test@example.com name:]: ‚ùå Username cannot be empty Test 2 - Creating user map[email: name:Zhang San]: ‚ùå Email cannot be empty Test 3 - Creating user map[email:duplicate@example.com name:Li Si]: ‚ùå Email address already exists: Unique constraint violation Test 4 - Creating user map[email:valid@example.com name:Wang Wu]: ‚úÖ Creation successful === Query User Test === Querying email \u0026#39;\u0026#39;: ‚ùå Email address cannot be empty Querying email \u0026#39;notfound@example.com\u0026#39;: ‚ùå User does not exist Querying email \u0026#39;valid@example.com\u0026#39;: ‚úÖ Found user: map[email:valid@example.com id:1 name:Zhang San] === Transaction Error Handling === Starting transaction... ‚ùå Transaction step 1 failed: User creation failed Transaction ultimately failed: Transaction rollback: User creation failed - User creation failed 6. Error Handling Best Practices\r6.1 Error Handling Principles\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) // Good error handling practices // 1. Handle errors promptly, don\u0026#39;t delay func goodErrorHandling1() error { data, err := readConfig() if err != nil { return fmt.Errorf(\u0026#34;Failed to read config: %w\u0026#34;, err) // Handle immediately } if err := validateConfig(data); err != nil { return fmt.Errorf(\u0026#34;Config validation failed: %w\u0026#34;, err) // Handle immediately } return nil } // 2. Provide meaningful error information func goodErrorHandling2(filename string) error { file, err := openFile(filename) if err != nil { // Good error information includes context return fmt.Errorf(\u0026#34;Unable to open config file \u0026#39;%s\u0026#39;: %w\u0026#34;, filename, err) } defer file.Close() return nil } // 3. Distinguish different types of errors func goodErrorHandling3(userID string) error { user, err := findUser(userID) if err != nil { // Take different actions based on error type switch { case errors.Is(err, ErrUserNotFound): return fmt.Errorf(\u0026#34;User does not exist, please register first\u0026#34;) case errors.Is(err, ErrDatabaseDown): return fmt.Errorf(\u0026#34;System maintenance, please try again later\u0026#34;) default: return fmt.Errorf(\u0026#34;Failed to get user info: %w\u0026#34;, err) } } if !user.IsActive { return fmt.Errorf(\u0026#34;User account has been disabled\u0026#34;) } return nil } // 4. Log errors but don\u0026#39;t expose internal details func goodErrorHandling4() { if err := sensitiveOperation(); err != nil { // Log detailed error to logs log.Printf(\u0026#34;Sensitive operation failed (internal error): %+v\u0026#34;, err) // Return generic error to user fmt.Println(\u0026#34;Operation failed, please contact administrator\u0026#34;) } } // Simulate functions func readConfig() (interface{}, error) { return nil, errors.New(\u0026#34;File does not exist\u0026#34;) } func validateConfig(data interface{}) error { return errors.New(\u0026#34;Config format error\u0026#34;) } func openFile(filename string) (interface{}, error) { return nil, errors.New(\u0026#34;Permission denied\u0026#34;) } var ( ErrUserNotFound = errors.New(\u0026#34;User does not exist\u0026#34;) ErrDatabaseDown = errors.New(\u0026#34;Database down\u0026#34;) ) func findUser(userID string) (interface{}, error) { return nil, ErrUserNotFound } type User struct { IsActive bool } func sensitiveOperation() error { return errors.New(\u0026#34;Internal database credentials leaked\u0026#34;) } // Bad error handling practices // 1. Ignoring errors func badErrorHandling1() { data, _ := readConfig() // Error ignored processConfig(data) // May use nil data } // 2. Unclear error information func badErrorHandling2(filename string) error { _, err := openFile(filename) if err != nil { return err // Error information too simple } return nil } // 3. Over-wrapping errors func badErrorHandling3() error { err := lowLevelError() if err != nil { return fmt.Errorf(\u0026#34;High-level error: %w\u0026#34;, fmt.Errorf(\u0026#34;Mid-level error: %w\u0026#34;, fmt.Errorf(\u0026#34;Low-level error: %w\u0026#34;, err))) // Over-wrapping } return nil } func lowLevelError() error { return errors.New(\u0026#34;Low-level error\u0026#34;) } func processConfig(data interface{}) { // Process config } func main() { fmt.Println(\u0026#34;=== Error Handling Best Practices ===\u0026#34;) fmt.Println(\u0026#34;Good practice examples:\u0026#34;) if err := goodErrorHandling1(); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } if err := goodErrorHandling2(\u0026#34;config.json\u0026#34;); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } if err := goodErrorHandling3(\u0026#34;user123\u0026#34;); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } goodErrorHandling4() fmt.Println(\u0026#34;\\nBad practices to avoid:\u0026#34;) fmt.Println(\u0026#34;1. Ignoring errors may cause program crashes\u0026#34;) fmt.Println(\u0026#34;2. Unclear error information is difficult to debug\u0026#34;) fmt.Println(\u0026#34;3. Over-wrapping makes error chains overly complex\u0026#34;) // Demonstrate error logging best practices fmt.Println(\u0026#34;\\n=== Error Logging Best Practices ===\u0026#34;) logError := func(context string, err error) { // Development environment: detailed logs log.Printf(\u0026#34;[DEBUG] %s failed: %+v\u0026#34;, context, err) // Production environment: simplified logs log.Printf(\u0026#34;[ERROR] %s failed, please check detailed logs\u0026#34;, context) } // Simulate error recording sampleErr := fmt.Errorf(\u0026#34;Database connection failed: %w\u0026#34;, errors.New(\u0026#34;Network timeout\u0026#34;)) logError(\u0026#34;User login\u0026#34;, sampleErr) } Execution result:\n=== Error Handling Best Practices === Good practice examples: ‚ùå Failed to read config: File does not exist ‚ùå Unable to open config file \u0026#39;config.json\u0026#39;: Permission denied ‚ùå User does not exist, please register first Operation failed, please contact administrator Bad practices to avoid: 1. Ignoring errors may cause program crashes 2. Unclear error information is difficult to debug 3. Over-wrapping makes error chains overly complex === Error Logging Best Practices === 2024/01/15 15:30:45 [DEBUG] User login failed: Database connection failed: Network timeout 2024/01/15 15:30:45 [ERROR] User login failed, please check detailed logs 7. Summary\rGo language\u0026rsquo;s error handling mechanism embodies its design philosophy of \u0026ldquo;simple, clear, practical\u0026rdquo;:\nCore points:\nErrors are values and should be explicitly checked and handled Use error interface to unify error representation Modern error handling features provided through errors package Reasonable use of error wrapping and context information Best practices:\nHandle promptly: Handle errors immediately when discovered, don\u0026rsquo;t delay Provide context: Error information should include sufficient context Distinguish error types: Take different handling strategies based on error types Log detailed information: Record detailed errors internally, return appropriate information externally Avoid error ignoring: Unless truly ignorable, all errors should be handled Modern developments:\nGo 1.13+ introduced new error wrapping and checking features errors.Is() and errors.As() provide better error checking capabilities fmt.Errorf()\u0026rsquo;s %w verb supports error wrapping Good error handling not only improves program robustness but also greatly enhances user experience and system maintainability. In actual development, appropriate error handling strategies should be chosen based on specific scenarios.\n","date":"2026-02-04T20:15:16+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-12/","title":"Golang Learning Journey [Part 12: Error Handling]"},{"content":"1. What is Interface\rInterface is the core mechanism for implementing abstraction and polymorphism in Go language. If structs solve the problem of \u0026ldquo;what data is\u0026rdquo;, then interfaces solve the problem of \u0026ldquo;what can be done\u0026rdquo;. Interfaces define a set of method signatures, and any type that implements these methods \u0026ldquo;implements\u0026rdquo; the interface.\n1.1 Basic Concepts of Interface\rLet\u0026rsquo;s understand interfaces through a real-life example:\nReal scenario:\nUSB interface: Defines the standard for data transmission Any device that conforms to USB standards (USB drives, mice, keyboards) can be plugged in and used We don\u0026rsquo;t need to care what specific device it is, as long as it conforms to USB standards Programming scenario:\nInterface defines method signatures (what can be done) Any type that implements these methods automatically implements the interface We can program to interfaces rather than caring about specific implementations 1.2 Value and Significance of Interfaces\rMain roles of interfaces:\nDecoupling: Separate interface definition from specific implementation Polymorphism: Same interface can have multiple implementations Abstraction: Hide specific implementation details Extensibility: Easy to add new implementations Test-friendly: Facilitate writing mock tests 2. Basic Interface Syntax\r2.1 Interface Definition Syntax\rtype InterfaceName interface { MethodName1(ParameterList) ReturnList MethodName2(ParameterList) ReturnList // ... More methods } 2.2 Simple Interface Example\rpackage main import \u0026#34;fmt\u0026#34; // Define animal interface type Animal interface { Speak() string // Speaking method Move() string // Moving method GetAge() int // Get age method } // Dog implementation type Dog struct { Name string Age int } func (d Dog) Speak() string { return \u0026#34;Woof\u0026#34; } func (d Dog) Move() string { return \u0026#34;Running\u0026#34; } func (d Dog) GetAge() int { return d.Age } // Cat implementation type Cat struct { Name string Age int } func (c Cat) Speak() string { return \u0026#34;Meow\u0026#34; } func (c Cat) Move() string { return \u0026#34;Crawling\u0026#34; } func (c Cat) GetAge() int { return c.Age } // Bird implementation type Bird struct { Species string Age int } func (b Bird) Speak() string { return \u0026#34;Chirp\u0026#34; } func (b Bird) Move() string { return \u0026#34;Flying\u0026#34; } func (b Bird) GetAge() int { return b.Age } // Function using interface func MakeAnimalSpeak(animal Animal) { fmt.Printf(\u0026#34;Animal speaks: %s\\n\u0026#34;, animal.Speak()) } func ShowAnimalMove(animal Animal) { fmt.Printf(\u0026#34;Animal moves by: %s\\n\u0026#34;, animal.Move()) } func main() { // Create different types of animals dog := Dog{Name: \u0026#34;Wang Cai\u0026#34;, Age: 3} cat := Cat{Name: \u0026#34;Mi Mi\u0026#34;, Age: 2} bird := Bird{Species: \u0026#34;Parrot\u0026#34;, Age: 1} // All can be used as Animal interface animals := []Animal{dog, cat, bird} fmt.Println(\u0026#34;=== Animal Performance ===\u0026#34;) for i, animal := range animals { fmt.Printf(\u0026#34;Animal %d:\\n\u0026#34;, i+1) MakeAnimalSpeak(animal) ShowAnimalMove(animal) fmt.Printf(\u0026#34;Age: %d years\\n\\n\u0026#34;, animal.GetAge()) } // Direct use of specific types fmt.Println(\u0026#34;=== Specific Type Calls ===\u0026#34;) fmt.Printf(\u0026#34;Dog speaks: %s\\n\u0026#34;, dog.Speak()) fmt.Printf(\u0026#34;Cat moves: %s\\n\u0026#34;, cat.Move()) fmt.Printf(\u0026#34;Bird age: %d\\n\u0026#34;, bird.GetAge()) } Execution result:\n=== Animal Performance === Animal 1: Animal speaks: Woof Animal moves by: Running Age: 3 years Animal 2: Animal speaks: Meow Animal moves by: Crawling Age: 2 years Animal 3: Animal speaks: Chirp Animal moves by: Flying Age: 1 years === Specific Type Calls === Dog speaks: Woof Cat moves: Crawling Bird age: 1 3. Interface Implementation Mechanism\r3.1 Implicit Implementation\rGo language\u0026rsquo;s interface implementation is implicit and doesn\u0026rsquo;t require explicit declaration:\npackage main import \u0026#34;fmt\u0026#34; // Define interfaces type Writer interface { Write(data string) (int, error) } type Reader interface { Read() (string, error) } // File type implementation type File struct { Name string Content string Pos int } func (f *File) Write(data string) (int, error) { f.Content += data return len(data), nil } func (f *File) Read() (string, error) { if f.Pos \u0026gt;= len(f.Content) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Reading ended\u0026#34;) } result := f.Content[f.Pos:] f.Pos = len(f.Content) return result, nil } // Network connection type implementation type NetworkConnection struct { Address string Buffer string } func (nc *NetworkConnection) Write(data string) (int, error) { nc.Buffer += data fmt.Printf(\u0026#34;Network sending to %s: %s\\n\u0026#34;, nc.Address, data) return len(data), nil } func (nc *NetworkConnection) Read() (string, error) { if nc.Buffer == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Buffer is empty\u0026#34;) } result := nc.Buffer nc.Buffer = \u0026#34;\u0026#34; return result, nil } // Generic function using interfaces func ProcessData(w Writer, r Reader, data string) { // Write data n, err := w.Write(data) if err != nil { fmt.Printf(\u0026#34;Write error: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Successfully wrote %d characters\\n\u0026#34;, n) // Read data content, err := r.Read() if err != nil { fmt.Printf(\u0026#34;Read error: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Read content: %s\\n\u0026#34;, content) } func main() { // File operations file := \u0026amp;File{Name: \u0026#34;test.txt\u0026#34;} fmt.Println(\u0026#34;=== File Operations ===\u0026#34;) ProcessData(file, file, \u0026#34;Hello, File!\u0026#34;) // Network operations conn := \u0026amp;NetworkConnection{Address: \u0026#34;192.168.1.1:8080\u0026#34;} fmt.Println(\u0026#34;\\n=== Network Operations ===\u0026#34;) ProcessData(conn, conn, \u0026#34;Hello, Network!\u0026#34;) // Mixed use fmt.Println(\u0026#34;\\n=== Mixed Operations ===\u0026#34;) ProcessData(file, conn, \u0026#34;Mixed operation test\u0026#34;) } Execution result:\n=== File Operations === Successfully wrote 11 characters Read content: Hello, File! === Network Operations === Network sending to 192.168.1.1:8080: Hello, Network! Successfully wrote 15 characters Read content: Hello, Network! === Mixed Operations === Successfully wrote 21 characters Network sending to 192.168.1.1:8080: Hello, File! Read content: Hello, File! 3.2 Internal Structure of Interface Values\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;unsafe\u0026#34; ) type Speaker interface { Speak() string } type Dog struct { Name string } func (d Dog) Speak() string { return \u0026#34;Woof, I\u0026#39;m \u0026#34; + d.Name } type Cat struct { Name string } func (c Cat) Speak() string { return \u0026#34;Meow, I\u0026#39;m \u0026#34; + c.Name } func InspectInterface(i interface{}) { v := reflect.ValueOf(i) fmt.Printf(\u0026#34;Type: %T\\n\u0026#34;, i) fmt.Printf(\u0026#34;Value: %v\\n\u0026#34;, i) fmt.Printf(\u0026#34;Is nil: %t\\n\u0026#34;, i == nil) if v.Kind() == reflect.Interface { elem := v.Elem() fmt.Printf(\u0026#34;Dynamic type: %T\\n\u0026#34;, elem.Interface()) fmt.Printf(\u0026#34;Dynamic value: %v\\n\u0026#34;, elem.Interface()) } fmt.Println(\u0026#34;---\u0026#34;) } func main() { // nil interface value var speaker1 Speaker fmt.Println(\u0026#34;1. nil interface value:\u0026#34;) InspectInterface(speaker1) // Concrete type assignment dog := Dog{Name: \u0026#34;Wang Cai\u0026#34;} speaker1 = dog fmt.Println(\u0026#34;2. After assigning Dog:\u0026#34;) InspectInterface(speaker1) // Different type assignment cat := Cat{Name: \u0026#34;Mi Mi\u0026#34;} speaker1 = cat fmt.Println(\u0026#34;3. After assigning Cat:\u0026#34;) InspectInterface(speaker1) // Interface slice speakers := []Speaker{dog, cat} fmt.Println(\u0026#34;4. Interface slice:\u0026#34;) for i, s := range speakers { fmt.Printf(\u0026#34;Index %d: %T - %s\\n\u0026#34;, i, s, s.Speak()) } } Execution result:\n1. nil interface value: Type: \u0026lt;nil\u0026gt; Value: \u0026lt;nil\u0026gt; Is nil: true --- 2. After assigning Dog: Type: main.Dog Value: {Wang Cai} Is nil: false Dynamic type: main.Dog Dynamic value: {Wang Cai} --- 3. After assigning Cat: Type: main.Cat Value: {Mi Mi} Is nil: false Dynamic type: main.Cat Dynamic value: {Mi Mi} --- 4. Interface slice: Index 0: main.Dog - Woof, I\u0026#39;m Wang Cai Index 1: main.Cat - Meow, I\u0026#39;m Mi Mi 4. Common Built-in Interfaces\r4.1 error Interface\rpackage main import ( \u0026#34;fmt\u0026#34; ) // error interface definition // type error interface { // Error() string // } // Custom error type type ValidationError struct { Field string Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;Validation error - Field: %s, Message: %s\u0026#34;, e.Field, e.Message) } type NetworkError struct { Code int Message string } func (e NetworkError) Error() string { return fmt.Sprintf(\u0026#34;Network error[%d]: %s\u0026#34;, e.Code, e.Message) } // Function returning error func ValidateAge(age int) error { if age \u0026lt; 0 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Message: \u0026#34;Age cannot be negative\u0026#34;, } } if age \u0026gt; 150 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Message: \u0026#34;Age cannot exceed 150 years\u0026#34;, } } return nil // No error } func ConnectToServer(url string) error { if url == \u0026#34;\u0026#34; { return NetworkError{ Code: 400, Message: \u0026#34;URL cannot be empty\u0026#34;, } } if url == \u0026#34;timeout.com\u0026#34; { return NetworkError{ Code: 504, Message: \u0026#34;Connection timeout\u0026#34;, } } return nil // Connection successful } func main() { // Test validation errors ages := []int{-5, 25, 200} for _, age := range ages { fmt.Printf(\u0026#34;Validating age %d: \u0026#34;, age) if err := ValidateAge(age); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;‚úÖ Validation passed\\n\u0026#34;) } } // Test network errors urls := []string{\u0026#34;\u0026#34;, \u0026#34;timeout.com\u0026#34;, \u0026#34;google.com\u0026#34;} fmt.Println(\u0026#34;\\n=== Network Connection Test ===\u0026#34;) for _, url := range urls { fmt.Printf(\u0026#34;Connecting to %s: \u0026#34;, url) if err := ConnectToServer(url); err != nil { fmt.Printf(\u0026#34;‚ùå %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;‚úÖ Connection successful\\n\u0026#34;) } } // Error type assertion fmt.Println(\u0026#34;\\n=== Error Type Analysis ===\u0026#34;) err := ValidateAge(-1) if err != nil { if validationErr, ok := err.(ValidationError); ok { fmt.Printf(\u0026#34;This is a validation error: field=%s, message=%s\\n\u0026#34;, validationErr.Field, validationErr.Message) } } } Execution result:\nValidating age -5: ‚ùå Validation error - Field: age, Message: Age cannot be negative Validating age 25: ‚úÖ Validation passed Validating age 200: ‚ùå Validation error - Field: age, Message: Age cannot exceed 150 years === Network Connection Test === Connecting to : ‚ùå Network error[400]: URL cannot be empty Connecting to timeout.com: ‚ùå Network error[504]: Connection timeout Connecting to google.com: ‚úÖ Connection successful === Error Type Analysis === This is a validation error: field=age, message=Age cannot be negative 4.2 Stringer Interface\rpackage main import ( \u0026#34;fmt\u0026#34; ) // Stringer interface definition // type Stringer interface { // String() string // } type Person struct { Name string Age int City string } func (p Person) String() string { return fmt.Sprintf(\u0026#34;Name: %s, Age: %d years, From: %s\u0026#34;, p.Name, p.Age, p.City) } type Product struct { Name string Price float64 Stock int } func (p Product) String() string { return fmt.Sprintf(\u0026#34;Product: %s, Price: ¬•%.2f, Stock: %d pieces\u0026#34;, p.Name, p.Price, p.Stock) } type Point struct { X, Y int } func (p Point) String() string { return fmt.Sprintf(\u0026#34;(%d, %d)\u0026#34;, p.X, p.Y) } func main() { // Create various objects person := Person{Name: \u0026#34;Zhang San\u0026#34;, Age: 25, City: \u0026#34;Beijing\u0026#34;} product := Product{Name: \u0026#34;iPhone 15\u0026#34;, Price: 5999.00, Stock: 100} point := Point{X: 10, Y: 20} // Direct printing will automatically call String() method fmt.Println(\u0026#34;=== Automatic String() Method Call ===\u0026#34;) fmt.Println(person) fmt.Println(product) fmt.Println(point) // Explicit String() method call fmt.Println(\u0026#34;\\n=== Explicit String() Method Call ===\u0026#34;) fmt.Println(\u0026#34;Person string representation: \u0026#34;, person.String()) fmt.Println(\u0026#34;Product string representation: \u0026#34;, product.String()) fmt.Println(\u0026#34;Point string representation: \u0026#34;, point.String()) // Usage in formatting fmt.Println(\u0026#34;\\n=== Formatted Output ===\u0026#34;) fmt.Printf(\u0026#34;Personal info: %s\\n\u0026#34;, person) fmt.Printf(\u0026#34;Product info: %s\\n\u0026#34;, product) fmt.Printf(\u0026#34;Coordinate info: %s\\n\u0026#34;, point) // Slices and maps people := []Person{ {Name: \u0026#34;Li Si\u0026#34;, Age: 30, City: \u0026#34;Shanghai\u0026#34;}, {Name: \u0026#34;Wang Wu\u0026#34;, Age: 28, City: \u0026#34;Guangzhou\u0026#34;}, } fmt.Println(\u0026#34;\\n=== Object Slice ===\u0026#34;) fmt.Println(people) } Execution result:\n=== Automatic String() Method Call === Name: Zhang San, Age: 25 years, From: Beijing Product: iPhone 15, Price: ¬•5999.00, Stock: 100 pieces (10, 20) === Explicit String() Method Call === Person string representation: Name: Zhang San, Age: 25 years, From: Beijing Product string representation: Product: iPhone 15, Price: ¬•5999.00, Stock: 100 pieces Point string representation: (10, 20) === Formatted Output === Personal info: Name: Zhang San, Age: 25 years, From: Beijing Product info: Product: iPhone 15, Price: ¬•5999.00, Stock: 100 pieces Coordinate info: (10, 20) === Object Slice === [{Li Si 30 Shanghai} {Wang Wu 28 Guangzhou}] 5. Interface Composition and Nesting\r5.1 Interface Composition\rpackage main import \u0026#34;fmt\u0026#34; // Basic interfaces type Reader interface { Read() (string, error) } type Writer interface { Write(data string) (int, error) } type Closer interface { Close() error } // Composite interfaces type ReadWriter interface { Reader // Embed Reader interface Writer // Embed Writer interface } type ReadWriteCloser interface { Reader // Reading functionality Writer // Writing functionality Closer // Closing functionality } // Concrete implementation type File struct { Name string Content string Closed bool } func (f *File) Read() (string, error) { if f.Closed { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;File is closed\u0026#34;) } return f.Content, nil } func (f *File) Write(data string) (int, error) { if f.Closed { return 0, fmt.Errorf(\u0026#34;File is closed\u0026#34;) } f.Content += data return len(data), nil } func (f *File) Close() error { f.Closed = true fmt.Printf(\u0026#34;File %s closed\\n\u0026#34;, f.Name) return nil } // Network connection implementation type NetworkConnection struct { Address string Buffer string Closed bool } func (nc *NetworkConnection) Read() (string, error) { if nc.Closed { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Connection is closed\u0026#34;) } if nc.Buffer == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Buffer is empty\u0026#34;) } result := nc.Buffer nc.Buffer = \u0026#34;\u0026#34; return result, nil } func (nc *NetworkConnection) Write(data string) (int, error) { if nc.Closed { return 0, fmt.Errorf(\u0026#34;Connection is closed\u0026#34;) } nc.Buffer += data fmt.Printf(\u0026#34;Sending to %s: %s\\n\u0026#34;, nc.Address, data) return len(data), nil } func (nc *NetworkConnection) Close() error { nc.Closed = true fmt.Printf(\u0026#34;Network connection %s closed\\n\u0026#34;, nc.Address) return nil } // Function using composite interface func ProcessData(rwc ReadWriteCloser, data string) error { // Write data _, err := rwc.Write(data) if err != nil { return err } // Read data content, err := rwc.Read() if err != nil { return err } fmt.Printf(\u0026#34;Read data: %s\\n\u0026#34;, content) // Close resources return rwc.Close() } func main() { // File operations file := \u0026amp;File{Name: \u0026#34;test.txt\u0026#34;} fmt.Println(\u0026#34;=== File Operations ===\u0026#34;) err := ProcessData(file, \u0026#34;Hello, File System!\u0026#34;) if err != nil { fmt.Printf(\u0026#34;File operation error: %v\\n\u0026#34;, err) } // Network operations conn := \u0026amp;NetworkConnection{Address: \u0026#34;192.168.1.100:8080\u0026#34;} fmt.Println(\u0026#34;\\n=== Network Operations ===\u0026#34;) err = ProcessData(conn, \u0026#34;Hello, Network!\u0026#34;) if err != nil { fmt.Printf(\u0026#34;Network operation error: %v\\n\u0026#34;, err) } // Verify interface compatibility fmt.Println(\u0026#34;\\n=== Interface Compatibility Test ===\u0026#34;) var rw ReadWriter = file fmt.Printf(\u0026#34;File implements ReadWriter interface: %t\\n\u0026#34;, rw != nil) var reader Reader = conn fmt.Printf(\u0026#34;NetworkConnection implements Reader interface: %t\\n\u0026#34;, reader != nil) } Execution result:\n=== File Operations === Read data: Hello, File System! File test.txt closed === Network Operations === Sending to 192.168.1.100:8080: Hello, Network! Read data: Hello, Network! Network connection 192.168.1.100:8080 closed === Interface Compatibility Test === File implements ReadWriter interface: true NetworkConnection implements Reader interface: true 6. Empty Interface and Type Assertion\r6.1 Empty Interface interface\rpackage main import ( \u0026#34;fmt\u0026#34; ) // Empty interface can store values of any type func PrintAnything(v interface{}) { fmt.Printf(\u0026#34;Value: %v, Type: %T\\n\u0026#34;, v, v) } func GetTypeDescription(v interface{}) string { switch v.(type) { case int: return \u0026#34;This is an integer\u0026#34; case string: return \u0026#34;This is a string\u0026#34; case bool: return \u0026#34;This is a boolean value\u0026#34; case []int: return \u0026#34;This is an integer slice\u0026#34; case map[string]int: return \u0026#34;This is a string to integer map\u0026#34; default: return fmt.Sprintf(\u0026#34;This is a %T type value\u0026#34;, v) } } func main() { // Empty interface can store any type values := []interface{}{ 42, \u0026#34;Hello\u0026#34;, true, 3.14, []int{1, 2, 3}, map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}, struct{ Name string }{Name: \u0026#34;Zhang San\u0026#34;}, } fmt.Println(\u0026#34;=== Empty Interface Storing Different Types ===\u0026#34;) for i, v := range values { fmt.Printf(\u0026#34;Index %d: %v\\n\u0026#34;, i, GetTypeDescription(v)) PrintAnything(v) } // Practical applications of empty interface fmt.Println(\u0026#34;\\n=== Practical Application Scenarios ===\u0026#34;) // 1. Generic container container := make(map[string]interface{}) container[\u0026#34;name\u0026#34;] = \u0026#34;Zhang San\u0026#34; container[\u0026#34;age\u0026#34;] = 25 container[\u0026#34;scores\u0026#34;] = []int{85, 92, 78} container[\u0026#34;active\u0026#34;] = true fmt.Println(\u0026#34;Generic container content:\u0026#34;) for key, value := range container { fmt.Printf(\u0026#34; %s: %v (%T)\\n\u0026#34;, key, value, value) } // 2. Function parameters processData := func(data interface{}) { switch v := data.(type) { case string: fmt.Printf(\u0026#34;Processing string: %s (Length: %d)\\n\u0026#34;, v, len(v)) case int: fmt.Printf(\u0026#34;Processing integer: %d (Square: %d)\\n\u0026#34;, v, v*v) case []int: sum := 0 for _, n := range v { sum += n } fmt.Printf(\u0026#34;Processing integer slice: Sum=%d\\n\u0026#34;, sum) default: fmt.Printf(\u0026#34;Processing unknown type: %T\\n\u0026#34;, v) } } processData(\u0026#34;Hello World\u0026#34;) processData(5) processData([]int{1, 2, 3, 4, 5}) } Execution result:\n=== Empty Interface Storing Different Types === Index 0: This is an integer Value: 42, Type: int Index 1: This is a string Value: Hello, Type: string Index 2: This is a boolean value Value: true, Type: bool Index 3: This is a float64 type value Value: 3.14, Type: float64 Index 4: This is an integer slice Value: [1 2 3], Type: []int Index 5: This is a string to integer map Value: map[a:1 b:2], Type: map[string]int Index 6: This is a struct { Name string } type value Value: {Zhang San}, Type: struct { Name string } === Practical Application Scenarios === Generic container content: active: true (bool) age: 25 (int) name: Zhang San (string) scores: [85 92 78] ([]int) Processing string: Hello World (Length: 11) Processing integer: 5 (Square: 25) Processing integer slice: Sum=15 6.2 Type Assertion\rpackage main import \u0026#34;fmt\u0026#34; func ProcessValue(v interface{}) { fmt.Printf(\u0026#34;Processing value: %v (Type: %T)\\n\u0026#34;, v, v) // Method 1: Type assertion (single type) if str, ok := v.(string); ok { fmt.Printf(\u0026#34; ‚úÖ This is a string, Length: %d, Content: %s\\n\u0026#34;, len(str), str) } if num, ok := v.(int); ok { fmt.Printf(\u0026#34; ‚úÖ This is an integer, Value: %d, Square: %d\\n\u0026#34;, num, num*num) } // Method 2: Type switch switch value := v.(type) { case string: fmt.Printf(\u0026#34; üî§ String processing: To uppercase: %s\\n\u0026#34;, stringToUpper(value)) case int: fmt.Printf(\u0026#34; üî¢ Integer processing: Even or odd: %s\\n\u0026#34;, evenOrOdd(value)) case bool: fmt.Printf(\u0026#34; üîò Boolean processing: Negation: %t\\n\u0026#34;, !value) case []int: fmt.Printf(\u0026#34; üìä Slice processing: Sum: %d\\n\u0026#34;, sumSlice(value)) case nil: fmt.Printf(\u0026#34; ‚ö†Ô∏è Null value processing\\n\u0026#34;) default: fmt.Printf(\u0026#34; ‚ùì Unknown type processing: %T\\n\u0026#34;, value) } fmt.Println() } func stringToUpper(s string) string { result := make([]rune, len(s)) for i, r := range s { if r \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;z\u0026#39; { result[i] = r - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; } else { result[i] = r } } return string(result) } func evenOrOdd(n int) string { if n%2 == 0 { return \u0026#34;Even\u0026#34; } return \u0026#34;Odd\u0026#34; } func sumSlice(nums []int) int { sum := 0 for _, n := range nums { sum += n } return sum } func main() { // Test different types testData := []interface{}{ \u0026#34;Hello World\u0026#34;, 42, true, []int{1, 2, 3, 4, 5}, 3.14, nil, } fmt.Println(\u0026#34;=== Type Assertion Demonstration ===\u0026#34;) for _, data := range testData { ProcessValue(data) } // Safe type conversion example fmt.Println(\u0026#34;=== Safe Type Conversion ===\u0026#34;) var unknown interface{} = \u0026#34;Test string\u0026#34; // Safe conversion if str, ok := unknown.(string); ok { fmt.Printf(\u0026#34;Safe conversion successful: %s\\n\u0026#34;, str) } else { fmt.Printf(\u0026#34;Conversion failed, not a string type\\n\u0026#34;) } // Unsafe conversion (would panic) // str := unknown.(string) // Would panic if unknown is not string // Batch processing example fmt.Println(\u0026#34;\\n=== Batch Data Processing ===\u0026#34;) mixedData := []interface{}{1, \u0026#34;two\u0026#34;, 3.0, true, \u0026#34;five\u0026#34;} strings := make([]string, 0) numbers := make([]int, 0) for _, item := range mixedData { switch v := item.(type) { case string: strings = append(strings, v) case int: numbers = append(numbers, v) } } fmt.Printf(\u0026#34;Extracted strings: %v\\n\u0026#34;, strings) fmt.Printf(\u0026#34;Extracted numbers: %v\\n\u0026#34;, numbers) } Execution result:\n=== Type Assertion Demonstration === Processing value: Hello World (Type: string) ‚úÖ This is a string, Length: 11, Content: Hello World üî§ String processing: To uppercase: HELLO WORLD Processing value: 42 (Type: int) ‚úÖ This is an integer, Value: 42, Square: 1764 üî¢ Integer processing: Even or odd: Even Processing value: true (Type: bool) üîò Boolean processing: Negation: false Processing value: [1 2 3 4 5] (Type: []int) üìä Slice processing: Sum: 15 Processing value: 3.14 (Type: float64) ‚ùì Unknown type processing: float64 Processing value: \u0026lt;nil\u0026gt; (Type: \u0026lt;nil\u0026gt;) ‚ö†Ô∏è Null value processing === Safe Type Conversion === Safe conversion successful: Test string === Batch Data Processing === Extracted strings: [two five] Extracted numbers: [1] 7. Interface Best Practices\r7.1 Interface Design Principles\rpackage main import \u0026#34;fmt\u0026#34; // Good interface design: Small and focused type Shape interface { Area() float64 } type Drawable interface { Draw() } type Movable interface { Move(dx, dy float64) } // Composite use type Graphic interface { Shape Drawable Movable } // Concrete implementation type Rectangle struct { Width, Height float64 X, Y float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r Rectangle) Draw() { fmt.Printf(\u0026#34;Drawing rectangle: width=%.1f, height=%.1f\\n\u0026#34;, r.Width, r.Height) } func (r *Rectangle) Move(dx, dy float64) { r.X += dx r.Y += dy fmt.Printf(\u0026#34;Rectangle moved to: (%.1f, %.1f)\\n\u0026#34;, r.X, r.Y) } // Bad interface design: Too large and cluttered type BadInterface interface { Read() string Write(string) Close() Validate() Log(string) Notify() // ... Too many methods } func main() { rect := Rectangle{Width: 10, Height: 5} // Using small interfaces var shape Shape = rect var drawable Drawable = rect var movable Movable = \u0026amp;rect fmt.Println(\u0026#34;=== Small Interface Usage ===\u0026#34;) fmt.Printf(\u0026#34;Area: %.2f\\n\u0026#34;, shape.Area()) drawable.Draw() movable.Move(5, 3) // Interface segregation principle example fmt.Println(\u0026#34;\\n=== Interface Segregation Principle ===\u0026#34;) // Only need drawing functionality drawOnly := func(d Drawable) { d.Draw() } drawOnly(rect) // Only need area calculation functionality calculateOnly := func(s Shape) { fmt.Printf(\u0026#34;Area calculation result: %.2f\\n\u0026#34;, s.Area()) } calculateOnly(rect) } Execution result:\n=== Small Interface Usage === Area: 50.00 Drawing rectangle: width=10.0, height=5.0 Rectangle moved to: (5.0, 3.0) === Interface Segregation Principle === Drawing rectangle: width=10.0, height=5.0 Area calculation result: 50.00 7.2 Interface Applications in Testing\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Define interface for testing type TimeProvider interface { Now() time.Time } type RealTimeProvider struct{} func (RealTimeProvider) Now() time.Time { return time.Now() } // Test mock time provider type MockTimeProvider struct { CurrentTime time.Time } func (m MockTimeProvider) Now() time.Time { return m.CurrentTime } // Service using time type UserService struct { timeProvider TimeProvider } func NewUserService(tp TimeProvider) *UserService { return \u0026amp;UserService{timeProvider: tp} } func (us *UserService) CreateUser(name string) string { now := us.timeProvider.Now() return fmt.Sprintf(\u0026#34;User %s created at %s\u0026#34;, name, now.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) } func (us *UserService) CheckExpiry(expiry time.Time) bool { return us.timeProvider.Now().After(expiry) } func main() { fmt.Println(\u0026#34;=== Real Time Testing ===\u0026#34;) // Using real time realService := NewUserService(RealTimeProvider{}) userMsg := realService.CreateUser(\u0026#34;Zhang San\u0026#34;) fmt.Println(userMsg) // Check expiry time futureTime := time.Now().Add(24 * time.Hour) isExpired := realService.CheckExpiry(futureTime) fmt.Printf(\u0026#34;Future time expired: %t\\n\u0026#34;, isExpired) fmt.Println(\u0026#34;\\n=== Mock Time Testing ===\u0026#34;) // Use mock time for testing mockTime := time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC) mockProvider := MockTimeProvider{CurrentTime: mockTime} mockService := NewUserService(mockProvider) userMsg2 := mockService.CreateUser(\u0026#34;Li Si\u0026#34;) fmt.Println(userMsg2) // Test expiry check pastTime := time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC) isExpired2 := mockService.CheckExpiry(pastTime) fmt.Printf(\u0026#34;Past time expired: %t\\n\u0026#34;, isExpired2) futureTime2 := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC) isExpired3 := mockService.CheckExpiry(futureTime2) fmt.Printf(\u0026#34;Future time expired: %t\\n\u0026#34;, isExpired3) } Execution result:\n=== Real Time Testing === User Zhang San created at 2024-01-15 15:30:45 Future time expired: false === Mock Time Testing === User Li Si created at 2024-01-15 10:30:00 Past time expired: true Future time expired: false 8. Summary\rInterfaces are the core mechanism for implementing abstraction and polymorphism in Go language:\nCore features:\nImplicit implementation: No need to explicitly declare implementation relationships Dynamic typing: Determine specific type at runtime Empty interface: Can store any type Composition capability: Interfaces can embed other interfaces Design principles:\nInterfaces should be small and focused, following the interface segregation principle Prefer composition over inheritance Use empty interfaces and type assertions appropriately Provide good interface design for testing Application scenarios:\nDefine behavior specifications (such as io.Reader, io.Writer) Implement dependency injection and inversion of control Support polymorphism and dynamic dispatch Facilitate unit testing and mocking Interfaces embody Go language\u0026rsquo;s \u0026ldquo;programming to interfaces\u0026rdquo; philosophy. Mastering interface usage is crucial for writing high-quality Go programs.\n","date":"2026-02-04T19:15:16+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-11/","title":"Golang Learning Journey [Part 11: Interface]"},{"content":"1. What are Methods\rMethods are functions associated with specific types in Go language. If functions are independent functional units, then methods are special functions that \u0026ldquo;belong\u0026rdquo; to a particular type. Methods give data types behavioral capabilities, which is an important feature of object-oriented programming.\n1.1 Difference Between Methods and Functions\rLet\u0026rsquo;s understand this through a simple example:\n// Regular function func add(a, b int) int { return a + b } // Method (syntax will be explained in detail later) // func (receiver) methodName(parameters) returnType { function body } Main differences:\nFunction: Exists independently, called by function name Method: Binds to a specific type, called by \u0026ldquo;type.methodName\u0026rdquo; 1.2 Why Do We Need Methods\rMain values of methods:\nEncapsulation: Organize data and methods that operate on data together Readability: student.GetName() is more intuitive than getName(student) Object-oriented: Lay foundation for subsequent interface implementation Code organization: Better organization of related functionalities 2. Basic Method Syntax\r2.1 Method Definition Syntax\rfunc (receiver) methodName(parameterList) (returnValueList) { // method body } 2.2 Two Forms of Receivers\rValue Receiver\rfunc (t MyType) MethodName(parameters) returnType { // t is a copy of MyType type // Modifying t won\u0026#39;t affect original data } Pointer Receiver\rfunc (t *MyType) MethodName(parameters) returnType { // t is a pointer to MyType type // Modifying t will affect original data } 2.3 Simple Example\rpackage main import \u0026#34;fmt\u0026#34; // Define a rectangle struct type Rectangle struct { Width float64 Height float64 } // Value receiver method: calculate area func (r Rectangle) Area() float64 { return r.Width * r.Height } // Value receiver method: calculate perimeter func (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) } // Pointer receiver method: scale rectangle func (r *Rectangle) Scale(factor float64) { r.Width *= factor r.Height *= factor } // Pointer receiver method: set dimensions func (r *Rectangle) SetDimensions(width, height float64) { r.Width = width r.Height = height } func main() { // Create rectangle instance rect := Rectangle{Width: 10, Height: 5} fmt.Printf(\u0026#34;Original rectangle: width=%.2f, height=%.2f\\n\u0026#34;, rect.Width, rect.Height) fmt.Printf(\u0026#34;Area: %.2f\\n\u0026#34;, rect.Area()) fmt.Printf(\u0026#34;Perimeter: %.2f\\n\u0026#34;, rect.Perimeter()) // Use pointer method to modify data rect.Scale(2.0) fmt.Printf(\u0026#34;\\nRectangle after scaling: width=%.2f, height=%.2f\\n\u0026#34;, rect.Width, rect.Height) fmt.Printf(\u0026#34;New area: %.2f\\n\u0026#34;, rect.Area()) rect.SetDimensions(15, 8) fmt.Printf(\u0026#34;\\nAfter resetting: width=%.2f, height=%.2f\\n\u0026#34;, rect.Width, rect.Height) fmt.Printf(\u0026#34;Final area: %.2f\\n\u0026#34;, rect.Area()) } Execution result:\nOriginal rectangle: width=10.00, height=5.00 Area: 50.00 Perimeter: 30.00 Rectangle after scaling: width=20.00, height=10.00 New area: 200.00 After resetting: width=15.00, height=8.00 Final area: 120.00 3. In-depth Understanding of Receivers\r3.1 Value Receiver vs Pointer Receiver\rpackage main import \u0026#34;fmt\u0026#34; type Counter struct { Count int } // Value receiver method func (c Counter) GetValue() int { return c.Count } // Value receiver method (won\u0026#39;t modify original value) func (c Counter) IncrementByValue() { c.Count++ // This modifies the copy fmt.Printf(\u0026#34;Value receiver internal Count: %d\\n\u0026#34;, c.Count) } // Pointer receiver method func (c *Counter) GetPointerValue() int { return c.Count } // Pointer receiver method (will modify original value) func (c *Counter) IncrementByPointer() { c.Count++ // This modifies the original value fmt.Printf(\u0026#34;Pointer receiver internal Count: %d\\n\u0026#34;, c.Count) } func main() { counter := Counter{Count: 10} fmt.Printf(\u0026#34;Initial value: %d\\n\u0026#34;, counter.Count) // Value receiver call counter.IncrementByValue() fmt.Printf(\u0026#34;After value receiver call: %d\\n\u0026#34;, counter.Count) // Pointer receiver call counter.IncrementByPointer() fmt.Printf(\u0026#34;After pointer receiver call: %d\\n\u0026#34;, counter.Count) // Verify return values fmt.Printf(\u0026#34;GetValue(): %d\\n\u0026#34;, counter.GetValue()) fmt.Printf(\u0026#34;GetPointerValue(): %d\\n\u0026#34;, counter.GetPointerValue()) } Execution result:\nInitial value: 10 Value receiver internal Count: 11 Value receiver call after: 10 Pointer receiver internal Count: 11 Pointer receiver call after: 11 GetValue(): 11 GetPointerValue(): 11 3.2 Receiver Selection Principles\rWhen to use value receivers: ‚úÖ Small data types (basic types, small structs) ‚úÖ Methods don\u0026rsquo;t need to modify receiver data ‚úÖ Concurrency safety required (value passing is safe)\nWhen to use pointer receivers: ‚úÖ Methods need to modify receiver data ‚úÖ Large data types (avoid copy overhead) ‚úÖ Consistency consideration (all methods of type use pointer receivers)\npackage main import \u0026#34;fmt\u0026#34; type SmallData struct { Value int } type LargeData struct { Values [1000]int // Large array Name string Active bool } // SmallData uses value receiver (reasonable) func (s SmallData) Double() SmallData { s.Value *= 2 return s } // LargeData uses pointer receiver (reasonable) func (l *LargeData) Activate() { l.Active = true } func main() { // Small data type small := SmallData{Value: 5} doubled := small.Double() fmt.Printf(\u0026#34;SmallData - Original: %d, Doubled: %d\\n\u0026#34;, small.Value, doubled.Value) // Large data type large := LargeData{Name: \u0026#34;Test\u0026#34;} fmt.Printf(\u0026#34;LargeData - Active before modification: %t\\n\u0026#34;, large.Active) large.Activate() fmt.Printf(\u0026#34;LargeData - Active after modification: %t\\n\u0026#34;, large.Active) } Execution result:\nSmallData - Original: 5, Doubled: 10 LargeData - Active before modification: false LargeData - Active after modification: true 4. Receivers of Different Types\r4.1 Methods for Basic Types\rpackage main import \u0026#34;fmt\u0026#34; // Create alias for int type type MyInt int // Add methods to custom type func (mi MyInt) Double() MyInt { return mi * 2 } func (mi MyInt) IsEven() bool { return mi%2 == 0 } func (mi *MyInt) Increment() { *mi++ } // Create methods for built-in types (need type aliases) type Celsius float64 type Fahrenheit float64 func (c Celsius) ToFahrenheit() Fahrenheit { return Fahrenheit(c*9/5 + 32) } func (f Fahrenheit) ToCelsius() Celsius { return Celsius((f - 32) * 5 / 9) } func main() { // Custom int type num := MyInt(10) fmt.Printf(\u0026#34;Original value: %d\\n\u0026#34;, num) fmt.Printf(\u0026#34;Doubled: %d\\n\u0026#34;, num.Double()) fmt.Printf(\u0026#34;Is even: %t\\n\u0026#34;, num.IsEven()) num.Increment() fmt.Printf(\u0026#34;After increment: %d\\n\u0026#34;, num) // Temperature conversion tempC := Celsius(25) tempF := tempC.ToFahrenheit() fmt.Printf(\u0026#34;\\n%d¬∞C = %.1f¬∞F\\n\u0026#34;, int(tempC), float64(tempF)) backToC := tempF.ToCelsius() fmt.Printf(\u0026#34;%.1f¬∞F = %d¬∞C\\n\u0026#34;, float64(tempF), int(backToC)) } Execution result:\nOriginal value: 10 Doubled: 20 Is even: true After increment: 11 25¬∞C = 77.0¬∞F 77.0¬∞F = 25¬∞C 4.2 Struct Methods\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Point struct { X, Y float64 } type Circle struct { Center Point Radius float64 } // Point methods func (p Point) Distance(other Point) float64 { dx := p.X - other.X dy := p.Y - other.Y return math.Sqrt(dx*dx + dy*dy) } func (p Point) Move(dx, dy float64) Point { return Point{X: p.X + dx, Y: p.Y + dy} } // Circle methods func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius } func (c Circle) Circumference() float64 { return 2 * math.Pi * c.Radius } func (c *Circle) Scale(factor float64) { c.Radius *= factor } func main() { // Point operations p1 := Point{X: 0, Y: 0} p2 := Point{X: 3, Y: 4} distance := p1.Distance(p2) fmt.Printf(\u0026#34;Distance between points: %.2f\\n\u0026#34;, distance) p3 := p1.Move(1, 1) fmt.Printf(\u0026#34;Point after moving: (%f, %f)\\n\u0026#34;, p3.X, p3.Y) // Circle operations circle := Circle{ Center: Point{X: 0, Y: 0}, Radius: 5, } fmt.Printf(\u0026#34;\\nCircle radius: %.2f\\n\u0026#34;, circle.Radius) fmt.Printf(\u0026#34;Circle area: %.2f\\n\u0026#34;, circle.Area()) fmt.Printf(\u0026#34;Circle circumference: %.2f\\n\u0026#34;, circle.Circumference()) circle.Scale(2) fmt.Printf(\u0026#34;\\nRadius after scaling: %.2f\\n\u0026#34;, circle.Radius) fmt.Printf(\u0026#34;Area after scaling: %.2f\\n\u0026#34;, circle.Area()) } Execution result:\nDistance between points: 5.00 Point after moving: (1.000000, 1.000000) Circle radius: 5.00 Circle area: 78.54 Circle circumference: 31.42 Radius after scaling: 10.00 Area after scaling: 314.16 4.3 Slice and Map Methods\rpackage main import \u0026#34;fmt\u0026#34; // Create alias for slice type type IntSlice []int // Create alias for map type type StringMap map[string]string // IntSlice methods func (is IntSlice) Sum() int { sum := 0 for _, v := range is { sum += v } return sum } func (is IntSlice) Average() float64 { if len(is) == 0 { return 0 } return float64(is.Sum()) / float64(len(is)) } func (is *IntSlice) Append(value int) { *is = append(*is, value) } // StringMap methods func (sm StringMap) Get(key string) (string, bool) { value, exists := sm[key] return value, exists } func (sm StringMap) Set(key, value string) { sm[key] = value } func (sm StringMap) Keys() []string { keys := make([]string, 0, len(sm)) for k := range sm { keys = append(keys, k) } return keys } func main() { // Slice methods numbers := IntSlice{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;Number slice: %v\\n\u0026#34;, numbers) fmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, numbers.Sum()) fmt.Printf(\u0026#34;Average: %.2f\\n\u0026#34;, numbers.Average()) numbers.Append(6) numbers.Append(7) fmt.Printf(\u0026#34;After adding elements: %v\\n\u0026#34;, numbers) fmt.Printf(\u0026#34;New sum: %d\\n\u0026#34;, numbers.Sum()) // Map methods studentGrades := StringMap{ \u0026#34;Zhang San\u0026#34;: \u0026#34;85\u0026#34;, \u0026#34;Li Si\u0026#34;: \u0026#34;92\u0026#34;, \u0026#34;Wang Wu\u0026#34;: \u0026#34;78\u0026#34;, } fmt.Printf(\u0026#34;\\nStudent grades: %v\\n\u0026#34;, studentGrades) // Get value if grade, exists := studentGrades.Get(\u0026#34;Li Si\u0026#34;); exists { fmt.Printf(\u0026#34;Li Si\u0026#39;s grade: %s\\n\u0026#34;, grade) } // Set new value studentGrades.Set(\u0026#34;Zhao Liu\u0026#34;, \u0026#34;88\u0026#34;) fmt.Printf(\u0026#34;After adding Zhao Liu: %v\\n\u0026#34;, studentGrades) // Get all keys keys := studentGrades.Keys() fmt.Printf(\u0026#34;All students: %v\\n\u0026#34;, keys) } Execution result:\nNumber slice: [1 2 3 4 5] Sum: 15 Average: 3.00 After adding elements: [1 2 3 4 5 6 7] New sum: 28 Student grades: map[Zhang San:85 Li Si:92 Wang Wu:78] Li Si\u0026#39;s grade: 92 After adding Zhao Liu: map[Zhang San:85 Li Si:92 Wang Wu:78 Zhao Liu:88] All students: [Zhang San Li Si Wang Wu Zhao Liu] 5. Relationship Between Methods and Interfaces\r5.1 Concept of Method Sets\rpackage main import \u0026#34;fmt\u0026#34; type Shape interface { Area() float64 Perimeter() float64 } type Rectangle struct { Width float64 Height float64 } type Circle struct { Radius float64 } // Rectangle implements Shape interface func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) } // Circle implements Shape interface func (c Circle) Area() float64 { return 3.14159 * c.Radius * c.Radius } func (c Circle) Perimeter() float64 { return 2 * 3.14159 * c.Radius } // Function using interface func PrintShapeInfo(s Shape) { fmt.Printf(\u0026#34;Area: %.2f\\n\u0026#34;, s.Area()) fmt.Printf(\u0026#34;Perimeter: %.2f\\n\u0026#34;, s.Perimeter()) } func main() { rect := Rectangle{Width: 10, Height: 5} circle := Circle{Radius: 3} fmt.Println(\u0026#34;=== Rectangle ===\u0026#34;) PrintShapeInfo(rect) fmt.Println(\u0026#34;\\n=== Circle ===\u0026#34;) PrintShapeInfo(circle) // Interface slice shapes := []Shape{rect, circle} fmt.Println(\u0026#34;\\n=== Batch processing ===\u0026#34;) for i, shape := range shapes { fmt.Printf(\u0026#34;Shape %d:\\n\u0026#34;, i+1) PrintShapeInfo(shape) fmt.Println() } } Execution result:\n=== Rectangle === Area: 50.00 Perimeter: 30.00 === Circle === Area: 28.27 Perimeter: 18.85 === Batch processing === Shape 1: Area: 50.00 Perimeter: 30.00 Shape 2: Area: 28.27 Perimeter: 18.85 6. Advanced Method Usage\r6.1 Method Chaining\rpackage main import \u0026#34;fmt\u0026#34; type Calculator struct { Result float64 } func (c Calculator) Add(x float64) Calculator { c.Result += x return c } func (c Calculator) Subtract(x float64) Calculator { c.Result -= x return c } func (c Calculator) Multiply(x float64) Calculator { c.Result *= x return c } func (c Calculator) Divide(x float64) Calculator { if x != 0 { c.Result /= x } return c } func (c Calculator) GetValue() float64 { return c.Result } func main() { calc := Calculator{Result: 10} result := calc. Add(5). Multiply(2). Subtract(3). Divide(2). GetValue() fmt.Printf(\u0026#34;Calculation result: %.2f\\n\u0026#34;, result) // Step-by-step demonstration calc2 := Calculator{Result: 10} fmt.Printf(\u0026#34;Initial value: %.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Add(5) fmt.Printf(\u0026#34;After adding 5: %.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Multiply(2) fmt.Printf(\u0026#34;After multiplying by 2: %.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Subtract(3) fmt.Printf(\u0026#34;After subtracting 3: %.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Divide(2) fmt.Printf(\u0026#34;After dividing by 2: %.2f\\n\u0026#34;, calc2.GetValue()) } Execution result:\nCalculation result: 13.50 Initial value: 10.00 After adding 5: 15.00 After multiplying by 2: 30.00 After subtracting 3: 27.00 After dividing by 2: 13.50 6.2 Method Promotion in Embedded Types\rpackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func (p Person) GetName() string { return p.Name } func (p Person) GetAge() int { return p.Age } type Student struct { Person // Embed Person School string Grade int } func (s Student) GetSchool() string { return s.School } type Teacher struct { Person // Embed Person Subject string Salary float64 } func (t Teacher) GetSubject() string { return t.Subject } func main() { student := Student{ Person: Person{Name: \u0026#34;Xiao Ming\u0026#34;, Age: 18}, School: \u0026#34;No.1 Middle School\u0026#34;, Grade: 12, } teacher := Teacher{ Person: Person{Name: \u0026#34;Teacher Wang\u0026#34;, Age: 35}, Subject: \u0026#34;Mathematics\u0026#34;, Salary: 8000, } // Can directly call embedded type methods fmt.Printf(\u0026#34;Student name: %s\\n\u0026#34;, student.GetName()) // Promoted method fmt.Printf(\u0026#34;Student age: %d\\n\u0026#34;, student.GetAge()) // Promoted method fmt.Printf(\u0026#34;School: %s\\n\u0026#34;, student.GetSchool()) fmt.Printf(\u0026#34;Grade: %d\\n\u0026#34;, student.Grade) fmt.Printf(\u0026#34;\\nTeacher name: %s\\n\u0026#34;, teacher.GetName()) // Promoted method fmt.Printf(\u0026#34;Teacher age: %d\\n\u0026#34;, teacher.GetAge()) // Promoted method fmt.Printf(\u0026#34;Subject: %s\\n\u0026#34;, teacher.GetSubject()) fmt.Printf(\u0026#34;Salary: %.2f\\n\u0026#34;, teacher.Salary) // Verify type relationship fmt.Printf(\u0026#34;\\nStudent is also Person type: %t\\n\u0026#34;, isPerson(student)) fmt.Printf(\u0026#34;Teacher is also Person type: %t\\n\u0026#34;, isPerson(teacher)) } func isPerson(p Person) bool { return true } Execution result:\nStudent name: Xiao Ming Student age: 18 School: No.1 Middle School Grade: 12 Teacher name: Teacher Wang Teacher age: 35 Subject: Mathematics Salary: 8000.00 Student is also Person type: true Teacher is also Person type: true 7. Method Considerations\r7.1 Method Name Conflicts\rpackage main import \u0026#34;fmt\u0026#34; type Base struct { Name string } func (b Base) GetName() string { return b.Name } type Derived struct { Base Name string // Same name as Name in Base } func (d Derived) GetName() string { // Explicitly specify which GetName to call return \u0026#34;Derived: \u0026#34; + d.Name + \u0026#34;, Base: \u0026#34; + d.Base.GetName() } func main() { derived := Derived{ Base: Base{Name: \u0026#34;BaseName\u0026#34;}, Name: \u0026#34;DerivedName\u0026#34;, } fmt.Printf(\u0026#34;Calling derived class GetName: %s\\n\u0026#34;, derived.GetName()) fmt.Printf(\u0026#34;Direct access to Name: %s\\n\u0026#34;, derived.Name) fmt.Printf(\u0026#34;Access Base.Name: %s\\n\u0026#34;, derived.Base.Name) } Execution result:\nCalling derived class GetName: Derived: DerivedName, Base: BaseName Direct access to Name: DerivedName Access Base.Name: BaseName 7.2 Calling Methods on Nil Pointers\rpackage main import \u0026#34;fmt\u0026#34; type Data struct { Value int } func (d *Data) GetValue() int { if d == nil { return 0 // Safety check } return d.Value } func (d *Data) SetValue(v int) { if d != nil { // Safety check d.Value = v } } func main() { var ptr *Data = nil // Calling method on nil pointer (safe) fmt.Printf(\u0026#34;Nil pointer GetValue: %d\\n\u0026#34;, ptr.GetValue()) // Calling modification method on nil pointer (safe) ptr.SetValue(100) // No problem because of safety check // Create actual object actual := \u0026amp;Data{Value: 42} fmt.Printf(\u0026#34;Actual object GetValue: %d\\n\u0026#34;, actual.GetValue()) actual.SetValue(99) fmt.Printf(\u0026#34;GetValue after modification: %d\\n\u0026#34;, actual.GetValue()) } Execution result:\nNil pointer GetValue: 0 Actual object GetValue: 42 GetValue after modification: 99 8. Summary\rMethods are the core mechanism for implementing object-oriented programming in Go language:\nCore concepts:\nMethods are functions bound to specific types Associate methods with types through receivers Value receivers and pointer receivers have different behavioral characteristics Usage principles:\nValue receivers: Suitable for not modifying data, small data types Pointer receivers: Suitable for needing to modify data, large data types Maintain consistency in receiver types for all methods of a type Important features:\nMethod promotion: Embedded type methods can be called directly Interface implementation: Methods are the foundation for implementing interfaces Chaining: Returning receiver type supports method chaining Mastering method usage is key to understanding Go language\u0026rsquo;s object-oriented features and lays a solid foundation for subsequent interface learning.\n","date":"2026-02-04T18:15:16+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-10/","title":"Golang Learning Journey [Part 10: Methods and Receivers]"},{"content":"1. What is a Struct\rA struct is an important composite data type in Go language that can combine multiple data of different types together to form a meaningful whole. A struct can be understood as an abstract representation of things in the real world.\n1.1 Basic Concepts of Structs\rImagine we want to describe a student\u0026rsquo;s information:\nName: string type Age: integer type Score: floating-point type Enrolled status: boolean type Without structs, we need to define multiple variables separately:\nvar name string = \u0026#34;Zhang San\u0026#34; var age int = 18 var score float64 = 95.5 var isEnrolled bool = true This is very inconvenient to manage and use. Structs can organize these related data together:\ntype Student struct { Name string Age int Score float64 IsEnrolled bool } 1.2 Why Do We Need Structs\rMain advantages of structs:\nData Aggregation: Organize related data together Code Clarity: Improve code readability and maintainability Type Safety: Create specialized data types Object-Oriented: Lay foundation for subsequent methods and interfaces 2. Struct Definition and Declaration\r2.1 Basic Definition Syntax\r// Basic syntax for struct definition type struct_name struct { field_name1 data_type1 field_name2 data_type2 field_name3 data_type3 // ... more fields } 2.2 Struct Definition Examples\rpackage main import \u0026#34;fmt\u0026#34; // Define student struct type Student struct { Name string // Name Age int // Age Score float64 // Score IsEnrolled bool // Enrollment status } // Define book struct type Book struct { Title string // Title Author string // Author Price float64 // Price Pages int // Number of pages ISBN string // ISBN number } // Define coordinate point struct type Point struct { X int // X coordinate Y int // Y coordinate } func main() { fmt.Println(\u0026#34;Struct definition completed\u0026#34;) } 2.3 Anonymous Structs\rpackage main import \u0026#34;fmt\u0026#34; func main() { // Anonymous struct definition and usage person := struct { Name string Age int }{ Name: \u0026#34;Li Si\u0026#34;, Age: 25, } fmt.Printf(\u0026#34;Anonymous struct: %+v\\n\u0026#34;, person) fmt.Printf(\u0026#34;Name: %s, Age: %d\\n\u0026#34;, person.Name, person.Age) // Anonymous struct slice people := []struct { Name string City string }{ {\u0026#34;Wang Wu\u0026#34;, \u0026#34;Beijing\u0026#34;}, {\u0026#34;Zhao Liu\u0026#34;, \u0026#34;Shanghai\u0026#34;}, {\u0026#34;Sun Qi\u0026#34;, \u0026#34;Guangzhou\u0026#34;}, } fmt.Println(\u0026#34;People list:\u0026#34;) for _, p := range people { fmt.Printf(\u0026#34;Name: %s, City: %s\\n\u0026#34;, p.Name, p.City) } } Execution result:\nAnonymous struct: {Name:Li Si Age:25} Name: Li Si, Age: 25 People list: Name: Wang Wu, City: Beijing Name: Zhao Liu, City: Shanghai Name: Sun Qi, City: Guangzhou 3. Struct Instantiation\r3.1 Various Creation Methods\rpackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int Score float64 } func main() { // Method 1: Complete field initialization student1 := Student{ Name: \u0026#34;Zhang San\u0026#34;, Age: 18, Score: 95.5, } // Method 2: Initialize by field order (must specify all fields) student2 := Student{\u0026#34;Li Si\u0026#34;, 19, 88.0} // Method 3: Partial field initialization (must specify field names) student3 := Student{ Name: \u0026#34;Wang Wu\u0026#34;, Age: 20, // Score uses default value 0.0 } // Method 4: Use new function to create (all fields have zero values) student4 := new(Student) student4.Name = \u0026#34;Zhao Liu\u0026#34; student4.Age = 21 student4.Score = 92.5 // Method 5: Use \u0026amp; to create and initialize student5 := \u0026amp;Student{ Name: \u0026#34;Sun Qi\u0026#34;, Age: 17, Score: 87.5, } fmt.Printf(\u0026#34;Student 1: %+v\\n\u0026#34;, student1) fmt.Printf(\u0026#34;Student 2: %+v\\n\u0026#34;, student2) fmt.Printf(\u0026#34;Student 3: %+v\\n\u0026#34;, student3) fmt.Printf(\u0026#34;Student 4: %+v\\n\u0026#34;, *student4) fmt.Printf(\u0026#34;Student 5: %+v\\n\u0026#34;, *student5) } Execution result:\nStudent 1: {Name:Zhang San Age:18 Score:95.5} Student 2: {Name:Li Si Age:19 Score:88} Student 3: {Name:Wang Wu Age:20 Score:0} Student 4: {Name:Zhao Liu Age:21 Score:92.5} Student 5: {Name:Sun Qi Age:17 Score:87.5} 3.2 Struct Zero Values\rpackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int Height float64 IsActive bool Scores []int Info map[string]string } func main() { // Declare struct variable without initialization var person Person fmt.Printf(\u0026#34;Struct zero value: %+v\\n\u0026#34;, person) fmt.Printf(\u0026#34;String zero value: %q\\n\u0026#34;, person.Name) fmt.Printf(\u0026#34;Integer zero value: %d\\n\u0026#34;, person.Age) fmt.Printf(\u0026#34;Float zero value: %f\\n\u0026#34;, person.Height) fmt.Printf(\u0026#34;Boolean zero value: %t\\n\u0026#34;, person.IsActive) fmt.Printf(\u0026#34;Slice zero value: %v, is nil: %t\\n\u0026#34;, person.Scores, person.Scores == nil) fmt.Printf(\u0026#34;Map zero value: %v, is nil: %t\\n\u0026#34;, person.Info, person.Info == nil) } Execution result:\nStruct zero value: {Name: Age:0 Height:0 IsActive:false Scores:[] Info:map[]} String zero value: \u0026#34;\u0026#34; Integer zero value: 0 Float zero value: 0.000000 Boolean zero value: false Slice zero value: [], is nil: true Map zero value: map[], is nil: true 4. Struct Field Access and Modification\r4.1 Field Access\rpackage main import \u0026#34;fmt\u0026#34; type Employee struct { Name string Age int Salary float64 Department string } func main() { // Create employee instance emp := Employee{ Name: \u0026#34;Zhang San\u0026#34;, Age: 28, Salary: 15000.0, Department: \u0026#34;Technology Department\u0026#34;, } // Access fields fmt.Printf(\u0026#34;Employee name: %s\\n\u0026#34;, emp.Name) fmt.Printf(\u0026#34;Employee age: %d\\n\u0026#34;, emp.Age) fmt.Printf(\u0026#34;Employee salary: %.2f\\n\u0026#34;, emp.Salary) fmt.Printf(\u0026#34;Department: %s\\n\u0026#34;, emp.Department) // Modify field values emp.Age = 29 emp.Salary = 16000.0 emp.Department = \u0026#34;R\u0026amp;D Department\u0026#34; fmt.Printf(\u0026#34;\\nInformation after modification:\\n\u0026#34;) fmt.Printf(\u0026#34;Employee name: %s\\n\u0026#34;, emp.Name) fmt.Printf(\u0026#34;Employee age: %d\\n\u0026#34;, emp.Age) fmt.Printf(\u0026#34;Employee salary: %.2f\\n\u0026#34;, emp.Salary) fmt.Printf(\u0026#34;Department: %s\\n\u0026#34;, emp.Department) } Execution result:\nEmployee name: Zhang San Employee age: 28 Employee salary: 15000.00 Department: Technology Department Information after modification: Employee name: Zhang San Employee age: 29 Employee salary: 16000.00 Department: R\u0026amp;D Department 4.2 Pointer Access to Struct Fields\rpackage main import \u0026#34;fmt\u0026#34; type Product struct { Name string Price float64 Stock int } func main() { // Ordinary struct variable product1 := Product{Name: \u0026#34;Phone\u0026#34;, Price: 3999.0, Stock: 100} // Struct pointer product2 := \u0026amp;Product{Name: \u0026#34;Computer\u0026#34;, Price: 8999.0, Stock: 50} // Access method 1: Direct access through variable name fmt.Printf(\u0026#34;Product 1 - Name: %s, Price: %.2f, Stock: %d\\n\u0026#34;, product1.Name, product1.Price, product1.Stock) // Access method 2: Access through pointer (Go automatically dereferences) fmt.Printf(\u0026#34;Product 2 - Name: %s, Price: %.2f, Stock: %d\\n\u0026#34;, product2.Name, product2.Price, product2.Stock) // Access method 3: Explicit dereferencing fmt.Printf(\u0026#34;Product 2 explicit dereference - Name: %s, Price: %.2f, Stock: %d\\n\u0026#34;, (*product2).Name, (*product2).Price, (*product2).Stock) // Modify values product1.Price = 3599.0 product2.Stock = 75 // Equivalent to (*product2).Stock = 75 fmt.Printf(\u0026#34;\\nAfter modification:\\n\u0026#34;) fmt.Printf(\u0026#34;Product 1 price: %.2f\\n\u0026#34;, product1.Price) fmt.Printf(\u0026#34;Product 2 stock: %d\\n\u0026#34;, product2.Stock) } Execution result:\nProduct 1 - Name: Phone, Price: 3999.00, Stock: 100 Product 2 - Name: Computer, Price: 8999.00, Stock: 50 Product 2 explicit dereference - Name: Computer, Price: 8999.00, Stock: 50 After modification: Product 1 price: 3599.00 Product 2 stock: 75 5. Struct Nesting\r5.1 Basic Nesting\rpackage main import \u0026#34;fmt\u0026#34; // Address struct type Address struct { Province string City string Street string ZipCode string } // Company struct type Company struct { Name string Address Address // Nested Address struct } // Employee struct type Employee struct { Name string Age int Company Company // Nested Company struct } func main() { // Create nested struct employee := Employee{ Name: \u0026#34;Zhang San\u0026#34;, Age: 30, Company: Company{ Name: \u0026#34;Technology Co., Ltd.\u0026#34;, Address: Address{ Province: \u0026#34;Beijing\u0026#34;, City: \u0026#34;Beijing\u0026#34;, Street: \u0026#34;Zhongguancun Street 1\u0026#34;, ZipCode: \u0026#34;100080\u0026#34;, }, }, } // Access nested fields fmt.Printf(\u0026#34;Employee name: %s\\n\u0026#34;, employee.Name) fmt.Printf(\u0026#34;Employee age: %d\\n\u0026#34;, employee.Age) fmt.Printf(\u0026#34;Company name: %s\\n\u0026#34;, employee.Company.Name) fmt.Printf(\u0026#34;Company province: %s\\n\u0026#34;, employee.Company.Address.Province) fmt.Printf(\u0026#34;Company city: %s\\n\u0026#34;, employee.Company.Address.City) fmt.Printf(\u0026#34;Company street: %s\\n\u0026#34;, employee.Company.Address.Street) fmt.Printf(\u0026#34;Zip code: %s\\n\u0026#34;, employee.Company.Address.ZipCode) // Modify nested fields employee.Company.Address.Street = \u0026#34;Zhongguancun Street 2\u0026#34; fmt.Printf(\u0026#34;\\nStreet after modification: %s\\n\u0026#34;, employee.Company.Address.Street) } Execution result:\nEmployee name: Zhang San Employee age: 30 Company name: Technology Co., Ltd. Company province: Beijing Company city: Beijing Company street: Zhongguancun Street 1 Zip code: 100080 Street after modification: Zhongguancun Street 2 5.2 Anonymous Nesting (Anonymous Fields)\rpackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } type Student struct { Person // Anonymous nested Person struct School string Grade int } type Teacher struct { Person // Anonymous nested Person struct Subject string Salary float64 } func main() { // Create student student := Student{ Person: Person{Name: \u0026#34;Xiao Ming\u0026#34;, Age: 18}, School: \u0026#34;No.1 Middle School\u0026#34;, Grade: 12, } // Create teacher teacher := Teacher{ Person: Person{Name: \u0026#34;Teacher Wang\u0026#34;, Age: 35}, Subject: \u0026#34;Mathematics\u0026#34;, Salary: 8000.0, } // Access promoted fields (can directly access nested struct fields) fmt.Printf(\u0026#34;Student name: %s\\n\u0026#34;, student.Name) // Equivalent to student.Person.Name fmt.Printf(\u0026#34;Student age: %d\\n\u0026#34;, student.Age) // Equivalent to student.Person.Age fmt.Printf(\u0026#34;School: %s\\n\u0026#34;, student.School) fmt.Printf(\u0026#34;Grade: %d\\n\u0026#34;, student.Grade) fmt.Printf(\u0026#34;\\nTeacher name: %s\\n\u0026#34;, teacher.Name) // Equivalent to teacher.Person.Name fmt.Printf(\u0026#34;Teacher age: %d\\n\u0026#34;, teacher.Age) // Equivalent to teacher.Person.Age fmt.Printf(\u0026#34;Subject: %s\\n\u0026#34;, teacher.Subject) fmt.Printf(\u0026#34;Salary: %.2f\\n\u0026#34;, teacher.Salary) // Modify promoted fields student.Age = 19 teacher.Name = \u0026#34;Teacher Li\u0026#34; fmt.Printf(\u0026#34;\\nStudent age after modification: %d\\n\u0026#34;, student.Age) fmt.Printf(\u0026#34;Teacher name after modification: %s\\n\u0026#34;, teacher.Name) } Execution result:\nStudent name: Xiao Ming Student age: 18 School: No.1 Middle School Grade: 12 Teacher name: Teacher Wang Teacher age: 35 Subject: Mathematics Salary: 8000.00 Student age after modification: 19 Teacher name after modification: Teacher Li 6. Struct Tags\r6.1 Basic Tag Usage\rpackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { ID int `json:\u0026#34;id\u0026#34;` UserName string `json:\u0026#34;username\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` Password string `json:\u0026#34;-\u0026#34;` // - means ignore this field Active bool `json:\u0026#34;active,omitempty\u0026#34;` // omitempty means ignore when value is empty } func main() { user := User{ ID: 1, UserName: \u0026#34;zhangsan\u0026#34;, Email: \u0026#34;zhangsan@example.com\u0026#34;, Password: \u0026#34;123456\u0026#34;, Active: true, } // Serialize to JSON jsonData, err := json.Marshal(user) if err != nil { fmt.Printf(\u0026#34;Serialization error: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;JSON data: %s\\n\u0026#34;, jsonData) // Deserialize var newUser User jsonStr := `{\u0026#34;id\u0026#34;:2,\u0026#34;username\u0026#34;:\u0026#34;lisi\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;lisi@example.com\u0026#34;,\u0026#34;active\u0026#34;:false}` err = json.Unmarshal([]byte(jsonStr), \u0026amp;newUser) if err != nil { fmt.Printf(\u0026#34;Deserialization error: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Deserialization result: %+v\\n\u0026#34;, newUser) } Execution result:\nJSON data: {\u0026#34;id\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;zhangsan\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;zhangsan@example.com\u0026#34;,\u0026#34;active\u0026#34;:true} Deserialization result: {ID:2 UserName:lisi Email:lisi@example.com Password: Active:false} 6.2 Multiple Tags Example\rpackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Product struct { ID int `json:\u0026#34;id\u0026#34; db:\u0026#34;product_id\u0026#34;` Name string `json:\u0026#34;name\u0026#34; db:\u0026#34;product_name\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34; db:\u0026#34;price\u0026#34;` Description string `json:\u0026#34;description,omitempty\u0026#34; db:\u0026#34;description\u0026#34;` Category string `json:\u0026#34;category\u0026#34; db:\u0026#34;category\u0026#34;` } func main() { products := []Product{ { ID: 1, Name: \u0026#34;iPhone 15\u0026#34;, Price: 5999.0, Description: \u0026#34;Latest Apple phone\u0026#34;, Category: \u0026#34;Electronics\u0026#34;, }, { ID: 2, Name: \u0026#34;MacBook Pro\u0026#34;, Price: 12999.0, // Description is empty, will be ignored by omitempty Category: \u0026#34;Computers\u0026#34;, }, } // JSON serialization jsonData, _ := json.MarshalIndent(products, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;JSON formatted data:\\n%s\\n\u0026#34;, jsonData) } Execution result:\nJSON formatted data: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;iPhone 15\u0026#34;, \u0026#34;price\u0026#34;: 5999, \u0026#34;description\u0026#34;: \u0026#34;Latest Apple phone\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;Electronics\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;MacBook Pro\u0026#34;, \u0026#34;price\u0026#34;: 12999, \u0026#34;category\u0026#34;: \u0026#34;Computers\u0026#34; } ] 7. Struct Comparison\r7.1 Struct Equality Comparison\rpackage main import \u0026#34;fmt\u0026#34; type Point struct { X, Y int } type Person struct { Name string Age int Data []int // Slice field } func main() { // Comparable structs p1 := Point{1, 2} p2 := Point{1, 2} p3 := Point{3, 4} fmt.Printf(\u0026#34;p1 == p2: %t\\n\u0026#34;, p1 == p2) fmt.Printf(\u0026#34;p1 == p3: %t\\n\u0026#34;, p1 == p3) // Structs containing non-comparable fields person1 := Person{Name: \u0026#34;Zhang San\u0026#34;, Age: 20, Data: []int{1, 2, 3}} person2 := Person{Name: \u0026#34;Zhang San\u0026#34;, Age: 20, Data: []int{1, 2, 3}} // The following code would cause compilation error because it contains slice fields // fmt.Printf(\u0026#34;person1 == person2: %t\\n\u0026#34;, person1 == person2) // Manual comparison equal := person1.Name == person2.Name \u0026amp;\u0026amp; person1.Age == person2.Age \u0026amp;\u0026amp; len(person1.Data) == len(person2.Data) if equal { for i := range person1.Data { if person1.Data[i] != person2.Data[i] { equal = false break } } } fmt.Printf(\u0026#34;Manual comparison result: %t\\n\u0026#34;, equal) } Execution result:\np1 == p2: true p1 == p3: false Manual comparison result: true 8. Struct Factory Functions\r8.1 Constructor Functions for Creating Structs\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type User struct { ID int Username string Email string CreatedAt time.Time IsActive bool } // Constructor 1: Create ordinary user func NewUser(username, email string) *User { return \u0026amp;User{ Username: username, Email: email, CreatedAt: time.Now(), IsActive: true, } } // Constructor 2: Create admin user func NewAdminUser(username, email string) *User { user := NewUser(username, email) user.ID = -1 // Set admin ID to special value return user } // Constructor 3: Constructor with validation func NewUserWithValidation(username, email string) (*User, error) { if len(username) \u0026lt; 3 { return nil, fmt.Errorf(\u0026#34;username length cannot be less than 3 characters\u0026#34;) } if len(email) \u0026lt; 5 || !contains(email, \u0026#34;@\u0026#34;) { return nil, fmt.Errorf(\u0026#34;incorrect email format\u0026#34;) } return \u0026amp;User{ Username: username, Email: email, CreatedAt: time.Now(), IsActive: true, }, nil } // Helper function func contains(s, substr string) bool { for i := 0; i \u0026lt;= len(s)-len(substr); i++ { if s[i:i+len(substr)] == substr { return true } } return false } func main() { // Create users using constructors user1 := NewUser(\u0026#34;zhangsan\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;) fmt.Printf(\u0026#34;Ordinary user: %+v\\n\u0026#34;, *user1) admin := NewAdminUser(\u0026#34;admin\u0026#34;, \u0026#34;admin@example.com\u0026#34;) fmt.Printf(\u0026#34;Admin user: %+v\\n\u0026#34;, *admin) // Constructor with validation user2, err := NewUserWithValidation(\u0026#34;li\u0026#34;, \u0026#34;invalid-email\u0026#34;) if err != nil { fmt.Printf(\u0026#34;User creation failed: %v\\n\u0026#34;, err) } user3, err := NewUserWithValidation(\u0026#34;lisi\u0026#34;, \u0026#34;lisi@example.com\u0026#34;) if err != nil { fmt.Printf(\u0026#34;User creation failed: %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;Validated user: %+v\\n\u0026#34;, *user3) } } Execution result:\nOrdinary user: {ID:0 Username:zhangsan Email:zhangsan@example.com CreatedAt:2024-01-15 10:30:45.123456789 +0800 CST IsActive:true} Admin user: {ID:-1 Username:admin Email:admin@example.com CreatedAt:2024-01-15 10:30:45.123456789 +0800 CST IsActive:true} User creation failed: username length cannot be less than 3 characters Validated user: {ID:0 Username:lisi Email:lisi@example.com CreatedAt:2024-01-15 10:30:45.123456789 +0800 CST IsActive:true} 9. Structs and Functions\r9.1 Structs as Function Parameters\rpackage main import \u0026#34;fmt\u0026#34; type Rectangle struct { Width float64 Height float64 } // Pass by value func calculateArea(rect Rectangle) float64 { return rect.Width * rect.Height } // Pass by pointer (can modify original struct) func scaleRectangle(rect *Rectangle, factor float64) { rect.Width *= factor rect.Height *= factor } // Return struct func createSquare(side float64) Rectangle { return Rectangle{Width: side, Height: side} } func main() { // Create rectangle rect := Rectangle{Width: 10, Height: 5} fmt.Printf(\u0026#34;Original rectangle: %+v\\n\u0026#34;, rect) // Calculate area by value passing area := calculateArea(rect) fmt.Printf(\u0026#34;Area: %.2f\\n\u0026#34;, area) fmt.Printf(\u0026#34;Rectangle after calculation: %+v\\n\u0026#34;, rect) // Original rectangle unchanged // Scale by pointer passing scaleRectangle(\u0026amp;rect, 2.0) fmt.Printf(\u0026#34;Rectangle after scaling: %+v\\n\u0026#34;, rect) fmt.Printf(\u0026#34;Area after scaling: %.2f\\n\u0026#34;, calculateArea(rect)) // Create square square := createSquare(8) fmt.Printf(\u0026#34;Created square: %+v\\n\u0026#34;, square) fmt.Printf(\u0026#34;Square area: %.2f\\n\u0026#34;, calculateArea(square)) } Execution result:\nOriginal rectangle: {Width:10 Height:5} Area: 50.00 Rectangle after calculation: {Width:10 Height:5} Rectangle after scaling: {Width:20 Height:10} Area after scaling: 200.00 Created square: {Width:8 Height:8} Square area: 64.00 10. Summary\rStructs are important tools in Go language for organizing and managing related data:\nKey Features:\nCombine multiple related data fields together Can nest other structs Support tags for operations like serialization Constructor functions can be defined to standardize creation process Usage Scenarios:\nRepresent real-world entities (users, products, orders, etc.) Organize configuration information Pass complex data as function parameters Foundation for object-oriented programming implementation Best Practices:\nUse constructor functions to create struct instances Add tags to important structs Reasonably use pointer passing to avoid unnecessary copying Pay attention to struct comparison issues with non-comparable fields Structs are the foundation of object-oriented programming in Go language. Mastering struct usage is very important for subsequent learning of methods and interfaces.\n","date":"2026-02-04T17:15:16+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-09/","title":"Golang Learning Journey [Part 9: Struct]"},{"content":"1. What is a Pointer\rA pointer is an important concept in programming. It acts like an \u0026ldquo;address label\u0026rdquo; that stores the specific location information of a variable in memory. Through pointers, we can directly access and manipulate data in memory.\n1.1 Basic Concepts of Pointers\rImagine a real-life scenario:\nYour home has a specific address (for example: xxx Street, Chaoyang District, Beijing) Others can find your home just by knowing this address A pointer is equivalent to this \u0026ldquo;address\u0026rdquo; - it stores the memory location of a variable In computers:\nEach variable is allocated a piece of memory space to store data This memory space has a unique address Pointer variables store this memory address 1.2 Why Do We Need Pointers\rPointers have several important roles:\nMemory Saving: When passing large data structures, passing pointers is more efficient than passing the entire data Direct Modification: Original data can be modified directly within functions Dynamic Memory Management: Memory can be allocated and freed dynamically Data Structure Implementation: Foundation for implementing complex data structures like linked lists and trees 2. Pointer Declaration and Usage\r2.1 Pointer Declaration\r// Pointer declaration syntax: var pointer_variable_name *data_type var ptr *int // Declare a pointer to int type var ptr2 *string // Declare a pointer to string type var ptr3 *float64 // Declare a pointer to float64 type 2.2 Getting Variable Addresses (\u0026amp; Operator)\rpackage main import \u0026#34;fmt\u0026#34; func main() { // Declare ordinary variables var num int = 100 var name string = \u0026#34;Zhang San\u0026#34; var score float64 = 95.5 // Use \u0026amp; operator to get variable\u0026#39;s memory address var ptrNum *int = \u0026amp;num var ptrName *string = \u0026amp;name var ptrScore *float64 = \u0026amp;score fmt.Printf(\u0026#34;Variable num value: %d, address: %p\\n\u0026#34;, num, \u0026amp;num) fmt.Printf(\u0026#34;Variable name value: %s, address: %p\\n\u0026#34;, name, \u0026amp;name) fmt.Printf(\u0026#34;Variable score value: %f, address: %p\\n\u0026#34;, score, \u0026amp;score) fmt.Printf(\u0026#34;Pointer ptrNum stores address: %p, pointed value: %d\\n\u0026#34;, ptrNum, *ptrNum) fmt.Printf(\u0026#34;Pointer ptrName stores address: %p, pointed value: %s\\n\u0026#34;, ptrName, *ptrName) fmt.Printf(\u0026#34;Pointer ptrScore stores address: %p, pointed value: %f\\n\u0026#34;, ptrScore, *ptrScore) } Execution result:\nVariable num value: 100, address: 0xc0000140a8 Variable name value: Zhang San, address: 0xc000010230 Variable score value: 95.500000, address: 0xc0000140b8 Pointer ptrNum stores address: 0xc0000140a8, pointed value: 100 Pointer ptrName stores address: 0xc000010230, pointed value: Zhang San Pointer ptrScore stores address: 0xc0000140b8, pointed value: 95.500000 2.3 Accessing Values Pointed by Pointers (* Operator)\rpackage main import \u0026#34;fmt\u0026#34; func main() { var num int = 50 var ptr *int = \u0026amp;num // ptr points to num\u0026#39;s address fmt.Printf(\u0026#34;num value: %d\\n\u0026#34;, num) fmt.Printf(\u0026#34;ptr stores address: %p\\n\u0026#34;, ptr) fmt.Printf(\u0026#34;Value accessed through pointer: %d\\n\u0026#34;, *ptr) // *ptr represents getting the value at the address ptr points to // Modify value through pointer *ptr = 100 fmt.Printf(\u0026#34;num value after modification: %d\\n\u0026#34;, num) // num\u0026#39;s value is also modified fmt.Printf(\u0026#34;Modified value accessed through pointer: %d\\n\u0026#34;, *ptr) } Execution result:\nnum value: 50 ptr stores address: 0xc0000140a8 Value accessed through pointer: 50 num value after modification: 100 Modified value accessed through pointer: 100 3. Pointer Zero Values and nil\r3.1 Pointer Zero Values\rpackage main import \u0026#34;fmt\u0026#34; func main() { // Declare pointer variables without initialization var ptr *int var ptr2 *string fmt.Printf(\u0026#34;Uninitialized int pointer: %v, is nil: %t\\n\u0026#34;, ptr, ptr == nil) fmt.Printf(\u0026#34;Uninitialized string pointer: %v, is nil: %t\\n\u0026#34;, ptr2, ptr2 == nil) // Trying to access values of uninitialized pointers will cause panic // fmt.Println(*ptr) // This line would cause an error! } Execution result:\nUninitialized int pointer: \u0026lt;nil\u0026gt;, is nil: true Uninitialized string pointer: \u0026lt;nil\u0026gt;, is nil: true 3.2 Safe Checking of nil Pointers\rpackage main import \u0026#34;fmt\u0026#34; func main() { var ptr *int // Safety check if ptr != nil { fmt.Println(\u0026#34;Pointer is not nil, safe to access\u0026#34;) fmt.Println(*ptr) } else { fmt.Println(\u0026#34;Pointer is nil, cannot access\u0026#34;) } // After initializing pointer num := 42 ptr = \u0026amp;num if ptr != nil { fmt.Println(\u0026#34;Pointer is not nil, safe to access\u0026#34;) fmt.Println(\u0026#34;Value pointed by pointer: \u0026#34;, *ptr) } } Execution result:\nPointer is nil, cannot access Pointer is not nil, safe to access Value pointed by pointer: 42 4. Pointers and Functions\r4.1 Pointers as Function Parameters\rpackage main import \u0026#34;fmt\u0026#34; // Pass by value - won\u0026#39;t modify original value func changeValueByValue(x int) { x = 100 fmt.Printf(\u0026#34;Value of x inside function: %d\\n\u0026#34;, x) } // Pass by pointer - can modify original value func changeValueByPointer(ptr *int) { *ptr = 200 fmt.Printf(\u0026#34;Value modified through pointer inside function: %d\\n\u0026#34;, *ptr) } func main() { num := 50 fmt.Printf(\u0026#34;num value before calling function: %d\\n\u0026#34;, num) // Call by value changeValueByValue(num) fmt.Printf(\u0026#34;num value after call by value: %d\\n\u0026#34;, num) // Call by pointer changeValueByPointer(\u0026amp;num) fmt.Printf(\u0026#34;num value after call by pointer: %d\\n\u0026#34;, num) } Execution result:\nnum value before calling function: 50 Value of x inside function: 100 num value after call by value: 50 Value modified through pointer inside function: 200 num value after call by pointer: 200 4.2 Functions Returning Pointers\rpackage main import \u0026#34;fmt\u0026#34; // Return pointer to int func createIntPointer(value int) *int { return \u0026amp;value } // Return pointer to struct func createStudentPointer(name string, age int) *struct { Name string Age int } { student := struct { Name string Age int }{name, age} return \u0026amp;student } func main() { // Get pointer ptr := createIntPointer(999) fmt.Printf(\u0026#34;Pointer address: %p, pointed value: %d\\n\u0026#34;, ptr, *ptr) // Modify value accessed through pointer *ptr = 888 fmt.Printf(\u0026#34;Modified value: %d\\n\u0026#34;, *ptr) // Struct pointer studentPtr := createStudentPointer(\u0026#34;Li Si\u0026#34;, 20) fmt.Printf(\u0026#34;Student info: %s, %d years old\\n\u0026#34;, (*studentPtr).Name, (*studentPtr).Age) // Go provides simplified syntax fmt.Printf(\u0026#34;Student info simplified syntax: %s, %d years old\\n\u0026#34;, studentPtr.Name, studentPtr.Age) } Execution result:\nPointer address: 0xc0000140a8, pointed value: 999 Modified value: 888 Student info: Li Si, 20 years old Student info simplified syntax: Li Si, 20 years old 5. Pointer Arrays and Array Pointers\r5.1 Pointer Arrays\rpackage main import \u0026#34;fmt\u0026#34; func main() { // Create several variables a, b, c := 1, 2, 3 // Pointer array - each element of the array is a pointer ptrArray := [3]*int{\u0026amp;a, \u0026amp;b, \u0026amp;c} fmt.Println(\u0026#34;Pointer array content:\u0026#34;) for i, ptr := range ptrArray { fmt.Printf(\u0026#34;Index %d: address %p, value %d\\n\u0026#34;, i, ptr, *ptr) } // Modify original variables through pointer array *ptrArray[0] = 10 *ptrArray[1] = 20 *ptrArray[2] = 30 fmt.Printf(\u0026#34;After modification: a=%d, b=%d, c=%d\\n\u0026#34;, a, b, c) } Execution result:\nPointer array content: Index 0: address 0xc0000140a8, value 1 Index 1: address 0xc0000140b0, value 2 Index 2: address 0xc0000140b8, value 3 After modification: a=10, b=20, c=30 5.2 Array Pointers\rpackage main import \u0026#34;fmt\u0026#34; func main() { // Ordinary array arr := [3]int{10, 20, 30} // Array pointer - pointer pointing to the entire array arrPtr := \u0026amp;arr fmt.Printf(\u0026#34;Array address: %p\\n\u0026#34;, \u0026amp;arr) fmt.Printf(\u0026#34;Array pointer stores address: %p\\n\u0026#34;, arrPtr) fmt.Printf(\u0026#34;Access elements through array pointer: %d, %d, %d\\n\u0026#34;, (*arrPtr)[0], (*arrPtr)[1], (*arrPtr)[2]) // Modify array elements (*arrPtr)[0] = 100 (*arrPtr)[1] = 200 (*arrPtr)[2] = 300 fmt.Printf(\u0026#34;Array after modification: %v\\n\u0026#34;, arr) // Go\u0026#39;s simplified syntax arrPtr[0] = 1000 // Equivalent to (*arrPtr)[0] = 1000 fmt.Printf(\u0026#34;After modification with simplified syntax: %v\\n\u0026#34;, arr) } Execution result:\nArray address: 0xc000016060 Array pointer stores address: 0xc000016060 Access elements through array pointer: 10, 20, 30 Array after modification: [100 200 300] After modification with simplified syntax: [1000 200 300] 6. Pointers to Pointers (Multi-level Pointers)\rpackage main import \u0026#34;fmt\u0026#34; func main() { num := 42 // First level pointer ptr1 := \u0026amp;num fmt.Printf(\u0026#34;num value: %d, address: %p\\n\u0026#34;, num, \u0026amp;num) fmt.Printf(\u0026#34;First level pointer ptr1: %p, pointed value: %d\\n\u0026#34;, ptr1, *ptr1) // Second level pointer (pointer to pointer) ptr2 := \u0026amp;ptr1 fmt.Printf(\u0026#34;Second level pointer ptr2: %p, pointed address: %p, final value: %d\\n\u0026#34;, ptr2, *ptr2, **ptr2) // Third level pointer ptr3 := \u0026amp;ptr2 fmt.Printf(\u0026#34;Third level pointer ptr3: %p, final value: %d\\n\u0026#34;, ptr3, ***ptr3) // Modify value through multi-level pointer ***ptr3 = 999 fmt.Printf(\u0026#34;num value after modification through third level pointer: %d\\n\u0026#34;, num) } Execution result:\nnum value: 42, address: 0xc0000140a8 First level pointer ptr1: 0xc0000140a8, pointed value: 42 Second level pointer ptr2: 0xc000006028, pointed address: 0xc0000140a8, final value: 42 Third level pointer ptr3: 0xc000006038, final value: 42 num value after modification through third level pointer: 999 7. Practical Application Examples of Pointers\r7.1 Swapping Two Numbers\rpackage main import \u0026#34;fmt\u0026#34; // Swap two numbers using pointers func swap(a, b *int) { temp := *a *a = *b *b = temp } func main() { x, y := 10, 20 fmt.Printf(\u0026#34;Before swap: x=%d, y=%d\\n\u0026#34;, x, y) swap(\u0026amp;x, \u0026amp;y) fmt.Printf(\u0026#34;After swap: x=%d, y=%d\\n\u0026#34;, x, y) } Execution result:\nBefore swap: x=10, y=20 After swap: x=20, y=10 7.2 Linked List Node Example\rpackage main import \u0026#34;fmt\u0026#34; // Define linked list node structure type ListNode struct { Value int Next *ListNode } // Create new node func NewNode(value int) *ListNode { return \u0026amp;ListNode{Value: value, Next: nil} } // Add node at the end of linked list func AppendNode(head **ListNode, value int) { newNode := NewNode(value) if *head == nil { *head = newNode return } current := *head for current.Next != nil { current = current.Next } current.Next = newNode } // Print linked list func PrintList(head *ListNode) { current := head for current != nil { fmt.Printf(\u0026#34;%d -\u0026gt; \u0026#34;, current.Value) current = current.Next } fmt.Println(\u0026#34;nil\u0026#34;) } func main() { var head *ListNode = nil // Add nodes AppendNode(\u0026amp;head, 1) AppendNode(\u0026amp;head, 2) AppendNode(\u0026amp;head, 3) AppendNode(\u0026amp;head, 4) fmt.Println(\u0026#34;Linked list content:\u0026#34;) PrintList(head) } Execution result:\nLinked list content: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; nil 8. Pointer Considerations and Best Practices\r8.1 Important Notes\rDanger of nil pointer access: Accessing nil pointers will cause program crashes Dangling pointer problem: Pointers pointing to released memory Memory leak: Forgetting to free dynamically allocated memory 8.2 Best Practices\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 1. Always check if pointer is nil var ptr *int if ptr != nil { fmt.Println(*ptr) // Safe access } // 2. Initialize pointers num := 100 ptr = \u0026amp;num fmt.Printf(\u0026#34;Safe access: %d\\n\u0026#34;, *ptr) // 3. Consider lifetime when using pointers data := make([]int, 5) ptrToSlice := \u0026amp;data fmt.Printf(\u0026#34;Slice pointer: %v\\n\u0026#34;, *ptrToSlice) // 4. Be careful when functions return pointers func returnPointer() *int { value := 42 // Local variable return \u0026amp;value // Dangerous! Returning address of local variable } // Correct approach func returnPointerSafe() *int { value := new(int) // Allocate memory on heap *value = 42 return value } } 9. Difference Between new and make Functions\r9.1 new Function\rpackage main import \u0026#34;fmt\u0026#34; func main() { // new function allocates zero-value memory for specified type and returns pointer ptr1 := new(int) // *int type, value 0 ptr2 := new(string) // *string type, value \u0026#34;\u0026#34; ptr3 := new([3]int) // *[3]int type, value [0,0,0] fmt.Printf(\u0026#34;int pointer: %p, value: %d\\n\u0026#34;, ptr1, *ptr1) fmt.Printf(\u0026#34;string pointer: %p, value: %s\\n\u0026#34;, ptr2, *ptr2) fmt.Printf(\u0026#34;array pointer: %p, value: %v\\n\u0026#34;, ptr3, *ptr3) // Modify values *ptr1 = 100 *ptr2 = \u0026#34;Hello\u0026#34; (*ptr3)[0] = 1 (*ptr3)[1] = 2 (*ptr3)[2] = 3 fmt.Printf(\u0026#34;Modified int value: %d\\n\u0026#34;, *ptr1) fmt.Printf(\u0026#34;Modified string value: %s\\n\u0026#34;, *ptr2) fmt.Printf(\u0026#34;Modified array value: %v\\n\u0026#34;, *ptr3) } Execution result:\nint pointer: 0xc0000140a8, value: 0 string pointer: 0xc000010230, value: array pointer: 0xc000016060, value: [0 0 0] Modified int value: 100 Modified string value: Hello Modified array value: [1 2 3] 9.2 make Function\rpackage main import \u0026#34;fmt\u0026#34; func main() { // make function is used to create slices, maps, channels slice := make([]int, 5) // Create slice with length 5 mapData := make(map[string]int) // Create map ch := make(chan int) // Create channel fmt.Printf(\u0026#34;Slice: %v, length: %d\\n\u0026#34;, slice, len(slice)) fmt.Printf(\u0026#34;Map: %v\\n\u0026#34;, mapData) fmt.Printf(\u0026#34;Channel: %v\\n\u0026#34;, ch) // Initialize data slice[0] = 10 slice[1] = 20 mapData[\u0026#34;one\u0026#34;] = 1 mapData[\u0026#34;two\u0026#34;] = 2 fmt.Printf(\u0026#34;Slice after initialization: %v\\n\u0026#34;, slice) fmt.Printf(\u0026#34;Map after initialization: %v\\n\u0026#34;, mapData) } 10. Summary\rPointers are a powerful but cautious feature in Golang:\nCore Concepts:\nPointers store memory addresses, not actual values Use \u0026amp; to get variable address, use * to access value pointed by pointer The zero value of pointers is nil Main Uses:\nSharing and modifying data between functions Avoiding copy overhead of large data structures Implementing complex data structures (linked lists, trees, etc.) Dynamic memory management Important Notes:\nAlways check if pointers are nil Pay attention to variable lifecycles Avoid dangling pointers and memory leaks Mastering pointers is very important for deeply understanding Golang and writing efficient programs. Although it may seem complex when first learning, it can be mastered through extensive practice.\n","date":"2026-02-04T16:15:16+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-08/","title":"Golang Learning Journey [Part 8: Pointer]"},{"content":"Multi-Tenancy Architecture Beginner\u0026rsquo;s Guide: How Beginners Can Quickly Understand SaaS System Sharing Mechanisms\rMulti-tenancy is one of the most common and important architectural patterns in modern SaaS systems. Many beginners feel that the concepts are abstract and implementation methods are difficult to grasp during the learning process. This article starts from a zero-foundation perspective, using clear structure, accessible language, and concise explanations to help readers quickly establish an overall understanding of multi-tenancy.\n1. What is Multi-Tenancy? Is it an Architecture or a Way of Thinking?\rOfficial Definition\nMulti-tenancy is a software architectural pattern where a single software instance (or infrastructure) can simultaneously serve multiple independent tenants (typically different customers, enterprises, or organizations), while using technical means to ensure data isolation, security, privacy compliance, and efficient resource utilization.\nCommon Understanding\nThink of multi-tenancy as a large shared apartment building:\nThe building\u0026rsquo;s infrastructure (elevators, water and electricity, lobby, fire protection systems) is shared by all residents But each resident has an independent room with locked doors, and their personal items are completely isolated from others This approach allows multiple households to live together without building a separate villa for each family, saving costs while facilitating management Multi-tenancy is based on the same idea: one software system serves multiple companies simultaneously, but each company\u0026rsquo;s data and operations are logically isolated and do not interfere with each other.\nIt\u0026rsquo;s not an abstract way of thinking, but a concrete, implementable system design solution.\ngraph TD A[Shared Infrastructure\u0026lt;br\u0026gt;Servers / Code / Basic Services] --\u0026gt; B[Tenant A\u0026lt;br\u0026gt;Independent Data \u0026amp; Context] A --\u0026gt; C[Tenant B\u0026lt;br\u0026gt;Independent Data \u0026amp; Context] A --\u0026gt; D[Tenant C\u0026lt;br\u0026gt;Independent Data \u0026amp; Context] classDef shared fill:#e6f3ff,stroke:#0066cc,stroke-width:2px classDef tenant fill:#fff3e6,stroke:#cc6600,stroke-width:2px class A shared class B,C,D tenant\r2. How is Multi-Tenancy Actually Implemented in Real Projects?\rThe core of multi-tenancy implementation lies in isolation, with database isolation being the most critical part, followed by application layer context management and infrastructure isolation.\nThree Main Database Isolation Approaches\rComparison Table\nApproach Isolation Strength Resource Cost Management Complexity Typical Use Cases Dedicated Database (One Database Per Tenant) ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ High High High compliance requirements, finance, healthcare, enterprise clients Shared Database + Dedicated Schema ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ Medium Medium Mid to large SaaS, hundreds to thousands of tenants Shared Database + Shared Schema + Row-level Isolation ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ Low Low Mass consumer SaaS, tens of thousands+ tenants Simple Analogy\nDedicated Database ‚Üí Each company rents an entire floor Dedicated Schema ‚Üí Each company rents an independent suite on the same floor Row-level Isolation ‚Üí Everyone shares one large space, but each bed has clear identification and strict control graph LR A[Database Isolation Methods] --\u0026gt; B[Dedicated Database\u0026lt;br\u0026gt;One Physical Database Per Tenant] A --\u0026gt; C[Shared Database + Dedicated Schema\u0026lt;br\u0026gt;Logical Namespace Isolation] A --\u0026gt; D[Shared Database + Shared Schema\u0026lt;br\u0026gt;Row-level Isolation tenant_id] B --\u0026gt;|Strongest Isolation| E[Highest Compliance Requirements\u0026lt;br\u0026gt;Finance/Healthcare/Enterprise Clients] C --\u0026gt;|Balanced Solution| F[Mid-large SaaS\u0026lt;br\u0026gt;Hundreds~Thousands of Tenants] D --\u0026gt;|Lowest Cost| G[Mass Consumer SaaS\u0026lt;br\u0026gt;Tens of Thousands+ Tenants] classDef high fill:#ffcccc,stroke:#990000 classDef medium fill:#ffffcc,stroke:#996600 classDef low fill:#ccffcc,stroke:#006600 class B high class C medium class D low\r3. What\u0026rsquo;s the Difference Between Multi-Tenancy and Role-Based Access Control (RBAC)?\rMulti-tenancy and role-based access control (RBAC) are concepts at different levels that are often confused.\nCore Differences Comparison\nDimension Multi-Tenancy Role-Based Access Control (RBAC) Problem Solved Multiple companies sharing one system with data isolation required Different people having different permissions within the same company Objects Isolated Company vs Company Person vs Person (within same company) Layer Level Architectural layer, system boundary Permission module, functional layer Configuration Owner Usually handled by platform provider (SaaS vendor) Usually configured by customer (tenant administrator) One-sentence Summary\nMulti-tenancy determines \u0026ldquo;how many companies share one building,\u0026rdquo; while RBAC determines \u0026ldquo;who holds which keys within one company.\u0026rdquo;\ngraph TD A[Entire System] --\u0026gt; B[Multi-Tenancy Layer\u0026lt;br\u0026gt;Company/Organization Boundary Isolation] B --\u0026gt; C[Within Tenant\u0026lt;br\u0026gt;RBAC Permission Control] subgraph Tenant Boundary C --\u0026gt; D[Role: Administrator] C --\u0026gt; E[Role: Regular Employee] C --\u0026gt; F[Role: Finance Staff] end classDef boundary fill:#f0f8ff,stroke:#4682b4,stroke-width:2px classDef rbac fill:#fffacd,stroke:#dAA520,stroke-width:2px class B boundary class C,D,E,F rbac\r4. Will Customer Personalization Requirements Make Multi-Tenancy Very Complex?\rPersonalization requirements are indeed one of the most common challenges in multi-tenancy implementation.\nCustomization Complexity Levels (Low to High)\nAppearance and Branding (Logo, theme colors, copywriting, login page) Fields and Forms (adding/removing fields, visibility rules, validation rules) Processes and Rules (approval flows, state machines, calculation formulas) Business Logic Forks (strategy patterns, Hooks, plugins) Completely New Modules or Different Business Models (microservices, independent deployment) Handling Principles\nPrioritize configuration solutions Use rule engines or editable rules as secondary option Avoid hard-coding, prefer strategy patterns or plugin mechanisms For extremely rare customization scenarios, consider hybrid or independent deployment 5. Conclusion and Learning Suggestions\rThe core value of multi-tenancy can be summarized in one sentence: Serve as many independent customers as possible safely and efficiently with minimal resource investment.\n","date":"2026-02-04T08:35:21+08:00","permalink":"https://zg-dd.github.io/en/stu/multi-tenancy-guide/","title":"Multi-Tenancy Architecture Beginner's Guide: How Beginners Can Quickly Understand SaaS System Sharing Mechanisms"},{"content":"Overview\rDelve (dlv) is the official Go debugger, designed for Go‚Äôs concurrency model and runtime. It is the most widely used and powerful debugger in the Go ecosystem.\nInstallation\rRecommended install\rInstall the latest version using Go modules:\ngo install github.com/go-delve/delve/cmd/dlv@latest Verify\rAfter installation:\ndlv version If $GOPATH/bin is not in your PATH, add it or use the full path:\n~/go/bin/dlv version Core capabilities\rBreakpoints at specific lines or functions Step execution (line-by-line or into functions) Variable inspection and complex structure viewing Goroutine management (inspect and switch) Runtime variable changes for testing Call stack inspection Basic usage\rExample code\rCreate main.go:\npackage main import \u0026#34;fmt\u0026#34; func main() { message := \u0026#34;Hello, Delve!\u0026#34; fmt.Println(message) result := add(23, 19) fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) } func add(a, b int) int { sum := a + b return sum } Start a debug session\rMode 1: Debug source\rdlv debug main.go Mode 2: Debug binary\rgo build -o myapp main.go dlv exec ./myapp Mode 3: Attach to running process\r# Build and run go build -gcflags=\u0026#34;all=-N -l\u0026#34; -o myapp main.go ./myapp \u0026amp; # Attach PID=$! dlv attach $PID Common commands\rBreakpoint management\rCommand Alias Description break main.main b main.main break at main() break main.go:10 b main.go:10 break at line 10 breakpoints bp list breakpoints clear 1 - remove breakpoint #1 clearall - remove all breakpoints Execution control\rCommand Alias Description continue c continue to next breakpoint next n step over step s step into stepout so step out restart r restart program Variables \u0026amp; expressions\rCommand Alias Description print message p message print a variable locals - list locals args - list function args Other commands\rCommand Alias Description stack bt show call stack goroutines - list goroutines goroutine 1 g 1 switch goroutine exit q quit Full session example\r$ dlv debug main.go Type \u0026#39;help\u0026#39; for list of commands. # Set breakpoints (dlv) b main.main Breakpoint 1 set at 0x... for main.main() ./main.go:5 (dlv) b main.go:11 Breakpoint 2 set at 0x... for main.main() ./main.go:11 # Continue (dlv) c \u0026gt; main.main() ./main.go:5 (hits goroutine(1):1 total:1) (PC: 0x...) 1: package main 2: 3: import \u0026#34;fmt\u0026#34; 4: =\u0026gt; 5: func main() { 6: message := \u0026#34;Hello, Delve!\u0026#34; 7: fmt.Println(message) 8: result := add(23, 19) 9: fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) 10: } # Step (dlv) n \u0026gt; main.main() ./main.go:6 (PC: 0x...) 5: func main() { =\u0026gt; 6: message := \u0026#34;Hello, Delve!\u0026#34; 7: fmt.Println(message) 8: result := add(23, 19) 9: fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) 10: } # Inspect (dlv) p message \u0026#34;\u0026#34; (dlv) n \u0026gt; main.main() ./main.go:7 (PC: 0x...) (dlv) p message \u0026#34;Hello, Delve!\u0026#34; # Step into (dlv) s \u0026gt; fmt.Println(...) # Step out (dlv) so Hello, Delve! \u0026gt; main.main() ./main.go:8 (PC: 0x...) # Continue (dlv) c Result: 42 \u0026gt; main.main() ./main.go:11 (hits goroutine(1):1 total:1) (PC: 0x...) (dlv) p result 42 # Quit (dlv) q Advanced features\rConditional breakpoints\r(dlv) b main.go:10 Breakpoint 1 set at main.go:10 (dlv) cond 1 i == 5 Debug tests\rdlv test main_test.go Set breakpoint:\n(dlv) b TestMyFunction Pass command-line args\rdlv debug -- arg1 arg2 # or dlv exec ./myapp -- arg1 arg2 Goroutine debugging\r(dlv) goroutines (dlv) goroutine 5 (dlv) p localVar Practical tips\r1. Production debugging\rBuild with optimizations disabled:\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o myapp main.go 2. Performance considerations\rDebug builds run slower; use them only for debugging. Use standard build options in production. 3. IDE integration\rVS Code: install Go extension Goland: built-in Delve support CLI proficiency helps you understand IDE debugging 4. Troubleshooting\rIssue: breakpoints don‚Äôt hit\nEnsure -gcflags=\u0026quot;all=-N -l\u0026quot; Verify breakpoint line and function Issue: variable values look wrong\nCompiler optimizations can distort values Rebuild with optimizations disabled Summary\rDelve is essential for Go developers. With it you can:\nLocate bugs quickly using breakpoints and stepping Understand code flow by tracking variables Debug concurrency by inspecting goroutines Improve productivity by reducing debug time Start with small programs, practice the commands, and gradually apply Delve to complex debugging tasks.\n","date":"2025-11-19T11:00:42+08:00","permalink":"https://zg-dd.github.io/en/stu/go-delve/","title":"Go Debugger Delve (dlv) Notes"},{"content":"Common Docker \u0026amp; Docker Compose Commands\r1. Image management\rImages are like installation packages or templates.\nCommand Description Example docker imagesdocker image ls List local images docker images docker search \u0026lt;name\u0026gt; Search images from registry docker search nginx docker pull \u0026lt;image\u0026gt;:\u0026lt;tag\u0026gt; Pull image (defaults to latest) docker pull nginx:alpine docker rmi \u0026lt;image\u0026gt; Remove local image docker rmi nginx docker image prune Remove dangling images docker image prune docker build -t \u0026lt;tag\u0026gt; . Build image from Dockerfile docker build -t my-app:1.0 . 2. Container management\rContainers are runtime instances created from images.\nCommand Description Example docker run [options] \u0026lt;image\u0026gt; Create and start a container docker run -d -p 80:80 nginx docker start \u0026lt;name/ID\u0026gt; Start a stopped container docker start my_nginx docker stop \u0026lt;name/ID\u0026gt; Stop a running container (graceful) docker stop my_nginx docker restart \u0026lt;name/ID\u0026gt; Restart container docker restart my_nginx docker rm \u0026lt;name/ID\u0026gt; Remove a stopped container docker rm my_nginx docker container prune Remove all stopped containers docker container prune docker ps List running containers docker ps docker ps -a List all containers docker ps -a docker logs \u0026lt;name/ID\u0026gt; View container logs docker logs my_nginx docker logs -f \u0026lt;name/ID\u0026gt; Follow logs in real time docker logs -f my_nginx docker exec -it \u0026lt;name/ID\u0026gt; \u0026lt;cmd\u0026gt; Run a command inside container docker exec -it my_nginx /bin/bash 3. Network management\rCommand Description Example docker network ls List networks docker network ls docker network create \u0026lt;name\u0026gt; Create a network docker network create my_net docker network inspect \u0026lt;name\u0026gt; Inspect a network docker network inspect bridge 4. Volume management\rVolumes store persistent data.\nCommand Description Example docker volume ls List volumes docker volume ls docker volume create \u0026lt;name\u0026gt; Create a volume docker volume create my_data docker volume rm \u0026lt;name\u0026gt; Remove a volume docker volume rm my_data docker volume prune Remove unused volumes docker volume prune 5. System and info\rCommand Description Example docker info Show Docker system info docker info docker version Show Docker version docker version docker stats Live resource usage docker stats docker system df Disk usage docker system df 6. Docker Compose commands\rManage multi-container apps.\nCommand Description Example docker compose up Create and start services docker compose up docker compose up -d Start services in background docker compose up -d docker compose down Stop and remove services docker compose down docker compose ps List project containers docker compose ps docker compose logs View logs docker compose logs docker compose logs -f \u0026lt;service\u0026gt; Follow logs for a service docker compose logs -f web docker compose exec \u0026lt;service\u0026gt; \u0026lt;cmd\u0026gt; Run a command in service container docker compose exec db mysql -u root -p Common flags\rFlag Long Meaning Example -d --detach Run in background docker run -d nginx -it -i -t Interactive TTY docker run -it ubuntu /bin/bash -p --publish Port mapping docker run -p 8080:80 nginx -v --volume Mount volume or dir docker run -v /host/data:/container/data nginx -e --env Set env var docker run -e MY_VAR=value nginx --name Set container name docker run --name my_nginx nginx --rm Remove container on exit docker run --rm alpine echo \u0026quot;hello\u0026quot; üöÄ Most-used commands\rCheck status: docker ps (containers), docker images (images) Pull image: docker pull \u0026lt;name\u0026gt; Run container: docker run -d -p ... --name ... \u0026lt;image\u0026gt; Stop container: docker stop \u0026lt;name\u0026gt; Enter container: docker exec -it \u0026lt;name\u0026gt; /bin/bash View logs: docker logs -f \u0026lt;name\u0026gt; Remove container: docker rm \u0026lt;name\u0026gt; Remove image: docker rmi \u0026lt;name\u0026gt; Tip: Save this list as a daily quick reference.\n","date":"2025-09-25T11:57:50+08:00","permalink":"https://zg-dd.github.io/en/stu/docker-command/","title":"Docker Common Commands Cheat Sheet"},{"content":"Core Knowledge of Network Communication\r1. Core concepts\r1. Socket\rWhat it is: An extension mechanism for inter‚Äëprocess communication (IPC)\nUse: Establish network communication channels (TCP/UDP)\nFlow:\nServer: socket ‚Üí bind ‚Üí listen ‚Üí accept Client: socket ‚Üí connect ‚Üí write/read ‚Üí close\nNote: handle byte‚Äëorder conversion (htonl/ntohl) 2. TCP vs UDP\rFeature TCP UDP Connection Connection‚Äëoriented (3‚Äëway handshake) Connectionless Reliability Reliable (retransmission) Unreliable Data form Stream socket Datagram socket Use cases File transfer, web browsing Real‚Äëtime video, DNS 2. Server models\r1. Iterative server\rLimitation: Single‚Äëthreaded blocking; cannot handle concurrent requests.\n2. Process/Thread model\rProcess approach:\nUse waitpid() to avoid zombie processes Parent must reap child resources Zombie handling details:\nCause:\nChild terminates but parent never calls wait() Consumes process table resources Solutions:\nSynchronous reap: waitpid(pid, NULL, 0); Async reap (recommended): signal(SIGCHLD, [](int) { while(waitpid(-1, NULL, WNOHANG) \u0026gt; 0); }); Special cases:\nIf parent exits first, init adopts and reaps Batch reaping requires a loop Thread approach:\nMust synchronize shared variables More complex critical‚Äësection control 3. Process pool optimization\rType Characteristics Static pool Pre‚Äëcreated processes, fixed concurrency Dynamic pool Maintain min/max idle processes 3. High‚Äëperformance I/O models\r1. Traditional blocking\rCharacteristics:\nSingle thread blocks on I/O Low resource utilization 2. Select/Poll\rFeature Select Poll Mechanism Bitmap FD scan Linked list FD scan Max connections 1024 (FD_SETSIZE) No hard limit Efficiency O(n) scan O(n) scan Portability All platforms All platforms 3. Epoll\rCore mechanism:\nRegistration via epoll_ctl (red‚Äëblack tree) Ready list maintained by kernel Trigger modes: LT (level‚Äëtriggered) ET (edge‚Äëtriggered) Advantages:\nO(1) event notification Supports massive connections (C1000K) 4. NIO (Non‚Äëblocking I/O)\rCore components:\nChannel: full‚Äëduplex pipes (SocketChannel/FileChannel) Buffer: ByteBuffer/CharBuffer Selector: multiplexer (based on epoll/kqueue) Workflow:\nstart : Create Selector; : Register Channel; repeat : select() for ready events; : Handle SelectionKey; repeat while (events?) stop 5. AIO (Asynchronous I/O)\rPrinciple:\nKernel completes I/O and calls back No user‚Äëthread polling Typical use cases:\nLarge file async read/write High‚Äëlatency network ops 6. Comparison\rModel Blocking Threading Trigger Use case Blocking I/O Blocking 1:1 - Low concurrency Select Non‚Äëblocking 1:N Polling Cross‚Äëplatform medium load Poll Non‚Äëblocking 1:N Polling \u0026lt;10K connections Epoll Non‚Äëblocking 1:N Event‚Äëdriven Linux high concurrency NIO Non‚Äëblocking 1:N Readiness High throughput AIO Async 0:1 Callback Latency‚Äësensitive Notes\rKernel support:\nWindows: IOCP is true async I/O Linux: io_uring (\u0026gt;=5.1) is close to true async Performance thresholds:\nC10K: Select/Poll bottleneck C100K: Epoll/NIO required C1000K: Epoll + zero‚Äëcopy optimization Complexity:\nBlocking \u0026lt; Select \u0026lt; Poll \u0026lt; Epoll \u0026lt; NIO \u0026lt; AIO 4. Practical points\r1. Daemons\rKey steps:\nfork() setsid()\nRedirect standard I/O to /dev/null 2. UDP server\rTraits:\nNo listen()/accept() Use recvfrom()/sendto() 3. Other tips\rReuse Address: avoid TIME_WAIT port blocking Thundering herd: multi‚Äëprocess accept contention, needs kernel lock optimizations Server types: I/O‚Äëbound: LNMP (nginx) CPU‚Äëbound: LAMP (Apache) Coroutines: user‚Äëmode threads with lower context switch cost than kernel threads 5. Learning suggestions\r1. Diagnostic tools\rnetstat -anp # list network connections 2. Classic books\rUnix Network Programming Advanced Programming in the UNIX Environment ","date":"2025-08-15T19:08:51+08:00","permalink":"https://zg-dd.github.io/en/stu/socket/","title":"Core Knowledge of Network Communication"},{"content":" Personal study notes\n1. What is MCP?\rMCP (Model Content Protocol) is an open standard introduced by Anthropic in 2024. It provides a unified interaction framework between LLMs and external tools, data sources, and services. The core goal is to solve data silos in the AI ecosystem by standardizing interfaces so models can connect to external resources seamlessly‚Äîlike a \u0026ldquo;USB‚ÄëC\u0026rdquo; for AI or a universal adapter.\n2. Core features and principles\r2.1 Standardized 3‚Äëlayer architecture\rHost: the main app running the model (e.g., Claude Desktop, IDE plugins) Client: establishes a 1:1 connection with the server, wraps and forwards requests Server: lightweight adapter to real tools/data sources (databases, APIs, file systems) 2.2 Communication: JSON‚ÄëRPC 2.0\rLocal: JSON‚ÄëRPC over stdio for local tool calls Remote: long-lived HTTP via SSE (Server‚ÄëSent Events) and Streamable HTTP for async streaming Message format: all requests/responses follow JSON‚ÄëRPC 2.0 2.3 Dynamic discovery\rTool-level discovery: tools describe themselves (e.g., via OpenAPI) so models can call them without hard‚Äëcoded integration Service-level discovery (uncertain): URI‚Äëdriven discovery. The client parses a custom URI like mcp://api.service.com and fetches metadata (e.g., https://api.service.com/llms.txt). The server returns a JSON description including capabilities, docs, and auth. The client auto‚Äëconfigures access. Example: paste an MCP URI into chat and the LLM auto‚Äëintegrates the service (e.g., stock API) without manual config. 3. Security and permissions\rLocal execution by default to avoid data leakage User confirmation for high‚Äërisk operations (e.g., file deletion) Enterprise extensions: JWT, RBAC, IPsec tunnels for regulated scenarios 4. How it differs from traditional approaches\rFeature MCP Traditional API Function Calling Integration Unified protocol, dynamic discovery Per‚ÄëAPI custom integration Hard‚Äëcoded bindings Communication Bi‚Äëdirectional, real‚Äëtime Request‚Äëresponse Synchronous, no streaming Flexibility Plug‚Äëand‚Äëplay, multi‚Äëtool composition Re‚Äëdevelopment required Vendor‚Äëspecific 5. Summary\rMCP combines client‚Äëserver decoupling, JSON‚ÄëRPC messaging, and dynamic discovery to solve three pain points for LLM‚Äëtool integration:\nFlexibility: tools can be hot‚Äëplugged and services can expand dynamically Security: local execution plus permission control Standardization: unified protocol lowers integration cost and pushes openness By decoupling models from tools at the protocol layer, MCP moves AI from ‚Äúchat assistant‚Äù to ‚Äúexecution agent,‚Äù forming a foundation for complex agent systems. As enterprise adoption grows (e.g., Changhong Hongxin EADP integrating MCP), it is becoming core infrastructure for next‚Äëgeneration AI agents.\n","date":"2025-08-06T15:14:07+08:00","permalink":"https://zg-dd.github.io/en/stu/mcp-protocol-core/","title":"MCP Protocol: Intro and Core Mechanisms"},{"content":"When using MyBatis, we often inspect SQL logs to debug and optimize queries. However, MyBatis logs include placeholders and parameter values, so the SQL is not directly executable. This simple HTML + JavaScript tool parses MyBatis SQL logs and outputs runnable SQL statements.\n1. Features\rParse SQL logs: Extract SQL statements and parameters from MyBatis logs. Replace parameters: Replace ? placeholders with actual parameter values. Generate executable SQL: Output full SQL ready to run. 2. Implementation details\r2.1 HTML structure\rThe HTML provides a simple UI with an input area, a parse button, and an output area.\nInput area: paste MyBatis SQL logs. Parse button: triggers the JS parser. Output area: shows the executable SQL. 2.2 JavaScript logic\rThe JS logic does the following:\nSplit logs by newline and process line by line. Extract SQL from lines containing Preparing:. Parse parameters from lines containing Parameters: and handle types: Strings \u0026amp; timestamps: wrap with single quotes and escape single quotes. Nulls: replace with NULL. Other types: replace directly. Output results to the output textarea. 3. Script code\rCreate a .html file, paste the following into it, save, then open in a browser.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Mybatis SQL Log Parser\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function f(obj) { try { var textVa = obj.value; var logs = textVa.split(\u0026#39;\\n\u0026#39;); // Split by newline var results = []; var currentStatement = null; logs.forEach(function(log) { // Check if this line contains \u0026#34;Preparing:\u0026#34; or \u0026#34;Parameters:\u0026#34; if (log.indexOf(\u0026#39;Preparing:\u0026#39;) !== -1) { if (currentStatement !== null) { // If we have a current statement, push it to the results results.push(currentStatement); } // Start a new statement currentStatement = log.substring(log.indexOf(\u0026#39;Preparing:\u0026#39;) + \u0026#34;Preparing:\u0026#34;.length).trim(); } else if (log.indexOf(\u0026#39;Parameters:\u0026#39;) !== -1 \u0026amp;\u0026amp; currentStatement !== null) { // If we find parameters and have a current statement, parse the parameters var parametersStr = log.substring(log.indexOf(\u0026#39;Parameters:\u0026#39;) + \u0026#34;Parameters:\u0026#34;.length).trim(); var parameters = parametersStr.split(/,(?![^()]*\\))/g); // Use regex to split correctly for (var i = 0; i \u0026lt; parameters.length; i++) { var paramValue = parameters[i].trim(); if (paramValue === \u0026#34;null\u0026#34;) { currentStatement = currentStatement.replace(\u0026#34;?\u0026#34;, \u0026#34;NULL\u0026#34;); } else { var typeStr = paramValue.substring(paramValue.indexOf(\u0026#34;(\u0026#34;) + 1, paramValue.indexOf(\u0026#34;)\u0026#34;)); paramValue = paramValue.substring(0, paramValue.indexOf(\u0026#34;(\u0026#34;)).trim(); if (typeStr === \u0026#34;String\u0026#34; || typeStr === \u0026#34;Timestamp\u0026#34;) { paramValue = \u0026#34;\u0026#39;\u0026#34; + paramValue.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;\u0026#34;; } currentStatement = currentStatement.replace(\u0026#34;?\u0026#34;, paramValue); } } // Add the final statement to the results and reset currentStatement results.push(currentStatement); currentStatement = null; } }); // If there\u0026#39;s a remaining statement, push it to the results if (currentStatement !== null) { results.push(currentStatement); } document.getElementById(\u0026#34;d1\u0026#34;).value = results.join(\u0026#34;\\n\\n\u0026#34;); } catch (e) { console.error(e); alert(\u0026#34;Error parsing SQL: \u0026#34; + e.message); } } function copySQL() { var SQL = document.getElementById(\u0026#34;d1\u0026#34;); navigator.clipboard.writeText(SQL.value).then(function() { var msg = document.getElementById(\u0026#34;msg\u0026#34;); msg.innerHTML = \u0026#34;Copied to clipboard\u0026#34;; setTimeout(function () { msg.innerHTML = \u0026#34;\u0026#34;; }, 3000); }).catch(function(err) { console.error(\u0026#34;Copy failed:\u0026#34;, err); alert(\u0026#34;Error copying SQL: \u0026#34; + err.message); }); } function clearLog(obj) { obj.value = \u0026#34;\u0026#34;; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#00bfff\u0026#34;\u0026gt;Paste Mybatis SQL logs:\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;textarea id=\u0026#34;sqlLog\u0026#34; rows=\u0026#34;12\u0026#34; cols=\u0026#34;140\u0026#34; style=\u0026#34;font-size:12px;font-family: \u0026#39;CourierNew\u0026#39;;font-weight: bold;width: 98%;\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;div style=\u0026#34;border:0px deepskyblue solid;width:1425px;height:50px;text-align:right;\u0026#34;\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;button\u0026#34; onclick=\u0026#34;clearLog(document.getElementById(\u0026#39;sqlLog\u0026#39;))\u0026#34;\u0026gt;Clear\u0026lt;/button\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;submit\u0026#34; onclick=\u0026#34;f(document.getElementById(\u0026#39;sqlLog\u0026#39;))\u0026#34;\u0026gt;Parse SQL\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#32cd32\u0026#34;\u0026gt;Executable SQL:\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;textarea id=\u0026#34;d1\u0026#34; rows=\u0026#34;12\u0026#34; cols=\u0026#34;140\u0026#34; style=\u0026#34;font-size:12px;font-family: \u0026#39;CourierNew\u0026#39;;font-weight: bold;width: 98%;\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;div style=\u0026#34;border:0px deepskyblue solid;width:1425px;height:50px;text-align:right;\u0026#34;\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;button\u0026#34; onclick=\u0026#34;copySQL()\u0026#34;\u0026gt;Copy SQL\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;msg\u0026#34; style=\u0026#34;color:cornflowerblue;border:0px black solid;width:800px;height:20px;text-align:right;font-style: initial;font-size: large\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. How to use\rPaste MyBatis SQL logs into the input area. Click \u0026ldquo;Parse SQL\u0026rdquo;. View and copy the executable SQL in the output area. 4.1 Example\rInput:\nPreparing: INSERT INTO users (name, email) VALUES (?, ?) Parameters: John(String), null Output:\nINSERT INTO users (name, email) VALUES (\u0026#39;John\u0026#39;, NULL) 5. Summary\rThis simple script converts MyBatis SQL logs into executable SQL statements, making development and debugging much easier.\n","date":"2025-02-19T21:52:49+08:00","permalink":"https://zg-dd.github.io/en/blog/mybatis-sql-log-parser/","title":"MyBatis SQL Log Parser Script"},{"content":" In Java projects, POJOs (Plain Old Java Objects) are everywhere and often need to be logged. The traditional approach is to print them via toString, but the output is usually unstructured and makes troubleshooting harder. This tool converts about 90% of daily POJO logs into structured JSON automatically, greatly improving readability and maintainability and helping ops engineers locate issues faster.\n1. Problems solved\rExample 1: Simple object\nInput: User(id=1, name=\u0026quot;Alice\u0026quot;, age=25)\nOutput: {\u0026quot;User\u0026quot;: {\u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Alice\u0026quot;, \u0026quot;age\u0026quot;: 25}} Example 2: Nested object\nInput: Order(id=1001, items=[Item(id=2001, name=\u0026quot;Book\u0026quot;)])\nOutput: {\u0026quot;Order\u0026quot;: {\u0026quot;id\u0026quot;: 1001, \u0026quot;items\u0026quot;: [{\u0026quot;Item\u0026quot;: {\u0026quot;id\u0026quot;: 2001, \u0026quot;name\u0026quot;: \u0026quot;Book\u0026quot;}}]}}\nExample 3: Complex map\nInput: Config(settings={key1=\u0026quot;value1\u0026quot;, key2=[1, 2, 3]})\nOutput: {\u0026quot;Config\u0026quot;: {\u0026quot;settings\u0026quot;: {\u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: [1, 2, 3]}}} Example 4: Custom complex object\nInput: User(username=Âº†‰∏â, password=123456, students=[Student(name=ÊùéÂõõ, age=18, score=0.0, courses=null), Student(name=Áéã‰∫î, age=20, score=0.0, courses=[Êï∞Â≠¶, Ëã±ËØ≠, Áâ©ÁêÜ])], map={aa=123, bb=456, cc=‰Ω†Â•Ω})\nOutput:\n{ \u0026#34;User\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;Âº†‰∏â\u0026#34;, \u0026#34;password\u0026#34;: 123456, \u0026#34;students\u0026#34;: [ { \u0026#34;Student\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;ÊùéÂõõ\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;score\u0026#34;: 0.0, \u0026#34;courses\u0026#34;: null } }, { \u0026#34;Student\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Áéã‰∫î\u0026#34;, \u0026#34;age\u0026#34;: 20, \u0026#34;score\u0026#34;: 0.0, \u0026#34;courses\u0026#34;: [ \u0026#34;Êï∞Â≠¶\u0026#34;, \u0026#34;Ëã±ËØ≠\u0026#34;, \u0026#34;Áâ©ÁêÜ\u0026#34; ] } } ], \u0026#34;map\u0026#34;: { \u0026#34;aa\u0026#34;: 123, \u0026#34;bb\u0026#34;: 456, \u0026#34;cc\u0026#34;: \u0026#34;‰Ω†Â•Ω\u0026#34; } } } 2. Download\rDownload script\n","date":"2025-02-19T21:48:01+08:00","permalink":"https://zg-dd.github.io/en/blog/java-pojo-log-json/","title":"Java POJO Log JSON Converter"},{"content":"1. Closures\r1.1 What is a closure?\rA closure is a function combined with the environment that it captures. In Go, closures can access and modify variables defined in their enclosing scopes even after the outer function returns.\n1.2 Closure properties\rA closure can access variables from its outer scope. A closure can modify those outer-scope variables. The variables persist after the outer function exits. 1.3 Closure example\rpackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println(pos(i), neg(-2*i)) } } Each call to adder returns a distinct closure that captures its own sum variable. The output shows two independent sums growing separately.\n2. Types\r2.1 Custom types\rGo lets you define new type names with the type keyword.\n2.2 Type example\rpackage main import \u0026#34;fmt\u0026#34; type addFun func(int) int type selfint int func adder2(x int) addFun { return func(y int) int { return x + y } } func main() { var eg addFun = adder2(10) fmt.Println(eg(15)) var num1 selfint = 10 var num2 int = 20 fmt.Println(num1 + selfint(num2)) fmt.Println(int(num1) + num2) } Output: 25, 30, 30. selfint cannot be mixed with int without conversion.\n3. Defer\r3.1 How defer works\rA defer statement postpones a function call until the surrounding function returns.\n3.2 Defer example\rpackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } Output: hello followed by world because the deferred call runs after main finishes.\n4. Panic and Recover\rpanic is similar to throwing an exception; recover catches it. Go does not have try..catch syntax.\n4.1 Usage\rpanic signals an unrecoverable error. recover captures the panic so the program can continue. 4.2 Example\rpackage main import \u0026#34;fmt\u0026#34; func main() { defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;Recovered from\u0026#34;, r) } }() fmt.Println(\u0026#34;Starting the program\u0026#34;) panic(\u0026#34;Something went wrong!\u0026#34;) fmt.Println(\u0026#34;This line will not run\u0026#34;) } Output: Starting the program and then Recovered from Something went wrong! because the deferred function recovered from the panic.\n5. The time package\rThe time package provides utilities for working with dates and times, including formatting, parsing, duration math, and comparisons.\ncurrentTime := time.Now() fmt.Println(\u0026#34;Current Time:\u0026#34;, currentTime) year := currentTime.Year() month := currentTime.Month() day := currentTime.Day() hour := currentTime.Hour() minute := currentTime.Minute() second := currentTime.Second() fmt.Printf(\u0026#34;Current Time: %d-%02d-%02d %02d:%02d:%02d\\n\u0026#34;, year, month, day, hour, minute, second) fmt.Println(\u0026#34;Formatted:\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) timeStr := \u0026#34;2023-01-01 12:00:00\u0026#34; parsedTime, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err != nil { fmt.Println(\u0026#34;Failed to parse:\u0026#34;, err) return } fmt.Println(\u0026#34;Parsed:\u0026#34;, parsedTime) duration := time.Duration(10) * time.Second fmt.Println(\u0026#34;Duration:\u0026#34;, duration) newTime := currentTime.Add(duration) fmt.Println(\u0026#34;New Time:\u0026#34;, newTime) if currentTime.Before(parsedTime) { fmt.Println(\u0026#34;Current time is before parsed time\u0026#34;) } else if currentTime.After(parsedTime) { fmt.Println(\u0026#34;Current time is after parsed time\u0026#34;) } else { fmt.Println(\u0026#34;Current time equals parsed time\u0026#34;) } if currentTime.Equal(parsedTime) { fmt.Println(\u0026#34;Current time equals parsed time\u0026#34;) } Summary:\ntime.Now() Year/Month/Day/Hour/Minute/Second currentTime.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;) time.Parse(\u0026quot;2006-01-02 15:04:05\u0026quot;, timeStr) time.Duration(10) * time.Second currentTime.Add(duration) currentTime.Before/After/Equal(parsedTime) ","date":"2025-02-13T17:45:37+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-07/","title":"Golang Learning Journey [Part 7: closures, types, defer, panic/recover \u0026 the time package]"},{"content":"1. Map Data Type\rA map is a collection of key-value pairs where each key is unique and maps to a value. Maps are unordered, so iteration order is undefined. A map‚Äôs zero value is nil, so you must create it with make before use. Maps are reference types.\n1.1 Declaring and initializing maps\rvar map1 map[string]int map1 = make(map[string]int) map1[\u0026#34;a\u0026#34;] = 1 map1[\u0026#34;b\u0026#34;] = 2 map1[\u0026#34;c\u0026#34;] = 3 var map2 = make(map[string]int) map2[\u0026#34;a\u0026#34;] = 4 map2[\u0026#34;b\u0026#34;] = 5 map2[\u0026#34;c\u0026#34;] = 6 map3 := map[string]int{} map3[\u0026#34;a\u0026#34;] = 7 map3[\u0026#34;b\u0026#34;] = 8 map3[\u0026#34;c\u0026#34;] = 9 var map4 = map[string]int{\u0026#34;a\u0026#34;: 10, \u0026#34;b\u0026#34;: 11, \u0026#34;c\u0026#34;: 12} map5 := map[string]int{\u0026#34;a\u0026#34;: 13, \u0026#34;b\u0026#34;: 14, \u0026#34;c\u0026#34;: 15} var map6 map[string]int var map7 = map[string]int{} fmt.Printf(\u0026#34;map1 type:%T value:%v nil:%v\\n\u0026#34;, map1, map1, map1 == nil) fmt.Printf(\u0026#34;map2 type:%T value:%v nil:%v\\n\u0026#34;, map2, map2, map2 == nil) fmt.Printf(\u0026#34;map3 type:%T value:%v nil:%v\\n\u0026#34;, map3, map3, map3 == nil) fmt.Printf(\u0026#34;map4 type:%T value:%v nil:%v\\n\u0026#34;, map4, map4, map4 == nil) fmt.Printf(\u0026#34;map5 type:%T value:%v nil:%v\\n\u0026#34;, map5, map5, map5 == nil) fmt.Printf(\u0026#34;map6 type:%T value:%v nil:%v\\n\u0026#34;, map6, map6, map6 == nil) fmt.Printf(\u0026#34;map7 type:%T value:%v nil:%v\\n\u0026#34;, map7, map7, map7 == nil) map8 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} fmt.Println(len(map1)) Output:\nmap1 type:map[string]int value:map[a:1 b:2 c:3] nil:false map2 type:map[string]int value:map[a:4 b:5 c:6] nil:false map3 type:map[string]int value:map[a:7 b:8 c:9] nil:false map4 type:map[string]int value:map[a:10 b:11 c:12] nil:false map5 type:map[string]int value:map[a:13 b:14 c:15] nil:false map6 type:map[string]int value:\u0026lt;nil\u0026gt; nil:true map7 type:map[string]int value:map[] nil:false 3 1.2 Iterating over maps\rmap1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} fmt.Println(\u0026#34;1. fori style\u0026#34;) keys := make([]string, 0, len(map1)) for k := range map1 { keys = append(keys, k) } for i := 0; i \u0026lt; len(keys); i++ { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, keys[i], map1[keys[i]]) } fmt.Println(\u0026#34;2. for range style\u0026#34;) for k, v := range map1 { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, k, v) } Output:\n1. fori style key=one value=java key=two value=python key=three value=go 2. for range style key=one value=java key=two value=python key=three value=go 1.3 Map CRUD\rmap1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;} map1[\u0026#34;four\u0026#34;] = \u0026#34;php\u0026#34; fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) delete(map1, \u0026#34;one\u0026#34;) fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) map1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; if value, ok := map1[\u0026#34;two\u0026#34;]; ok { fmt.Println(value) } if value1, ok1 := map1[\u0026#34;five\u0026#34;]; ok1 { fmt.Println(value1) } else { fmt.Println(\u0026#34;five does not exist\u0026#34;) } Output:\nmap1: map[four:php three:go two:python] map1: map[three:go two:python] c++ five does not exist 2. Functions\rFunctions are reusable code blocks that implement a specific feature.\nFunctions have the following traits:\nIncrease code reuse and readability, and simplify maintenance. Return values via return, which can send back one or more values. Parameters are defined in a parameter list and can be any type and any count. Local variable scope is limited to inside the function; the outside cannot access them. The parameter list and return values define the function‚Äôs interface and contract. 2.1 Various function definitions\rpackage main import \u0026#34;fmt\u0026#34; func sayHello() { fmt.Println(\u0026#34;hello world\u0026#34;) } func sayHello2(name string) { fmt.Println(\u0026#34;hello\u0026#34;, name) } func add(a int, b int) int { return a + b } func add2(a, b int) int { return a + b } func add3(a, b int) (c int) { c = a + b return } func add4(a, b int) (int, int) { return a + b, a - b } func add5(a, b int) (sum, diff int) { sum = a + b diff = a - b return } func add6(a ...int) int { sum := 0 for _, v := range a { sum += v } return sum } func opreate(a, b int, op func(int, int) int) int { return op(a, b) } func add7(a, b int) func() string { f := func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) } return f } func add8(a, b int) func() string { return func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) } } func main() { sayHello() sayHello2(\u0026#34;Zhang San\u0026#34;) fmt.Printf(\u0026#34;add %d\\n\u0026#34;, add(1, 2)) fmt.Printf(\u0026#34;add2 %d\\n\u0026#34;, add2(3, 4)) fmt.Printf(\u0026#34;add3 %d\\n\u0026#34;, add3(5, 6)) sum1, diff1 := add4(7, 8) fmt.Printf(\u0026#34;add4 %d %d\\n\u0026#34;, sum1, diff1) sum2, diff2 := add5(9, 10) fmt.Printf(\u0026#34;add5 %d %d\\n\u0026#34;, sum2, diff2) fmt.Printf(\u0026#34;add6 %d\\n\u0026#34;, add6(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(1, 2, add)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(2, 4, func(i1, i2 int) int { return i1 * i2 })) fmt.Printf(\u0026#34;add7 %s\\n\u0026#34;, add7(1, 2)()) fmt.Printf(\u0026#34;add8 %s\\n\u0026#34;, add8(3, 4)()) } Output:\nhello world hello Zhang San add 3 add2 7 add3 11 add4 15 -3 add5 19 -1 add6 55 opreate 3 opreate 8 add7 1 + 2 = 3 add8 3 + 4 = 7 ","date":"2025-02-11T20:05:09+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-06/","title":"Golang Learning Journey [Part 6: Composite Types ‚Äì Map \u0026 Function Primer]"},{"content":"1. Arrays\rAn array is a fixed-length collection of elements of the same type. Arrays are value types.\n1.1 Declaring an array\rvar name = [length]\u0026lt;type\u0026gt; var name = [length]\u0026lt;type\u0026gt;{} name := [length]\u0026lt;type\u0026gt;{} Example:\nvar arr1 [4]int fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr1, len(arr1), arr1) Output:\nType: [4]int; length: 4; data: [0 0 0 0] 1.2 Initializing arrays\rvar arr1 [4]int arr1[0] = 1 arr1[3] = 4 fmt.Printf(\u0026#34;Method1: %T length: %v data: %v\\n\u0026#34;, arr1, len(arr1), arr1) var arr2 = [3]float64{1, 2, 4.6} fmt.Printf(\u0026#34;Method2: %T length: %v data: %v\\n\u0026#34;, arr2, len(arr2), arr2) arr3 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;Method3: %T length: %v data: %v\\n\u0026#34;, arr3, len(arr3), arr3) arr4 := [...]int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;Method4: %T length: %v data: %v\\n\u0026#34;, arr4, len(arr4), arr4) arr5 := [...]float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;Method5: %T length: %v data: %v\\n\u0026#34;, arr5, len(arr5), arr5) Output:\nType: [4]int; length: 4; data: [0 0 0 0] Method1: [4]int; length: 4; data: [1 0 0 4] Method2: [3]float64; length: 3; data: [1 2 4.6] Method3: [3]string; length: 3; data: [java Golang Python] Method4: [5]int; length: 5; data: [2 4 6 7 8] Method5: [8]float64; length: 8; data: [2 0 3.5 0 0 4.6 0 9] 1.3 Looping through arrays\rarr6 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} for i := 0; i \u0026lt; len(arr6); i++ { fmt.Printf(\u0026#34;idx%v: %v\\t\u0026#34;, i, arr6[i]) } fmt.Println() for index, value := range arr6 { fmt.Printf(\u0026#34;idx%v: %v\\t\u0026#34;, index, value) } Output:\nfori loop idx0: java; idx1: Golang; idx2: Python; for range loop idx0: java; idx1: Golang; idx2: Python; 1.4 Multidimensional arrays\rarr7 := [3][3]int{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, } fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr7, len(arr7), arr7) arr8 := [...][2]string{{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}} fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr8, len(arr8), arr8) for i := 0; i \u0026lt; len(arr7); i++ { for j := 0; j \u0026lt; len(arr7[i]); j++ { fmt.Printf(\u0026#34;row%v col%v: %v\\t\u0026#34;, i+1, j+1, arr7[i][j]) } fmt.Println() } for row, rowValue := range arr8 { for col, value := range rowValue { fmt.Printf(\u0026#34;row%v col%v: %v\\t\u0026#34;, row+1, col+1, value) } fmt.Println() } Output:\nType: [3][3]int; length: 3; data: [[1 2 3] [4 5 6] [7 8 9]] Type: [2][2]string; length: 2; data: [[a b] [c d]] row1 col1: 1; row1 col2: 2; row1 col3: 3; row2 col1: 4; row2 col2: 5; row2 col3: 6; row3 col1: 7; row3 col2: 8; row3 col3: 9; row1 col1: a; row1 col2: b; row2 col1: c; row2 col2: d; 2. Slices\rA slice is a wrapper over an array and represents a dynamic-length view. Slices are reference types.\n2.1 Declaring and initializing slices\rvar arr1 []int fmt.Printf(\u0026#34;Type: %T; len: %v; data: %v\\n\u0026#34;, arr1, len(arr1), arr1) var arr2 = []float64{1, 2, 4.6} fmt.Printf(\u0026#34;Method1: %T; len: %v; data: %v\\n\u0026#34;, arr2, len(arr2), arr2) arr3 := []string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;Method2: %T; len: %v; data: %v\\n\u0026#34;, arr3, len(arr3), arr3) arr4 := []int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;Method3: %T; len: %v; data: %v\\n\u0026#34;, arr4, len(arr4), arr4) arr5 := []float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;Method4: %T; len: %v; data: %v\\n\u0026#34;, arr5, len(arr5), arr5) Output:\nType: []int; len: 0; data: [] Method1: []float64; len: 3; data: [1 2 4.6] Method2: []string; len: 3; data: [java Golang Python] Method3: []int; len: 5; data: [2 4 6 7 8] Method4: []float64; len: 8; data: [2 0 3.5 0 0 4.6 0 9] 2.2 Creating slices from arrays\rarr1 := [5]int{10, 29, 49, 58, 32} fmt.Printf(\u0026#34;Type: %T; length: %v; data: %v\\n\u0026#34;, arr1, len(arr1), arr1) s1 := arr1[:] s2 := arr1[2:] s3 := arr1[:2] fmt.Printf(\u0026#34;Full slice: %T; len: %v; data: %v\\n\u0026#34;, s1, len(s1), s1) fmt.Printf(\u0026#34;From idx2: %T; len: %v; data: %v\\n\u0026#34;, s2, len(s2), s2) fmt.Printf(\u0026#34;Before idx2: %T; len: %v; data: %v\\n\u0026#34;, s3, len(s3), s3) Output:\nType: [5]int; length: 5; data: [10 29 49 58 32] Full slice: []int; len: 5; data: [10 29 49 58 32] From idx2: []int; len: 3; data: [49 58 32] Before idx2: []int; len: 2; data: [10 29] Summary: arr[start:end] extracts elements from index start (inclusive) to end (exclusive). Omit start or end to mean the beginning or end of the array.\n2.3 Slice length and capacity\rA slice has its own length and capacity: len returns the number of elements; cap counts how many elements remain from the first element to the end of the underlying array.\na := []int{2, 3, 4, 5, 6, 7} fmt.Printf(\u0026#34;Type: %T, len: %v, cap: %v, data: %v\\n\u0026#34;, a, len(a), cap(a), a) b := a[3:] c := a[:3] fmt.Printf(\u0026#34;%T, len: %v, cap: %v, data: %v\\n\u0026#34;, b, len(b), cap(b), b) fmt.Printf(\u0026#34;%T, len: %v, cap: %v, data: %v\\n\u0026#34;, c, len(c), cap(c), c) Output:\nType: []int, len: 6, cap: 6, data: [2 3 4 5 6 7] Type: []int, len: 3, cap: 3, data: [5 6 7] Type: []int, len: 3, cap: 6, data: [2 3 4] 3. nil\rThe predefined identifier nil represents the zero value for pointers, channels, functions, interfaces, maps, slices, etc.\nType Default value bool false int, float 0 string \u0026quot;\u0026quot; pointers nil arrays zero value array slices nil maps nil channels nil functions nil var arr [3]int var slices1 []int var slices2 = []int{1} fmt.Println(arr) fmt.Println(slices1, slices1 == nil, slices2 == nil) Output:\n[0 0 0] [] true false 4. Value vs. reference types\rValue types store independent copies, so updating one variable does not affect another. Reference types share the same underlying data, so modifying one reflects in the other. Slices are typical reference types.\na1 := [...]int{2, 3, 4, 5} a2 := []int{2, 3, 4, 5} b1 := a1 b2 := a2 b1[0] = 6 b2[0] = 6 fmt.Printf(\u0026#34;a1=%v,b1=%v\\n\u0026#34;, a1, b1) fmt.Printf(\u0026#34;a2=%v,b2=%v\\n\u0026#34;, a2, b2) Output:\na1=[2 3 4 5],b1=[6 3 4 5] a2=[6 3 4 5],b2=[6 3 4 5] 5. Common slice utilities\r5.1 make\rmake([]int, 10, 11) allocates a slice with length 10 and capacity 11.\nslice1 := make([]int, 10, 11) slice1[2] = 6 slice1[9] = 20 fmt.Printf(\u0026#34;Type: %T, len: %v, cap: %v, data: %v\\n\u0026#34;, slice1, len(slice1), cap(slice1), slice1) Output:\nType: []int, len: 10, cap: 11, data: [0 0 6 0 0 0 0 0 0 20] 5.2 append\rUse append(slice, elems...) to grow slices.\nslice2 := make([]int, 0, 0) slice2 = append(slice2, 12, 14, 24) fmt.Printf(\u0026#34;%T len: %v cap: %v data: %v\\n\u0026#34;, slice2, len(slice2), cap(slice2), slice2) slice3 := []int{3, 4, 5} slice4 := append(slice2, slice3...) fmt.Printf(\u0026#34;%T len: %v cap: %v data: %v\\n\u0026#34;, slice4, len(slice4), cap(slice4), slice4) Output:\nType: []int, len: 3, cap: 3, data: [12 14 24] Type: []int, len: 6, cap: 6, data: [12 14 24 3 4 5] 5.3 copy (deep clone)\rcopy(dst, src) copies src into dst. Use it to avoid sharing the same backing array.\nslice2 := make([]int, 0, 0) slice2 = append(slice2, 12, 14, 24) slice3 := []int{3, 4, 5} slice4 := append(slice2, slice3...) slice4Copy := make([]int, len(slice4)) copy(slice4Copy, slice4) slice4Copy[0] = 6666 fmt.Println(slice4, slice4Copy) Output:\n[12 14 24 3 4 5] [6666 14 24 3 4 5] 5.4 Deleting from a slice\rGo has no built-in delete. Combine slicing with append to drop a range.\ns1 := []int{1, 2, 3, 4, 5, 6} delIdx := 3 s1 = append(s1[:delIdx], s1[delIdx+1:]...) fmt.Println(s1) Output:\n[1 2 3 5 6] 5.5 Sorting slices\r5.5.1 Ascending\rUse sort.Ints, sort.Float64s, or sort.Strings.\nintList := []int{3, 4, 32, 32, 423, 12} floatList := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} sort.Ints(intList) sort.Float64s(floatList) sort.Strings(stringList) fmt.Println(intList) fmt.Println(floatList) fmt.Println(stringList) Output:\n[3 4 12 32 32 423] [1.1 3.13 4.2 5.3] [A C D S] 5.5.2 Descending\rCombine sort.XXXSlice, sort.Reverse, and sort.Sort.\nintList := []int{3, 4, 32, 32, 423, 12} floatList := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(floatList))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Println(intList) fmt.Println(floatList) fmt.Println(stringList) Output:\n[423 32 32 12 4 3] [5.3 4.2 3.13 1.1] [S D C A] 6. Tips and tricks\r6.1 Editor hints\rWhen you type . after a variable the editor shows suggestions. Items ending with ! insert scaffolding code. Hint Meaning append! Append slice items copy! Copy slice for! standard for loop forr! for range loop ifnotnil! if var != nil guard last! shorthand for a[len(a)-1] len! shorthand for len(a) print! print variable range! alias for forr! reverse! reverse slice sort! custom sort scaffolding var! assign to a new variable 6.2 Inspecting signatures\rHover for over 1s to view parameter and return metadata. Ctrl+Click enters the definition with full documentation. Use translation tools if needed. ","date":"2025-01-08T22:05:33+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-05/","title":"Golang Learning Journey [Part 5: Composite Types ‚Äì Arrays \u0026 Slices]"},{"content":"1. Operators\r1.1 Arithmetic operators\rSymbol Description + Addition - Subtraction * Multiplication / Division % Modulo Example:\nnum1 := 5 num2 := 3 fmt.Printf(\u0026#34;%v + %v = %v\\n\u0026#34;, num1, num2, num1+num2) fmt.Printf(\u0026#34;%v - %v = %v\\n\u0026#34;, num1, num2, num1-num2) fmt.Printf(\u0026#34;%v * %v = %v\\n\u0026#34;, num1, num2, num1*num2) fmt.Printf(\u0026#34;%v / %v = %v\\n\u0026#34;, num1, num2, num1/num2) fmt.Printf(\u0026#34;%v %% %v = %v\\n\u0026#34;, num1, num2, num1%num2) num2++ fmt.Printf(\u0026#34;After ++: %v \\n\u0026#34;, num2) num2-- fmt.Printf(\u0026#34;After --: %v \\n\u0026#34;, num2) Output:\n5 + 3 = 8 5 - 3 = 2 5 * 3 = 15 5 / 3 = 1 5 % 3 = 2 After ++: 4 After --: 3 Note: Go‚Äôs ++ and \u0026ndash; are statements, not expressions, so they cannot be assigned.\n1.2 Comparison operators\rSymbol Description == equal to != not equal to \u0026gt; greater than \u0026gt;= greater than or equal to \u0026lt; less than \u0026lt;= less than or equal to Example:\nnum3, num4 := 8, 6 fmt.Printf(\u0026#34;%v == %v = %v\\n\u0026#34;, num3, num4, num3 == num4) fmt.Printf(\u0026#34;%v != %v = %v\\n\u0026#34;, num3, num4, num3 != num4) fmt.Printf(\u0026#34;%v \u0026gt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt; num4) fmt.Printf(\u0026#34;%v \u0026gt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt;= num4) fmt.Printf(\u0026#34;%v \u0026lt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt; num4) fmt.Printf(\u0026#34;%v \u0026lt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt;= num4) Output:\n8 == 6 = false 8 != 6 = true 8 \u0026gt; 6 = true 8 \u0026gt;= 6 = true 8 \u0026lt; 6 = false 8 \u0026lt;= 6 = false 1.3 Logical operators\rSymbol Description \u0026amp;\u0026amp; logical AND ! logical NOT Example:\nnum5, num6 := 16, 20 fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 \u0026lt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 \u0026amp;\u0026amp; num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 || num6 \u0026lt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 || num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026gt; 15 || num6 == 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num5 \u0026lt; 15 || num6 \u0026gt; 20) fmt.Printf(\u0026#34;%v\\n\u0026#34;, !(num5 \u0026lt; 15)) fmt.Printf(\u0026#34;%v\\n\u0026#34;, !(num6 == 20)) Output:\nfalse false true true true true false true false 1.4 Assignment operators\rSymbol Description = Assign += Add and assign -= Subtract and assign *= Multiply and assign /= Divide and assign %= Modulo and assign \u0026laquo;= Left shift and assign \u0026raquo;= Right shift and assign \u0026amp;= Bitwise AND and assign = ^= Bitwise XOR and assign Example:\nnum6, num7 := 3, 6 num7 += num6 fmt.Printf(\u0026#34;num7 += num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 -= num6 fmt.Printf(\u0026#34;num7 -= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 *= num6 fmt.Printf(\u0026#34;num7 *= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 /= num6 fmt.Printf(\u0026#34;num7 /= num6 result: %v\\n\u0026#34;, num7) num7 = 6 num7 %= num6 fmt.Printf(\u0026#34;num7 %%= num6 result: %v\\n\u0026#34;, num7) Output:\nnum7 += num6 result: 9 num7 -= num6 result: 3 num7 *= num6 result: 18 num7 /= num6 result: 2 num7 %= num6 result: 0 Advanced assignment operators are used in the binary section below.\n1.5 Other operators\rSymbol Description \u0026amp; Address of a variable * Pointer dereference Computers store variables through memory addresses. A pointer holds an address, and dereferencing it gives the stored value.\nExample:\nvar p *int num8 := 100 p = \u0026amp;num8 fmt.Printf(\u0026#34;p address=%v, value=%v\u0026#34;, p, *p) Output:\np address=0xc00000a0d8, value=100 2. Binary operations\rAll binary operations below operate on binary digits.\nSymbol Description \u0026amp; bitwise AND ^ bitwise XOR \u0026laquo; left shift \u0026raquo; right shift |p | q | p\u0026amp;q | p|q | p^q | |\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;| | 0 | 0 | 0 | 0 | 0 | | 1 | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 0 |\n\u0026amp; yields a 1 only if both bits are 1; | yields 0 only if both bits are 0; ^ yields 1 when bits differ; \u0026laquo; shifts left (fills with 0); \u0026raquo; shifts right (discards bits). Binary ops are useful for fast hardware-level control, such as address or IP manipulation.\nExample:\nvar num1 = 0b101011 var num2 = 0b110001 fmt.Printf(\u0026#34;%b \u0026amp; %b = %b \\n\u0026#34;, num1, num2, num1\u0026amp;num2) fmt.Printf(\u0026#34;%b | %b = %b \\n\u0026#34;, num1, num2, num1|num2) fmt.Printf(\u0026#34;%b ^ %b = %b \\n\u0026#34;, num1, num2, num1^num2) fmt.Printf(\u0026#34;%b \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, num1, 2, num1\u0026lt;\u0026lt;2) fmt.Printf(\u0026#34;%b \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, num2, 2, num2\u0026gt;\u0026gt;2) num2 = 0b110001 num2 \u0026amp;= num1 fmt.Printf(\u0026#34;num2 \u0026amp;= num1: %b \\n\u0026#34;, num2) num2 = 0b110001 num2 |= num1 fmt.Printf(\u0026#34;num2 |= num1: %b \\n\u0026#34;, num2) num2 = 0b110001 num2 ^= num1 fmt.Printf(\u0026#34;num2 ^= num1: %b \\n\u0026#34;, num2) num1 = 0b110001 num1 \u0026lt;\u0026lt;= 2 fmt.Printf(\u0026#34;num1 \u0026lt;\u0026lt;= 2: %b \\n\u0026#34;, num1) num2 = 0b110001 num2 \u0026gt;\u0026gt;= 2 fmt.Printf(\u0026#34;num2 \u0026gt;\u0026gt;= 2: %b \\n\u0026#34;, num2) Output:\n101011 \u0026amp; 110001 = 100001 101011 | 110001 = 111011 101011 ^ 110001 = 11010 101011 \u0026lt;\u0026lt; 2 = 10101100 110001 \u0026gt;\u0026gt; 2 = 1100 100001 111011 11010 11000100 1100 \u0026amp; and | can also toggle flags. For example, treat a 5-bit binary value as seat occupancy (0=free, 1=occupied). Using masks you can clear or set specific bits:\nvar seat = 0b10011 var mask1 = 0b01010 fmt.Printf(\u0026#34;clear positions 1,3,5: %b \\n\u0026#34;, seat\u0026amp;mask1) var mask2 = 0b01010 fmt.Printf(\u0026#34;set positions 2,4: %b \\n\u0026#34;, seat|mask2) Output:\nclear positions 1,3,5: 10 set positions 2,4: 11011 The same mask 01010 can support multiple scenarios such as traffic lights or switches that toggle opposite settings.\n3. Control Flow\r3.1 if statements\rThe program evaluates conditions sequentially and executes only the first matching block.\nscore := 60 if score \u0026gt;= 90 { fmt.Println(\u0026#34;Outstanding\u0026#34;) } else if score \u0026gt;= 80 { fmt.Println(\u0026#34;Excellent\u0026#34;) } else if score \u0026gt;= 70 { fmt.Println(\u0026#34;Good\u0026#34;) } else if score \u0026gt;= 60 { fmt.Println(\u0026#34;Pass\u0026#34;) } else { fmt.Println(\u0026#34;Fail\u0026#34;) } if score1 := 80; score1 \u0026gt;= 90 { fmt.Println(\u0026#34;Outstanding\u0026#34;) } else if score1 \u0026gt;= 80 { fmt.Println(\u0026#34;Excellent\u0026#34;) } else if score1 \u0026gt;= 70 { fmt.Println(\u0026#34;Good\u0026#34;) } else if score1 \u0026gt;= 60 { fmt.Println(\u0026#34;Pass\u0026#34;) } else { fmt.Println(\u0026#34;Fail\u0026#34;) } fmt.Println(strconv.Itoa(score)) Output:\nPass Excellent 80 3.2 for loops\rvar str = \u0026#34;hello world\u0026#34; for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) } fmt.Println() i := 0 for i \u0026lt; len(str) { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } fmt.Println() i = 0 for { if i \u0026gt;= len(str) { break } fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } Output:\nh e l l o w o r l d h e l l o w o r l d h e l l o w o r l d 3.3 for range (key/value loop)\rtext := \u0026#34;‰Ω†Â•Ω,program\u0026#34; for k, v := range text { fmt.Printf(\u0026#34;k=%v,v=%c\\n\u0026#34;, k, v) } Output:\nk=0,v=‰Ω† k=3,v=Â•Ω k=6,v=, k=7,v=p k=8,v=r k=9,v=o k=10,v=g k=11,v=r k=12,v=a k=13,v=m 3.4 switch\u0026hellip;case\rswitch is typically used for enums or discrete choices.\nvar week = 3 switch week { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } switch week1 := 0; week1 { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } switch num := 10; num { case 0, 2, 4, 6, 8, 10: fmt.Println(\u0026#34;Even\u0026#34;) case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;Odd\u0026#34;) } score := 80 switch { case score \u0026gt;= 90: fmt.Println(\u0026#34;Outstanding\u0026#34;) case score \u0026gt;= 80: fmt.Println(\u0026#34;Excellent\u0026#34;) case score \u0026gt;= 70: fmt.Println(\u0026#34;Good\u0026#34;) case score \u0026gt;= 60: fmt.Println(\u0026#34;Pass\u0026#34;) default: fmt.Println(\u0026#34;Fail\u0026#34;) } Output:\nWednesday Unknown Even Excellent Go‚Äôs switch/case automatically breaks after executing a matching case. Use fallthrough to continue to the next case.\nswitch week1 := 5; week1 { case 1: fmt.Println(\u0026#34;Monday\u0026#34;) case 2: fmt.Println(\u0026#34;Tuesday\u0026#34;) case 3: fmt.Println(\u0026#34;Wednesday\u0026#34;) case 4: fmt.Println(\u0026#34;Thursday\u0026#34;) case 5: fmt.Println(\u0026#34;Friday\u0026#34;) fallthrough case 6: fmt.Println(\u0026#34;Saturday\u0026#34;) case 7: fmt.Println(\u0026#34;Sunday\u0026#34;) default: fmt.Println(\u0026#34;Unknown\u0026#34;) } Output:\nFriday Saturday 3.5 break, continue, goto\rbreak exits the current loop. continue skips to the next iteration. goto jumps to a labeled statement. lable1: for i := 0; i \u0026lt;= 3; i++ { if i == 0 { continue } if i == 1 { continue lable1 } fmt.Printf(\u0026#34;i=%d \\n\u0026#34;, i) } lable2: for j := 0; j \u0026lt;= 3; j++ { if j == 3 { fmt.Printf(\u0026#34;break loop\\n\u0026#34;) break } if j == 1 { break lable2 } fmt.Printf(\u0026#34;j=%d \\n\u0026#34;, j) } i := 0 lable3: fmt.Println(\u0026#34;statement 1\u0026#34;) i++ if i == 2 { goto lable5 } goto lable4 fmt.Println(\u0026#34;statement 2\u0026#34;) lable4: fmt.Println(\u0026#34;statement 3\u0026#34;) goto lable3 lable5: fmt.Println(\u0026#34;statement 4\u0026#34;) Output:\ni=2 i=3 j=0 statement 1 statement 3 statement 1 statement 4 ","date":"2025-01-01T11:03:08+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-04/","title":"Golang Learning Journey [Part 4: Operators \u0026 Control Flow]"},{"content":"1. Overview\rGo data types are split into basic types and composite types.\nBasic types include integers, floating-point numbers, booleans, and strings. Composite types include arrays, slices, structs, functions, maps, channels, interfaces, etc.\n2. Basic Data Types\r2.1 Integers\rType Range Size Signed? int8 $-2^7$~$2^7-1$ 1 byte Yes int16 $-2^{15}$~$2^{15}-1$ 2 bytes Yes int32 $-2^{31}$~$2^{31}-1$ 4 bytes Yes int64 $-2^{63}$~$2^{63}-1$ 8 bytes Yes uint8 $0$~$2^8-1$ 1 byte No uint16 $0$~$2^{16}-1$ 2 bytes No uint32 $0$~$2^{32}-1$ 4 bytes No uint64 $0$~$2^{64}-1$ 8 bytes No Special integer types:\nType Description uint 32-bit on 32-bit OS, 64-bit on 64-bit OS int 32-bit on 32-bit OS, 64-bit on 64-bit OS uintptr Unsigned integer used to store pointer values Example:\nvar ( num1 int = 666 num2 uint = 666 num3 int8 = math.MaxInt8 num4 int16 = math.MaxInt16 num5 int32 = math.MaxInt32 num6 int64 = math.MaxInt64 num7 uint8 = math.MaxUint8 num8 uint16 = math.MaxUint16 num9 uint32 = math.MaxUint32 num10 uint64 = math.MaxUint64 ) fmt.Println(num1, num2, num3, num4, num5, num6, num7, num8, num9, num10) Output:\n666 666 127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615 2.2 Floating-point numbers\rGo provides float32 and float64 following IEEE 754. On 32-bit systems the default is float32; on 64-bit systems it is float64.\nfloat32: range of -3.4e38 to 3.4e38, uses 4 bytes float64: range of -1.8e308 to 1.8e308, uses 8 bytes var num1 float32 = 1.06 num2 := 3.1415926 fmt.Printf(\u0026#34;Exact: %v; default 6 decimals: %f; fixed 3 decimals: %0.3f \\n\u0026#34;, num1, num2, num2) var ( num3 float32 = 3.1415926 num4 float64 = 1.113 num5 = 3.14e2 num6 = 3.14e-2 ) fmt.Println(num3, num4, num5, num6) Output:\nExact: 1.06; default 6 decimals: 3.141593; fixed 3 decimals: 3.142 3.1415925 1.113 314 0.0314 2.3 Booleans\rbool only has two values: true and false. Uninitialized booleans default to false.\nvar ( bool1 bool bool2 = true ) fmt.Println(bool1, bool2) Output:\nfalse true 2.4 Characters\rCharacters are single values and are represented as ints. Go exposes them via byte (ASCII) and rune (UTF-8).\nbyte: an alias for int representing ASCII values rune: an alias for int representing UTF-8 code points Note: UTF-8 is the universal encoding that extends ASCII to cover characters from multiple languages.\nvar a = \u0026#39;A\u0026#39; fmt.Printf(\u0026#34;ASCII: %v; Char: %c \\n\u0026#34;, a, a) var ( b = \u0026#39;B\u0026#39; c = \u0026#39;‰Ω†\u0026#39; d = \u0026#34;this\u0026#34; ) fmt.Printf(\u0026#34;%c,%c,%c,%c,%c,%c\u0026#34;, b, c, d[0], d[1], d[2], d[3]) Output:\nASCII: 65; Char: A B,‰Ω†,t,h,i,s 2.4 Strings\r2.4.1 Common definitions\rvar val1 string = \u0026#34;hello world\u0026#34; var val2 = \u0026#34;‰Ω†Â•Ω go\u0026#34; val3 := \u0026#34;Good\u0026#34; fmt.Println(val1, val2, val3) fmt.Println(len(val2)) var info = `ÂßìÂêçÔºöÂº†‰∏â Âπ¥ÈæÑÔºö18` fmt.Println(info) Output:\nhello world ‰Ω†Â•Ω go Good 9 ÂßìÂêçÔºöÂº†‰∏â Âπ¥ÈæÑÔºö18 In strings, ASCII letters occupy one byte and Chinese characters occupy three bytes. Use len to get the byte length.\n2.4.2 Escape characters\rEscape sequences start with \\. Common ones include:\n\\r: carriage return (moves to the beginning of the line) \\n: newline (moves to the next line) \\t: tab (helps align output) \\': single quote \\\u0026quot;: double quote \\\\: backslash var val1 string = \u0026#34;hello\\r\u0026#34; var val2 string = \u0026#34;world\\n\u0026#34; var val3 string = \u0026#34;hello world\\t\u0026#34; var val4 string = \u0026#34;\u0026#39;hello\u0026#39; \\\\ \\\u0026#34;world\\\u0026#34;\u0026#34; fmt.Println(val1, val2, val3, val4) Output:\nworld hello world \u0026#39;hello\u0026#39; \\ \u0026#34;world\u0026#34; 2.4.3 Common string methods\rMost method names are intuitive and shared across languages.\nMethod Description len length + or fmt.Sprint concatenation strings.Split split string strings.Contains check substring strings.HasPrefix / HasSuffix prefix/suffix test strings.Index / LastIndex find substring index strings.Join join slice into string strings.ToLower lowercase strings.ToUpper uppercase Example:\nvar val = \u0026#34;Hello World\u0026#34; length := len(val) fmt.Printf(\u0026#34;%s length: %d\\n\u0026#34;, val, length) str1 := val + \u0026#34;Â∞èÊòé\u0026#34; str2 := fmt.Sprint(val, \u0026#34;Â∞èÁ∫¢\u0026#34;) fmt.Printf(\u0026#34;+ concat: %s; Sprint concat: %s \\n\u0026#34;, str1, str2) splitVal := strings.Split(val, \u0026#34; \u0026#34;) newStr := strings.Join(splitVal, \u0026#34;,\u0026#34;) fmt.Printf(\u0026#34;split: %v; Join result: %s \\n\u0026#34;, splitVal, newStr) bool1 := strings.Contains(val, \u0026#34;Hello\u0026#34;) bool2 := strings.Contains(val, \u0026#34;olleH\u0026#34;) fmt.Printf(\u0026#34;contains Hello: %v; contains olleH: %v \\n\u0026#34;, bool1, bool2) bool3 := strings.HasPrefix(val, \u0026#34;He\u0026#34;) bool4 := strings.HasPrefix(val, \u0026#34;llo\u0026#34;) bool5 := strings.HasSuffix(val, \u0026#34;World\u0026#34;) bool6 := strings.HasSuffix(val, \u0026#34;Wor\u0026#34;) fmt.Printf(\u0026#34;prefix He: %v; prefix llo: %v; suffix World: %v; suffix Wor: %v \\n\u0026#34;, bool3, bool4, bool5, bool6) index1 := strings.Index(val, \u0026#34;o\u0026#34;) index2 := strings.LastIndex(val, \u0026#34;o\u0026#34;) index3 := strings.Index(val, \u0026#34;a\u0026#34;) fmt.Printf(\u0026#34;o first index: %v; o last index: %v; a index: %v\\n\u0026#34;, index1, index2, index3) str3 := strings.ToLower(val) str4 := strings.ToUpper(val) fmt.Printf(\u0026#34;lower: %v; upper: %v\\n\u0026#34;, str3, str4) Output:\nHello World length: 11 + concat: Hello WorldÂ∞èÊòé; Sprint concat: Hello WorldÂ∞èÁ∫¢ split: [Hello World]; Join result: Hello,World contains Hello: true; contains olleH: false prefix He: true; prefix llo: false; suffix World: true; suffix Wor: false o first index: 4; o last index: 7; a index: -1 lower: hello world; upper: HELLO WORLD Tip: len, split, contains, prefix, suffix, index, join, lower, upper have similar meanings across languages. Learning one makes the rest easier.\n2.4.4 Mutating a string via slices\rvar val1 = \u0026#34;hello xioaming\u0026#34; byteStr := []byte(val1) byteStr[0] = \u0026#39;a\u0026#39; fmt.Println(string(byteStr)) var val2 = \u0026#34;‰Ω†Â•ΩÂ∞èÊòé\u0026#34; runeStr := []rune(val2) runeStr[0] = \u0026#39;Êàë\u0026#39; fmt.Println(string(runeStr)) Output:\naello xioaming ÊàëÂ•ΩÂ∞èÊòé 3. Type Conversion\rNumeric conversion goes both ways: low-precision to high-precision and vice versa. Warning: converting from high to low precision can drop data because of differences in range.\n3.1 Integer-to-integer conversions\rvar a int8 = 127 b := int64(a) fmt.Printf(\u0026#34;a=%v, type: %T\\tb=%v, type: %T \\n\u0026#34;, a, a, b, b) var c int64 = 127 d := int16(c) fmt.Printf(\u0026#34;c=%v, type: %T\\td=%v, type: %T \\n\u0026#34;, c, c, d, d) Output:\na=127, type: int8 b=127, type: int64 c=127, type: int64 d=127, type: int16 3.2 Floating-point and integer conversions\rvar e int16 = 256 f := float32(e) fmt.Printf(\u0026#34;e=%v, type: %T\\tf=%v, type: %T \\n\u0026#34;, e, e, f, f) var g float64 = 3.145 h := int16(g) fmt.Printf(\u0026#34;g=%v, type: %T\\th=%v, type: %T \\n\u0026#34;, g, g, h, h) Output:\ne=256, type: int16 f=256, type: float32 g=3.145, type: float64 h=3, type: int16 3.3 Other type to string conversion via fmt\rvar ( intV = 123 floatV = 3.145 boolV = true charV = \u0026#39;A\u0026#39; ) str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, intV) str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, floatV) str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, boolV) str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, charV) fmt.Println(str1, str2, str3, str4) Output:\n123 3.145000 true A 3.4 strconv helpers\r3.4.1 strconv.Atoi and strconv.Itoa\rTip: in Itoa the leading i stands for int -\u0026gt; string. In Atoi the trailing i stands for string -\u0026gt; int.\nvar str = \u0026#34;123\u0026#34; num1, _ := strconv.Atoi(str) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, num1, num1) var num2 int64 = 456 str2 := strconv.Itoa(int(num2)) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str2, str2) Output:\nvalue: 123 type: int value: 456 type: string 3.4.2 strconv.ParseX functions\rstrconv.Parse performs conversions only if the source is valid.\nvar ( str1 = \u0026#34;256\u0026#34; str2 = \u0026#34;3.145\u0026#34; str3 = \u0026#34;true\u0026#34; ) num1, _ := strconv.ParseInt(str1, 10, 0) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, num1, num1) num2, _ := strconv.ParseFloat(str2, 32) fmt.Printf(\u0026#34;value: %0.3f\\ttype: %T\\n\u0026#34;, num2, num2) boo, _ := strconv.ParseBool(str3) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, boo, boo) Output:\nvalue: 256 type: int64 value: 3.145 type: float64 value: true type: bool 3.4.3 strconv.FormatX functions\rvar ( intV = 123 floatV = 3.145e2 booV = true ) str1 := strconv.FormatInt(int64(intV), 10) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str1, str1) str2 := strconv.FormatFloat(floatV, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str2, str2) str3 := strconv.FormatBool(booV) fmt.Printf(\u0026#34;value: %v\\ttype: %T\\n\u0026#34;, str3, str3) Output:\nvalue: 123 type: string value: 314.5 type: string value: true type: string 3.4.4 Other helpers\rstrconv also includes helpers like Append (to append to byte slices), IsPrint, IsGraphic, Quote, Unquote, and CanBackquote. Study them when needed; this reference is handy.\n","date":"2024-12-21T19:37:51+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-03/","title":"Golang Learning Journey [Part 3: Basic Data Types and Type Conversion]"},{"content":" Preface: Packages in Go are collections of functionality provided either by the standard library or by custom code. You need to import a package before using it‚Äîfor today we focus on the fmt package, imported with import \u0026quot;fmt\u0026quot;.\n1. fmt Package\rThe fmt package is a widely used standard library module that handles formatted I/O, similar to printf and scanf in C. It lets you read input and display formatted data to stdout or to other writers.\n1.1 Printing\rPrinting in Go is handled by functions whose names start with Print. Print writes without inserting a newline, Println appends a newline, and Printf allows formatted printing.\n1.1.1 fmt.Print\r// package declaration: think of it as a folder package main // import statement: bring in the fmt package import \u0026#34;fmt\u0026#34; // main function: entry point func main() { fmt.Print(\u0026#39;C\u0026#39;) // prints a rune; single quotes are flexible fmt.Print(\u0026#34;a\u0026#34;) // prints a string fmt.Print(\u0026#34;Hello World\u0026#34;) // prints a string in double quotes fmt.Print(123) // prints an integer fmt.Print(3.1415926) // prints a float fmt.Print(true) // prints a boolean } Output:\n67aHello World1233.1415926true Summary: Print can print anything. Note that 'C' prints the ASCII value 67 because single quotes denote a rune literal; double quotes produce a string. Writing 'ABC' would trigger the error more than one character in rune literal because rune literals must be a single character.\n1.1.2 fmt.Println\rIf you switch to Println, each call adds a newline. From now on only the relevant code is shown.\nfmt.Println(\u0026#39;C\u0026#39;) fmt.Println(\u0026#34;a\u0026#34;) fmt.Println(\u0026#34;Hello World\u0026#34;, \u0026#34;‰Ω†Â•Ω\u0026#34;) fmt.Println(123) fmt.Println(3.1415926) fmt.Println(true) Result:\n67 a Hello World ‰Ω†Â•Ω 123 3.1415926 true 1.1.3 fmt.Printf\rPrintf allows you to control the formatting with verbs. Common verbs:\nVerb Description Importance (personal view) %T print the variable type high %v print with the default format high %t print true/false high %b print binary high %c print the Unicode character low %d print decimal high %o print octal high %x print lowercase hexadecimal high %X print uppercase hexadecimal low %U Unicode format low %f decimal floating-point high %e scientific notation with lowercase e low %E scientific notation with uppercase E low %g automatically choose %f or %e high %s plain string high %q double-quoted string or character low %p pointer address low Example:\nfmt.Printf(\u0026#34;Boolean value: %t \\n\u0026#34;, false) fmt.Printf(\u0026#34;Unicode 65: %c \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Default format 65: %v \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Binary 65: %b \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Decimal 65: %d \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Octal 65: %o \\n\u0026#34;, 65) fmt.Printf(\u0026#34;Hex (lower) 1024: %x \\n\u0026#34;, 1024) fmt.Printf(\u0026#34;Hex (upper) 1024: %X \\n\u0026#34;, 1024) fmt.Printf(\u0026#34;\u0026#39;C\u0026#39; Unicode: %U \\n\u0026#34;, \u0026#39;C\u0026#39;) fmt.Printf(\u0026#34;Float: %f \\n\u0026#34;, 3.1415926) fmt.Printf(\u0026#34;Scientific (lower): %e \\n\u0026#34;, 3.1415926) fmt.Printf(\u0026#34;Scientific (upper): %E \\n\u0026#34;, 3.1415926) Output:\nBoolean value: false Unicode 65: A Default format 65: 65 Binary 65: 1000001 Decimal 65: 65 Octal 65: 101 Hex (lower) 1024: 400 Hex (upper) 1024: 400 \u0026#39;C\u0026#39; Unicode: U+0043 Float: 3.141593 Scientific (lower): 3.141593e+00 Scientific (upper): 3.141593E+00 1.2 Input (Scan)\rScan captures raw input; the f suffix (ScanF) enables formatting.\n1.2.1 fmt.Scan\rExample:\nvar name string var age int fmt.Print(\u0026#34;ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºö\u0026#34;) fmt.Scan(\u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) Result:\nËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â 18 name=Âº†‰∏â,age=18 1.2.2 fmt.Scanf\rExample:\nvar name string var age int fmt.Print(\u0026#34;ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºö\u0026#34;) fmt.Scanf(\u0026#34;%s %d\u0026#34;, \u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) Run several times to see Go\u0026rsquo;s flexibility for beginners:\nPS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â name=Âº†‰∏â,age=0 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â 18 name=Âº†‰∏â,age=18 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â ÊùéÂõõ name=Âº†‰∏â,age=0 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â ÊùéÂõõ 18 name=Âº†‰∏â,age=0 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºöÂº†‰∏â 18 ÊùéÂõõ name=Âº†‰∏â,age=18 PS F:\\go_project\u0026gt; go run main.go ËØ∑ËæìÂÖ•ÂßìÂêçÂíåÂπ¥ÈæÑÔºö18 Âº†‰∏â name=18,age=0 PS F:\\go_project\u0026gt; 2. Variables\rVariables are containers for data and can hold any type of value. Variable names must consist of letters, digits, and underscores, and cannot start with a digit. Keywords and reserved words cannot be used as variable names.\n2.1 Variable declaration\rDeclare a variable by defining it. Several options exist:\nvar a string var b = \u0026#34;Âº†‰∏â\u0026#34; fmt.Printf(\u0026#34;a=%v,b=%v\u0026#34;, a, b) Output:\na=,b=Âº†‰∏â Default values:\nvar a string var b int var c bool var d float32 fmt.Printf(\u0026#34;a=%v, b=%v, c=%v, d=%v\u0026#34;, a, b, c, d) Output:\na=, b=0, c=false, d=0 Tip: Declared variables must be used; otherwise Go reports declared and not used.\n2.2 Initialization and assignment\rvar name string name = \u0026#34;Âº†‰∏â\u0026#34; var age = 18 sex := \u0026#34;Áî∑\u0026#34; score := 80 fmt.Print(name, age, sex, score) Result:\nÂº†‰∏â18Áî∑80 2.2 Declaring multiple variables\rvar a1, a2, a3 string a1 = \u0026#34;Âº†‰∏â\u0026#34; a2 = \u0026#34;ÊùéÂõõ\u0026#34; a3 = \u0026#34;Áéã‰∫î\u0026#34; fmt.Println(a1, a2, a3) var ( name string age int ) name = \u0026#34;ËµµÂÖ≠\u0026#34; age = 20 fmt.Println(name, age) var ( num1 = 1 num2 = 2 ) fmt.Println(num1, num2) num3, num4, num5 := 3, 4, \u0026#34;Hello\u0026#34; fmt.Println(num3, num4, num5) Result (Println automatically adds spaces and a newline):\nÂº†‰∏â ÊùéÂõõ Áéã‰∫î ËµµÂÖ≠ 20 1 2 3 4 Hello var is used for global definitions, while := can only be used locally.\n2.3 Anonymous variables\rAnonymous variables discard values using _ and do not occupy namespace.\nExample:\npackage main import \u0026#34;fmt\u0026#34; func getUserInfo() (string, int) { return \u0026#34;zhangsan\u0026#34;, 10 } func main() { var name, age = getUserInfo() fmt.Println(name, age) var _, age1 = getUserInfo() fmt.Println(age1) var name1, _ = getUserInfo() fmt.Println(name1) } Result:\nzhangsan 10 10 zhangsan Anonymous variables can be reused because they do not reserve names, but using var or := requires unique names.\n3. Constants\rVariables change over time; constants never do. Use const to declare them.\n3.1 Declaring constants\rconst A = \u0026#34;TEST1\u0026#34; fmt.Println(A) const ( B = \u0026#34;TEST2\u0026#34; C = \u0026#34;TEST3\u0026#34; D = \u0026#34;TEST4\u0026#34; ) fmt.Println(B, C, D) const ( E = \u0026#34;TEST5\u0026#34; F G H = \u0026#34;TEST6\u0026#34; I ) fmt.Println(E, F, G, H, I) Output:\nTEST1 TEST2 TEST3 TEST4 TEST5 TEST5 TEST5 TEST6 TEST6 3.2 iota counter\riota is a counter used together with const.\nconst ( n1 = iota n2 _ n3 n4 = iota n5 n6 = 100 n7 = iota n8, n9, n10 = iota, iota, iota + 1 ) fmt.Println(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10) Output:\n0 1 3 4 5 100 7 8 8 9 4. Summary: Variable and constant naming rules\rVariable names may contain letters, digits, and underscores. Identifiers cannot begin with a digit. Identifiers cannot be reserved keywords (var, if, for, etc.). Names are case-sensitive: name, Name, NAme, and NAME are different. Choose descriptive names. CamelCase is preferred; for example maxAge. Acronyms such as DNS or IP can stay uppercase. ","date":"2024-12-21T19:36:53+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-02/","title":"Golang Learning Journey [Part 2: fmt Package and Variables/Constants]"},{"content":" Preface: Go (also called Golang) is an open-source programming language developed by Google and first released publicly in 2009. It aims to provide concise, efficient, and reliable tools for software development. Golang is statically typed and compiled, and it is expressive thanks to its concurrency features. Programs written in Go can make very effective use of multi-core and networked computers, and its novel type system keeps the code modular and flexible. Compiling Go code to machine code is fast, and the language also offers convenient garbage collection plus a powerful reflection runtime.\nNotes from this journey: I will supplement this section after finishing the lessons.\n1. Learning Resources\rChinese documentation: https://go.p2hp.com/ „ÄêNot recommended‚Äîlagging behind the official docs„Äë\nOfficial documentation: https://go.dev/ „ÄêRecommended‚Äîthe latest, in English„Äë\nPractice while learning: Chinese tour | English tour\nBilibili study video\n2. Installing Go on Windows\r2.1 Installation\rFollow the screenshots below step by step: Click the arrow to download the installer and follow the prompts. Note: Developers typically avoid installing the newest release because it may have bugs, but the latest version is fine for learning. Double-click the downloaded go1.23.4.windows-amd64.msi file to install.\n2.2 Verification\rWindows environment variables tutorial You can also verify the Go installation via commands:\nPress Win + R, type cmd, and press Enter. Run the following commands:\n# Go version go version # Go environment go env Tip: If you accidentally left-click and see the terminal highlighted (pay attention to the selection indicator in the top-left), the cmd window is paused. Right-click to release and continue. 3. Development Environment‚ÄîVsCode\r3.1 Installing VsCode\rDownload VsCode After downloading, extract the archive and be sure to click ‚ÄúExtract‚Äù or ‚ÄúExtract to \u0026quot;VsCode-win***\u0026quot;‚Äù; otherwise the files scatter across the current directory. Place the extracted folder anywhere you like on your chosen drive.\nClick ‚ÄúExtract‚Äù to proceed: Put a shortcut on the desktop. Open the software and review the quick overview. 3.2 Install Extensions\r3.2.1 Language localization extension\r3.2.2 Go extension\rInstall the Go extension in the same way. 4. Hello World Walkthrough\r4.1 Create the project\rOpen the project folder in VsCode. When prompted, trust the author. 4.2 Create the project file\r4.3 Write the Hello World program\r// package declaration: Think of it as a folder package main // import: usually brings in standard library or custom packages import \u0026#34;fmt\u0026#34; // main function: the entry point func main() { // Print the Hello World string; semicolons are optional fmt.Println(\u0026#34;Hello World\u0026#34;) } 4.4 Fix VsCode code suggestions\rOpen a cmd terminal and configure the Go proxy:\ngo env -w GOPROXY=https://goproxy.io/ Restart VsCode a few times until the tools finish installing and code completion works. 4.5 Run the program\rOpen a terminal (it is just the Windows cmd window) and run the Go file:\n# run a Go file go run main.go # output # Hello World 4.6 Build the executable\r# compile the Go file into an executable go build main.go After the build you can double-click the exe to run it. Tip: The program exits immediately after finishing, so the terminal window closes at once, which makes it look like nothing happened.\n","date":"2024-12-21T10:51:49+08:00","permalink":"https://zg-dd.github.io/en/stu/golang-stu-01/","title":"Golang Learning Journey [Part 1: Getting Started]"},{"content":"show-busy-java-threads.sh\n#!/bin/bash # @Function # Find out the highest cpu consumed threads of java, and print the stack of these threads. # # @Usage # $ ./show-busy-java-threads.sh # # @author Jerry Lee # javaÁõÆÂΩï JAVA_HOME=/usr/local/java/jdk1.8.0_202 readonly PROG=`basename $0` readonly -a COMMAND_LINE=(\u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34;) usage() { cat \u0026lt;\u0026lt;EOF Usage: ${PROG} [OPTION]... Find out the highest cpu consumed threads of java, and print the stack of these threads. Example: ${PROG} -c 10 Options: -p, --pid find out the highest cpu consumed threads from the specifed java process, default from all java process. -c, --count set the thread count to show, default is 5 -h, --help display this help and exit EOF exit $1 } readonly ARGS=`getopt -n \u0026#34;$PROG\u0026#34; -a -o c:p:h -l count:,pid:,help -- \u0026#34;$@\u0026#34;` [ $? -ne 0 ] \u0026amp;\u0026amp; usage 1 eval set -- \u0026#34;${ARGS}\u0026#34; while true; do case \u0026#34;$1\u0026#34; in -c|--count) count=\u0026#34;$2\u0026#34; shift 2 ;; -p|--pid) pid=\u0026#34;$2\u0026#34; shift 2 ;; -h|--help) usage ;; --) shift break ;; esac done count=${count:-5} redEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;31m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } yellowEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;33m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } blueEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;36m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } # Check the existence of jstack command! if ! which jstack \u0026amp;\u0026gt; /dev/null; then [ -z \u0026#34;$JAVA_HOME\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH!\u0026#34; exit 1 } ! [ -f \u0026#34;$JAVA_HOME/bin/jstack\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH and $JAVA_HOME/bin/jstack file does NOT exists!\u0026#34; exit 1 } ! [ -x \u0026#34;$JAVA_HOME/bin/jstack\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH and $JAVA_HOME/bin/jstack is NOT executalbe!\u0026#34; exit 1 } export PATH=\u0026#34;$JAVA_HOME/bin:$PATH\u0026#34; fi readonly uuid=`date +%s`_${RANDOM}_$$ cleanupWhenExit() { rm /tmp/${uuid}_* \u0026amp;\u0026gt; /dev/null } trap \u0026#34;cleanupWhenExit\u0026#34; EXIT printStackOfThreads() { local line local count=1 while IFS=\u0026#34; \u0026#34; read -a line ; do local pid=${line[0]} local threadId=${line[1]} local threadId0x=\u0026#34;0x`printf %x ${threadId}`\u0026#34; local user=${line[2]} local pcpu=${line[4]} local jstackFile=/tmp/${uuid}_${pid} [ ! -f \u0026#34;${jstackFile}\u0026#34; ] \u0026amp;\u0026amp; { { if [ \u0026#34;${user}\u0026#34; == \u0026#34;${USER}\u0026#34; ]; then jstack ${pid} \u0026gt; ${jstackFile} else if [ $UID == 0 ]; then sudo -u ${user} jstack ${pid} \u0026gt; ${jstackFile} else redEcho \u0026#34;[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}).\u0026#34; redEcho \u0026#34;User of java process($user) is not current user($USER), need sudo to run again:\u0026#34; yellowEcho \u0026#34; sudo ${COMMAND_LINE[@]}\u0026#34; echo continue fi fi } || { redEcho \u0026#34;[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}).\u0026#34; echo rm ${jstackFile} continue } } blueEcho \u0026#34;[$((count++))] Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}):\u0026#34; sed \u0026#34;/nid=${threadId0x} /,/^$/p\u0026#34; -n ${jstackFile} done } ps -Leo pid,lwp,user,comm,pcpu --no-headers | { [ -z \u0026#34;${pid}\u0026#34; ] \u0026amp;\u0026amp; awk \u0026#39;$4==\u0026#34;java\u0026#34;{print $0}\u0026#39; || awk -v \u0026#34;pid=${pid}\u0026#34; \u0026#39;$1==pid,$4==\u0026#34;java\u0026#34;{print $0}\u0026#39; } | sort -k5 -r -n | head --lines \u0026#34;${count}\u0026#34; | printStackOfThreads ","date":"2024-09-10T13:48:55+08:00","permalink":"https://zg-dd.github.io/en/blog/java-high-cpu-threads/","title":"Java High-CPU Thread Diagnosis Script"},{"content":" Byte Buddy is a bytecode enhancer for Java, an elegant runtime Java code generation library that should be used with caution.\nDocumentation: http://bytebuddy.net/#/tutorial\n1. Introducing ByteBuddy\r\u0026lt;!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.bytebuddy\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;byte-buddy\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.14.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2. Learning ByteBuddy\r2.1 Class Creation\rAny instance creation starts with an instance of ByteBuddy.\nDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() .subclass(Object.class) // Enhancement method: Generate subclass of target class .name(\u0026#34;example.Type\u0026#34;) // Custom generated class name: package name + class name .make(); // Compile and generate the class 2.2 Specifying Package Name for Class\rDynamicType.Unloaded\u0026lt;?\u0026gt; dynamicType = byteBuddy .with(new NamingStrategy.AbstractBase() { @Override protected String name(TypeDescription superClass) { return \u0026#34;example.\u0026#34; + superClass.getSimpleName(); // Customizable package name and type } }) .subclass(Object.class) .make(); 2.3 Saving Classes\rDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() dynamicType.saveIn(new File(\u0026#34;file path\u0026#34;)); // Save the class file to folder 2.4 Injecting Classes\rDynamically generated classes can be injected into a specified jar file.\nDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() dynamicType.inject(new File(\u0026#34;jar\u0026#34;)); // Inject the class file into the jar package 2.5 ByteBuddy Enhancement Methods\rByteBuddy has three enhancement methods:\nsubclass: Generates a subclass for the target class to enhance it rebase: When rebasing a type, Byte Buddy preserves all implementations of the rebased class. Byte Buddy copies all method implementations with compatible signatures as private renamed methods, unlike redefinition which discards overridden methods. With this approach, no method implementations are lost, and rebased methods can call these renamed methods (though this currently does not appear to work). redefine: Redefines methods, replacing existing method implementations. 2.6 Class Loading Strategies\rClassLoadingStrategy.Default defines built-in strategies. If none is selected, the system will automatically deduce a strategy.\nWRAPPER Strategy: 1. Creates a new ClassLoader to load dynamically generated types. 2. Suitable for most cases, as the dynamic classes won\u0026#39;t be loaded by ApplicationClassLoader, which won\u0026#39;t affect classes already in the project. WRAPPER_PERSISTENT: Same as WRAPPER, but exposes the byte arrays representing the classes via ClassLoader.getResourceAsStream(String). For this purpose, all class files are persisted as byte arrays in the wrapper class loader. CHILD_FIRST: Creates a child-first loading ClassLoader, breaking the parent delegation model. CHILD_FIRST_PERSISTENT: Same as CHILD_FIRST, but exposes the byte arrays representing the classes via ClassLoader.getResourceAsStream(String). For this purpose, all class files are persisted as byte arrays in the wrapper class loader. INJECTION Strategy: Uses reflection to directly inject dynamically generated types into the current ClassLoader. 2.7 Runtime Instantiation\rDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() .subclass(Object.class) // Enhancement method: Generate subclass of target class .name(\u0026#34;example.Type\u0026#34;) // Custom generated class name: package name + class name .make(); // Compile and generate the class 2.8 Field and Method Declaration\rDynamicType.Unloaded\u0026lt;?\u0026gt; dynamicType = new ByteBuddy() // Enhancement method .subclass(Object.class) // Class name .name(\u0026#34;subclass.Example\u0026#34;) // Define field, type, visibility - Multiple can be used with | operator .defineField(\u0026#34;username\u0026#34;, String.class, Modifier.PUBLIC | Modifier.STATIC) // Define getter method .defineMethod(\u0026#34;getUserName\u0026#34;, String.class, Modifier.PUBLIC) .intercept(FieldAccessor.ofField(\u0026#34;username\u0026#34;)) // Get value of username property .make(); 2.9 FixedValue for Fixed Values\rFixedValue can declare any fixed value for field and method definitions. The fixed values will eventually be written to the constant pool of the class.\n2.10 ElementMatchers Element Selectors\rElementMatchers contains many matching rules for overriding original classes. Commonly used ones include:\nisDeclaredBy Matches all methods in a specific class named Specifies method name takesArguments Specifies number of arguments Example:\npublic class Foo { public String bar() { return null; } public String foo() { return null; } public String foo(Object o) { return null; } } // Building an implementation class DynamicType.Unloaded\u0026lt;?\u0026gt; dynamicType = new ByteBuddy() .with(new NamingStrategy.AbstractBase() { @Override protected String name(TypeDescription superClass) { return \u0026#34;subclass.subclass\u0026#34; + superClass.getSimpleName(); } }) .subclass(Foo.class) .method(ElementMatchers.isDeclaredBy(Foo.class)).intercept(FixedValue.value(\u0026#34;One!\u0026#34;)) .method(ElementMatchers.named(\u0026#34;foo\u0026#34;)).intercept(FixedValue.value(\u0026#34;Two!\u0026#34;)) .method(ElementMatchers.named(\u0026#34;foo\u0026#34;).and(ElementMatchers.takesArguments(1))) .intercept(FixedValue.value(\u0026#34;Three!\u0026#34;)) .make(); // The final generated class looks like: public class subclassFoo extends Foo { public String foo(Object var1) {return \u0026#34;Three!\u0026#34;;} public String foo() {return \u0026#34;Two!\u0026#34;;} public String bar() {return \u0026#34;One!\u0026#34;;} public subclassFoo() {} } In this example: The bar() method is matched only by ElementMatchers.isDeclaredBy(Foo.class), finally overriding to \u0026ldquo;One!\u0026rdquo; The foo() method is matched by both ElementMatchers.named(\u0026ldquo;foo\u0026rdquo;) and ElementMatchers.named(\u0026ldquo;foo\u0026rdquo;).and(ElementMatchers.takesArguments(1)), resulting in \u0026ldquo;Two!\u0026rdquo; foo(Object var1) is matched by ElementMatchers.named(\u0026ldquo;foo\u0026rdquo;).and(ElementMatchers.takesArguments(1)), overridden again to \u0026ldquo;Three!\u0026rdquo;\n2.11 MethodDelegation (Method Delegation)\rMethod delegation provides maximum freedom when responding to method calls. Methods in the Source can be delegated to Target method calls (the method names in Source and Target can be different); Note: All delegation methods must be declared as static\nSimple example:\n// Rebase target public class MemoryDatabase { public void hello(String name) { System.out.println(\u0026#34;MemoryDatabase.hello origin\u0026#34;); } public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load origin: \u0026#34; + info); return Arrays.asList(info, info); } } // Delegate class public class LoggerInterceptor { public static void hello(String name) { System.out.println(\u0026#34;LoggerInterceptor.hello \u0026#34; + name + \u0026#34;!\u0026#34;); } public static List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;LoggerInterceptor.load before\u0026#34;); try { // Parameter enhancement List\u0026lt;String\u0026gt; list = Arrays.asList(info + \u0026#34;: foo\u0026#34;, info + \u0026#34;: bar\u0026#34;); System.out.println(\u0026#34;LoggerInterceptor.load after\u0026#34;); return list; } finally { System.out.println(\u0026#34;LoggerInterceptor.load finally\u0026#34;); } } } // Test method MemoryDatabase loggingDatabase = new MemoryDatabase(); loggingDatabase.hello(\u0026#34;hello MemoryDatabase\u0026#34;); System.out.println(\u0026#34;MemoryDatabase.load return value: \u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); // Delegate specified methods of MemoryDatabase class new ByteBuddy() .redefine(MemoryDatabase.class) .method(named(\u0026#34;hello\u0026#34;)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .method(named(\u0026#34;load\u0026#34;)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .make() .load(MemoryDatabase.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent()) // ClassReloadingStrategy.fromInstalledAgent() indicates using agent to modify source method .getLoaded(); System.out.println(\u0026#34;After rebasing...\u0026#34;); loggingDatabase = new MemoryDatabase(); loggingDatabase.hello(\u0026#34;hello MemoryDatabase\u0026#34;); System.out.println(\u0026#34;MemoryDatabase.load return value: \u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); // Execution results: MemoryDatabase.hello origin MemoryDatabase.load origin: hello MemoryDatabase MemoryDatabase.load return value: [hello MemoryDatabase, hello MemoryDatabase] After rebasing... LoggerInterceptor.hello hello MemoryDatabase! LoggerInterceptor.load before LoggerInterceptor.load after LoggerInterceptor.load finally MemoryDatabase.load return value: [hello MemoryDatabase: foo, hello MemoryDatabase: bar] This simple example shows that method delegation can completely replace the original methods, performing rebasing modifications. It plays an important role in modifying source code. Note: subclass enhances the parent class without affecting the source class, while redefine and rebase require agent permissions and need to add VM parameter before starting the class loader: -javaagent:path\\byte-buddy-agent-1.14.17.jar. byte-buddy-agent refers to the code jar file, which can be downloaded online. Let\u0026rsquo;s begin learning various scenarios of method delegation:\n@SuperCall\npublic class MemoryDatabase { public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load origin: \u0026#34; + info); return Arrays.asList(info, info); } } public class LoggerInterceptor { public static List\u0026lt;String\u0026gt; log(@SuperCall Callable\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; zuper) { System.out.println(\u0026#34;LoggerInterceptor.log before\u0026#34;); try { // Parameter enhancement List\u0026lt;String\u0026gt; call = zuper.call(); System.out.println(\u0026#34;LoggerInterceptor.log after\u0026#34;); return call; } catch (Exception e) { throw new RuntimeException(e); } finally { System.out.println(\u0026#34;LoggerInterceptor.log finally\u0026#34;); } } } // Test: MemoryDatabase loggingDatabase = new ByteBuddy() .subclass(MemoryDatabase.class) .method(isDeclaredBy(MemoryDatabase.class)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .make() .load(MemoryDatabase.class.getClassLoader()) .getLoaded().newInstance(); System.out.println(\u0026#34;MemoryDatabase.load return value: \u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); In the above example, MemoryDatabase.load is delegated to LoggerInterceptor.log; @SuperCall indicates this is a proxy method, referring to MemoryDatabase.load. Callable\u0026lt;List\u0026gt; represents the return type of the load method. This approach is essentially how Spring AOP works.\n@Super\npublic class MemoryDatabase { public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load origin: \u0026#34; + info); return Arrays.asList(info, info); } } public class LoggerInterceptor { // info represents method parameter, zuper annotated with @Super indicates proxy object public static List\u0026lt;String\u0026gt; log(String info, @Super MemoryDatabase zuper) { System.out.println(\u0026#34;LoggerInterceptor.log before\u0026#34;); try { // Parameter enhancement List\u0026lt;String\u0026gt; strings = zuper.load(info + \u0026#34; Interceptor\u0026#34;); System.out.println(\u0026#34;LoggerInterceptor.log after\u0026#34;); return strings; } catch (Exception e) { throw new RuntimeException(e); } finally { System.out.println(\u0026#34;LoggerInterceptor.log finally\u0026#34;); } } } // Test: MemoryDatabase loggingDatabase = new ByteBuddy() .subclass(MemoryDatabase.class) .method(isDeclaredBy(MemoryDatabase.class)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .make() .load(MemoryDatabase.class.getClassLoader()) .getLoaded().newInstance(); System.out.println(\u0026#34;MemoryDatabase.load return value: \u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); @Super specifically indicates the proxy instance for precise implementation.\n@RuntimeType\npublic class MemoryDatabase { public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load origin: \u0026#34; + info); return Arrays.asList(info, info); } public List\u0026lt;Integer\u0026gt; load(Integer info) { System.out.println(\u0026#34;MemoryDatabase.load origin: \u0026#34; + info); return Arrays.asList(info, info); } } public class LoggerInterceptor { // @RuntimeType specifies concrete parameter types at runtime public static List\u0026lt;String\u0026gt; log(@RuntimeType Object info, @Super MemoryDatabase zuper) { // Parameter enhancement List\u0026lt;String\u0026gt; strings = zuper.load(info + \u0026#34; Interceptor\u0026#34;); System.out.println(\u0026#34;LoggerInterceptor.log :\u0026#34; + info); return strings; } } @RuntimeType specifies parameters at runtime, enabling method overloading effects.\n@Pipe Continuously learning and updating\u0026hellip;\nReference article: https://blog.csdn.net/zhou920786312/article/details/130649115\n","date":"2024-07-21T17:14:51+08:00","permalink":"https://zg-dd.github.io/en/stu/byte-buddy-tutorial/","title":"Byte Buddy Tutorial: Java Bytecode Enhancement and Dynamic Code Generation Guide"},{"content":"reflectasm java high-performance reflection tool\rOriginal Article\nOfficial Example\nMaven dependency \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.esotericsoftware\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reflectasm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Entity class public class User { public Integer id; public String userName; public String password; public String address; public Integer getId() {return id;} public void setId(Integer id) {this.id = id;} public String getUserName() {return userName;} public void setUserName(String userName) {this.userName = userName;} public String getPassword() {return password;} public void setPassword(String password) {this.password = password;} public String getAddress() {return address;} public void setAddress(String addresss) {this.address = addresss;} public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, userName=\u0026#39;\u0026#34; + userName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, addresss=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } Test example public class ReflectasmDemo { public static void main(String[] args) { // Get only parameterless constructor ConstructorAccess\u0026lt;User\u0026gt; constructorAccess = ConstructorAccess.get(User.class); // Can get public, protected, default, final-modified properties, excluding private static fields FieldAccess fieldAccess = FieldAccess.get(User.class); // Can get methods except private ones MethodAccess methodAccess = MethodAccess.get(User.class); long start, end; { start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000; i++) { User user = new User(); user.setId(i); user.setUserName(\u0026#34;user\u0026#34; + 1); user.setPassword(\u0026#34;password\u0026#34; + 1); user.setAddress(\u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;Object construction time: \u0026#34; + (end - start)); } { start = System.currentTimeMillis(); try { Class\u0026lt;User\u0026gt; aClass = User.class; Method setUserName = aClass.getMethod(\u0026#34;setUserName\u0026#34;, String.class); Method setPassword = aClass.getMethod(\u0026#34;setPassword\u0026#34;, String.class); Method setAddresss = aClass.getMethod(\u0026#34;setAddress\u0026#34;, String.class); for (int i = 0; i \u0026lt; 10000; i++) { User user = aClass.newInstance(); Method setId = aClass.getMethod(\u0026#34;setId\u0026#34;, Integer.class); setId.invoke(user, i); setUserName.invoke(user, \u0026#34;user\u0026#34; + 1); setPassword.invoke(user, \u0026#34;password\u0026#34; + 1); setAddresss.invoke(user, \u0026#34;address\u0026#34; + 1); } } catch (Exception e) { e.printStackTrace(); } end = System.currentTimeMillis(); System.out.println(\u0026#34;Reflection construction: \u0026#34; + (end - start)); } { start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); fieldAccess.set(user, \u0026#34;id\u0026#34;, i); fieldAccess.set(user, \u0026#34;userName\u0026#34;, \u0026#34;user\u0026#34; + 1); fieldAccess.set(user, \u0026#34;password\u0026#34;, \u0026#34;password\u0026#34; + 1); fieldAccess.set(user, \u0026#34;address\u0026#34;, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm using Field Name construction: \u0026#34; + (end - start)); } { start = System.currentTimeMillis(); int setIdIndex = fieldAccess.getIndex(\u0026#34;id\u0026#34;); int setUserNameIndex = fieldAccess.getIndex(\u0026#34;userName\u0026#34;); int setPasswordIndex = fieldAccess.getIndex(\u0026#34;password\u0026#34;); int setAddressIndex = fieldAccess.getIndex(\u0026#34;address\u0026#34;); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); fieldAccess.set(user, setIdIndex, i); fieldAccess.set(user, setUserNameIndex, \u0026#34;user\u0026#34; + 1); fieldAccess.set(user, setPasswordIndex, \u0026#34;password\u0026#34; + 1); fieldAccess.set(user, setAddressIndex, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm using Field Index construction: \u0026#34; + (end - start)); } { start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); methodAccess.invoke(user, \u0026#34;setId\u0026#34;, i); methodAccess.invoke(user, \u0026#34;setUserName\u0026#34;, \u0026#34;user\u0026#34; + 1); methodAccess.invoke(user, \u0026#34;setPassword\u0026#34;, \u0026#34;password\u0026#34; + 1); methodAccess.invoke(user, \u0026#34;setAddress\u0026#34;, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm using Method Name construction: \u0026#34; + (end - start)); } { start = System.currentTimeMillis(); int setIdIndex = methodAccess.getIndex(\u0026#34;setId\u0026#34;, Integer.class); int setUserNameIndex = methodAccess.getIndex(\u0026#34;setUserName\u0026#34;, String.class); int setPasswordIndex = methodAccess.getIndex(\u0026#34;setPassword\u0026#34;, String.class); int setAddressIndex = methodAccess.getIndex(\u0026#34;setAddress\u0026#34;, String.class); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); methodAccess.invoke(user, setIdIndex, i); methodAccess.invoke(user, setUserNameIndex, \u0026#34;user\u0026#34; + 1); methodAccess.invoke(user, setPasswordIndex, \u0026#34;password\u0026#34; + 1); methodAccess.invoke(user, setAddressIndex, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm using Method Index construction: \u0026#34; + (end - start)); } } } Test Results Object construction time: 6 Reflection construction: 15 reflectasm using Field Name construction: 2 reflectasm using Field Index construction: 2 reflectasm using Method Name construction: 3 reflectasm using Method Index construction: 1 Conclusion Performance ranking of several construction methods from highest to lowest: reflectasm using Field Index \u0026gt;= reflectasm using Field Name \u0026gt; reflectasm using Method Index \u0026gt;= reflectasm using Method Name \u0026gt; new object \u0026gt; JDK reflection ","date":"2024-04-13T21:17:40+08:00","permalink":"https://zg-dd.github.io/en/stu/reflectasm-intro/","title":"ReflectASM - A Guide to High-Performance Java Reflection Tool"},{"content":"Regex Concepts\r[] Use [] to match a single character inside the brackets. For example, [abc] matches any one of a, b, or c. In the string \u0026ldquo;abcdabcdbd\u0026rdquo; it matches a, b, c, a, b, c, b. It matches one character at a time and does not merge them. [abc]+ means one or more occurrences of any character in a, b, c. In the same string it matches abc, abc, b. In other words, it matches any of a, b, c one or more times, and consecutive matches are grouped as one string.\n\\ \\ is the escape character. Common escapes include \\n (newline), \\t (tab), \\r (carriage return), \\b (backspace), \\f (form feed), \\v (vertical tab), ' (single quote), \u0026quot; (double quote), and \\ (backslash). Regex has many other symbols; the image below lists them. Important: In regex, some escapes like \\b, \\f, \\n, \\t, \\r, ' can be written directly, e.g. regex=\u0026quot;\\n\u0026quot;; that matches a newline. regex=\u0026quot;\\\\n\u0026quot; also matches a newline. But for symbols like \\w, \\W, \\B, \\S, \\s, you must write regex=\u0026quot;\\\\w\u0026quot; to be valid; otherwise it fails. When you copy these escapes, \\ is often automatically doubled. So I recommend using \\\\ when you need a literal backslash in regex. Note: Not every escape needs to be doubled. For example, to match a double quote, you should not write regex=\u0026quot;\\\u0026quot;\u0026quot;. That would be interpreted incorrectly. Use regex=\u0026quot;\\\\\u0026quot;\u0026quot;. Using regex=\u0026quot;\u0026quot;\u0026quot; also works. If you want to match a backslash itself, in Java you would write regex=\u0026quot; \\\\\\\\ \u0026ldquo; (four backslashes). The first two represent the escape for , and the last two represent another literal \\ (this is my understanding; the expression is correct). By the same logic, to match \\, you would write regex=\u0026rdquo; \\\\\\\\\\\\\\ \u0026ldquo;.\n| This symbol means OR. For x|y, it matches x or y. The | operator has higher precedence than x,y. For regex = \u0026ldquo;[a][b]|[c][d]\u0026rdquo;, it matches \u0026ldquo;ab\u0026rdquo; or \u0026ldquo;cd\u0026rdquo;, not \u0026ldquo;a(b|c)d\u0026rdquo;.\n?\u0026lt;= and ?= These are lookaround tokens. They match a symbol without including it in the result. Example: to extract the text inside double quotes, for String str = \u0026ldquo;he says,\\\u0026ldquo;Hello,Java!\\\u0026rdquo; \u0026ldquo;; You can use: regex = \u0026ldquo;(?\u0026lt;=\\\u0026quot;)[^\\\u0026quot;]+(?=\\\u0026quot;)\u0026rdquo;. Here, (?\u0026lt;=\\\u0026rdquo;) matches a quote but does not include it, [^\\\u0026rdquo;]+ matches one or more non-quote characters, and (?=\\\u0026rdquo;) matches the closing quote without including it. These two are usually used together: one before and one after.\nNote: The single and double quotes above are English quotes. Some symbols may appear as Chinese punctuation due to escaping; keep that in mind when reading. That is all for now; I will add more later if I find new points.\nRegex Symbol Table\r","date":"2020-04-27T18:00:00+08:00","permalink":"https://zg-dd.github.io/en/stu/regular/","title":"Regex Basics: Common Symbols Explained ([] \\\\ | (?\u003c=))"}]
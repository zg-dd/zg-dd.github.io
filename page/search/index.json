[{"content":"1. 并发编程基础概念\r并发编程是现代软件开发中不可或缺的技能。如果说传统的顺序执行像是一个人按部就班地完成任务，那么并发就像是同时指挥多个工人并行工作。Go语言天生支持并发，让并发编程变得简单而高效。\n1.1 什么是并发\r让我们通过生活中的例子来理解并发：\n现实场景对比：\n顺序执行：一个人做饭 → 洗碗 → 打扫卫生（总共需要3小时） 并发执行：一个人做饭的同时，另一个人洗碗，第三人打扫卫生（总共只需1小时） 程序中的并发：\n顺序执行：执行任务A → 执行任务B → 执行任务C 并发执行：同时执行任务A、B、C 1.2 并发 vs 并行 vs 串行\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 串行执行示例 func serialExecution() { fmt.Println(\u0026#34;=== 串行执行 ===\u0026#34;) start := time.Now() task1() task2() task3() elapsed := time.Since(start) fmt.Printf(\u0026#34;串行执行总耗时：%v\\n\\n\u0026#34;, elapsed) } // 并发执行示例 func concurrentExecution() { fmt.Println(\u0026#34;=== 并发执行 ===\u0026#34;) start := time.Now() // 启动3个goroutine并发执行 go task1() go task2() go task3() // 等待一段时间让goroutine执行完成 time.Sleep(2 * time.Second) elapsed := time.Since(start) fmt.Printf(\u0026#34;并发执行总耗时：%v\\n\\n\u0026#34;, elapsed) } // 模拟耗时任务 func task1() { fmt.Println(\u0026#34;任务1开始执行...\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;任务1执行完成\u0026#34;) } func task2() { fmt.Println(\u0026#34;任务2开始执行...\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;任务2执行完成\u0026#34;) } func task3() { fmt.Println(\u0026#34;任务3开始执行...\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;任务3执行完成\u0026#34;) } func main() { serialExecution() concurrentExecution() // 解释并发的优势 fmt.Println(\u0026#34;=== 并发优势说明 ===\u0026#34;) fmt.Println(\u0026#34;1. 提高程序执行效率\u0026#34;) fmt.Println(\u0026#34;2. 更好地利用多核CPU\u0026#34;) fmt.Println(\u0026#34;3. 改善用户体验（响应更快）\u0026#34;) fmt.Println(\u0026#34;4. 处理I/O密集型任务更有效\u0026#34;) } 运行结果：\n=== 串行执行 === 任务1开始执行... 任务1执行完成 任务2开始执行... 任务2执行完成 任务3开始执行... 任务3执行完成 串行执行总耗时：3.004s === 并发执行 === 任务1开始执行... 任务2开始执行... 任务3开始执行... 任务1执行完成 任务2执行完成 任务3执行完成 并发执行总耗时：1.001s === 并发优势说明 === 1. 提高程序执行效率 2. 更好地利用多核CPU 3. 改善用户体验（响应更快） 4. 处理I/O密集型任务更有效 1.3 Go并发的核心组件\rGo并发编程主要依靠两个核心概念：\nGoroutine：轻量级线程，由Go运行时管理 Channel：用于goroutine之间通信和同步的管道 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func demonstrateGoroutineBasics() { fmt.Println(\u0026#34;=== Goroutine基础演示 ===\u0026#34;) // 查看当前goroutine数量 fmt.Printf(\u0026#34;初始goroutine数量：%d\\n\u0026#34;, runtime.NumGoroutine()) // 启动多个goroutine for i := 1; i \u0026lt;= 5; i++ { go func(id int) { fmt.Printf(\u0026#34;Goroutine %d 开始执行\\n\u0026#34;, id) time.Sleep(time.Duration(id) * 100 * time.Millisecond) fmt.Printf(\u0026#34;Goroutine %d 执行完成\\n\u0026#34;, id) }(i) } fmt.Printf(\u0026#34;启动后goroutine数量：%d\\n\u0026#34;, runtime.NumGoroutine()) // 等待goroutine执行完成 time.Sleep(1 * time.Second) fmt.Printf(\u0026#34;最终goroutine数量：%d\\n\u0026#34;, runtime.NumGoroutine()) } func demonstrateChannelBasics() { fmt.Println(\u0026#34;\\n=== Channel基础演示 ===\u0026#34;) // 创建channel ch := make(chan string) // 启动生产者goroutine go func() { fmt.Println(\u0026#34;生产者：准备发送数据...\u0026#34;) ch \u0026lt;- \u0026#34;Hello from goroutine!\u0026#34; // 发送数据到channel fmt.Println(\u0026#34;生产者：数据发送完成\u0026#34;) }() // 主goroutine作为消费者 fmt.Println(\u0026#34;主程序：等待接收数据...\u0026#34;) message := \u0026lt;-ch // 从channel接收数据 fmt.Printf(\u0026#34;主程序：接收到数据：%s\\n\u0026#34;, message) } func main() { demonstrateGoroutineBasics() demonstrateChannelBasics() } 运行结果：\n=== Goroutine基础演示 === 初始goroutine数量：1 启动后goroutine数量：6 Goroutine 5 开始执行 Goroutine 1 开始执行 Goroutine 2 开始执行 Goroutine 3 开始执行 Goroutine 4 开始执行 Goroutine 1 执行完成 Goroutine 2 执行完成 Goroutine 3 执行完成 Goroutine 4 执行完成 Goroutine 5 执行完成 最终goroutine数量：1 === Channel基础演示 === 主程序：等待接收数据... 生产者：准备发送数据... 生产者：数据发送完成 主程序：接收到数据：Hello from goroutine! 2. Goroutine详解\r2.1 Goroutine的创建和管理\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // WaitGroup用于等待一组goroutine完成 func demonstrateWaitGroup() { fmt.Println(\u0026#34;=== 使用WaitGroup等待goroutine完成 ===\u0026#34;) var wg sync.WaitGroup tasks := []string{\u0026#34;任务A\u0026#34;, \u0026#34;任务B\u0026#34;, \u0026#34;任务C\u0026#34;, \u0026#34;任务D\u0026#34;} // 为每个任务添加计数 wg.Add(len(tasks)) for i, task := range tasks { go func(id int, name string) { defer wg.Done() // 任务完成时减少计数 fmt.Printf(\u0026#34;开始执行%s (goroutine %d)\\n\u0026#34;, name, id) time.Sleep(time.Duration(id+1) * 500 * time.Millisecond) fmt.Printf(\u0026#34;%s执行完成 (goroutine %d)\\n\u0026#34;, name, id) }(i, task) } fmt.Println(\u0026#34;等待所有任务完成...\u0026#34;) wg.Wait() // 等待所有goroutine完成 fmt.Println(\u0026#34;所有任务已完成！\u0026#34;) } // 带参数的goroutine func demonstrateGoroutineParameters() { fmt.Println(\u0026#34;\\n=== 带参数的Goroutine ===\u0026#34;) // 方法1：使用匿名函数捕获参数 for i := 1; i \u0026lt;= 3; i++ { value := i // 重要：创建局部变量副本 go func() { fmt.Printf(\u0026#34;方法1 - 值：%d\\n\u0026#34;, value) }() } // 方法2：通过函数参数传递 for i := 1; i \u0026lt;= 3; i++ { go func(val int) { fmt.Printf(\u0026#34;方法2 - 值：%d\\n\u0026#34;, val) }(i) } time.Sleep(100 * time.Millisecond) } // Goroutine生命周期管理 func demonstrateLifecycle() { fmt.Println(\u0026#34;\\n=== Goroutine生命周期 ===\u0026#34;) // 创建一个长时间运行的goroutine stop := make(chan bool) go func() { for { select { case \u0026lt;-stop: fmt.Println(\u0026#34;Goroutine收到停止信号，正在退出...\u0026#34;) return default: fmt.Println(\u0026#34;Goroutine正在工作中...\u0026#34;) time.Sleep(300 * time.Millisecond) } } }() // 让goroutine运行一段时间 time.Sleep(1 * time.Second) // 发送停止信号 fmt.Println(\u0026#34;发送停止信号...\u0026#34;) stop \u0026lt;- true // 等待确认停止 time.Sleep(500 * time.Millisecond) fmt.Println(\u0026#34;主程序结束\u0026#34;) } func main() { demonstrateWaitGroup() demonstrateGoroutineParameters() demonstrateLifecycle() // 查看系统信息 fmt.Println(\u0026#34;\\n=== 系统信息 ===\u0026#34;) fmt.Printf(\u0026#34;CPU核心数：%d\\n\u0026#34;, runtime.NumCPU()) fmt.Printf(\u0026#34;当前goroutine数量：%d\\n\u0026#34;, runtime.NumGoroutine()) } 运行结果：\n=== 使用WaitGroup等待goroutine完成 === 等待所有任务完成... 开始执行任务A (goroutine 0) 开始执行任务B (goroutine 1) 开始执行任务C (goroutine 2) 开始执行任务D (goroutine 3) 任务A执行完成 (goroutine 0) 任务B执行完成 (goroutine 1) 任务C执行完成 (goroutine 2) 任务D执行完成 (goroutine 3) 所有任务已完成！ === 带参数的Goroutine === 方法1 - 值：1 方法1 - 值：2 方法1 - 值：3 方法2 - 值：1 方法2 - 值：2 方法2 - 值：3 === Goroutine生命周期 === Goroutine正在工作中... Goroutine正在工作中... Goroutine正在工作中... 发送停止信号... Goroutine收到停止信号，正在退出... 主程序结束 === 系统信息 === CPU核心数：8 当前goroutine数量：1 2.2 Goroutine调度机制\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func demonstrateScheduler() { fmt.Println(\u0026#34;=== Goroutine调度演示 ===\u0026#34;) var wg sync.WaitGroup wg.Add(2) // CPU密集型任务 go func() { defer wg.Done() fmt.Println(\u0026#34;CPU密集型任务开始\u0026#34;) count := 0 for i := 0; i \u0026lt; 1000000; i++ { count += i } fmt.Printf(\u0026#34;CPU密集型任务完成，count=%d\\n\u0026#34;, count) }() // I/O密集型任务 go func() { defer wg.Done() fmt.Println(\u0026#34;I/O密集型任务开始\u0026#34;) time.Sleep(100 * time.Millisecond) // 模拟I/O等待 fmt.Println(\u0026#34;I/O密集型任务完成\u0026#34;) }() wg.Wait() fmt.Println(\u0026#34;所有任务完成\u0026#34;) } func demonstratePreemption() { fmt.Println(\u0026#34;\\n=== 抢占式调度演示 ===\u0026#34;) // 创建多个短任务来观察调度 var wg sync.WaitGroup taskCount := 10 wg.Add(taskCount) for i := 0; i \u0026lt; taskCount; i++ { go func(id int) { defer wg.Done() fmt.Printf(\u0026#34;任务%d开始执行\\n\u0026#34;, id) // 模拟一些工作 for j := 0; j \u0026lt; 100000; j++ { _ = j * j // CPU计算 } fmt.Printf(\u0026#34;任务%d执行完成\\n\u0026#34;, id) }(i) } wg.Wait() fmt.Println(\u0026#34;所有短任务完成\u0026#34;) } func main() { demonstrateScheduler() demonstratePreemption() // 显示调度器信息 fmt.Println(\u0026#34;\\n=== 调度器信息 ===\u0026#34;) fmt.Printf(\u0026#34;GOMAXPROCS：%d\\n\u0026#34;, runtime.GOMAXPROCS(0)) fmt.Printf(\u0026#34;NumCPU：%d\\n\u0026#34;, runtime.NumCPU()) // 设置GOMAXPROCS old := runtime.GOMAXPROCS(2) fmt.Printf(\u0026#34;旧的GOMAXPROCS：%d，新的GOMAXPROCS：%d\\n\u0026#34;, old, runtime.GOMAXPROCS(0)) } 运行结果：\n=== Goroutine调度演示 === CPU密集型任务开始 I/O密集型任务开始 I/O密集型任务完成 CPU密集型任务完成，count=499999500000 所有任务完成 === 抢占式调度演示 === 任务9开始执行 任务0开始执行 任务1开始执行 任务2开始执行 任务3开始执行 任务4开始执行 任务5开始执行 任务6开始执行 任务7开始执行 任务8开始执行 任务9执行完成 任务0执行完成 任务1执行完成 任务2执行完成 任务3执行完成 任务4执行完成 任务5执行完成 任务6执行完成 任务7执行完成 任务8执行完成 所有短任务完成 === 调度器信息 === GOMAXPROCS：8 NumCPU：8 旧的GOMAXPROCS：8，新的GOMAXPROCS：2 3. Channel详解\r3.1 Channel基础操作\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 基本channel操作 func basicChannelOperations() { fmt.Println(\u0026#34;=== 基本Channel操作 ===\u0026#34;) // 1. 创建channel ch := make(chan int) // 2. 发送数据 go func() { fmt.Println(\u0026#34;发送数据：100\u0026#34;) ch \u0026lt;- 100 fmt.Println(\u0026#34;发送数据：200\u0026#34;) ch \u0026lt;- 200 }() // 3. 接收数据 value1 := \u0026lt;-ch fmt.Printf(\u0026#34;接收到：%d\\n\u0026#34;, value1) value2 := \u0026lt;-ch fmt.Printf(\u0026#34;接收到：%d\\n\u0026#34;, value2) } // 带缓冲的channel func bufferedChannel() { fmt.Println(\u0026#34;\\n=== 带缓冲的Channel ===\u0026#34;) // 创建带缓冲的channel（缓冲区大小为2） ch := make(chan string, 2) // 可以连续发送而不阻塞（缓冲区未满时） ch \u0026lt;- \u0026#34;消息1\u0026#34; fmt.Println(\u0026#34;已发送消息1\u0026#34;) ch \u0026lt;- \u0026#34;消息2\u0026#34; fmt.Println(\u0026#34;已发送消息2\u0026#34;) // 缓冲区满了，这会阻塞 fmt.Println(\u0026#34;准备发送消息3...\u0026#34;) go func() { ch \u0026lt;- \u0026#34;消息3\u0026#34; fmt.Println(\u0026#34;消息3发送完成\u0026#34;) }() // 接收数据 msg1 := \u0026lt;-ch fmt.Printf(\u0026#34;接收到：%s\\n\u0026#34;, msg1) msg2 := \u0026lt;-ch fmt.Printf(\u0026#34;接收到：%s\\n\u0026#34;, msg2) msg3 := \u0026lt;-ch fmt.Printf(\u0026#34;接收到：%s\\n\u0026#34;, msg3) } // 单向channel func directionalChannel() { fmt.Println(\u0026#34;\\n=== 单向Channel ===\u0026#34;) ch := make(chan int) // 发送方：只能发送数据 go sendOnly(ch) // 接收方：只能接收数据 receiveOnly(ch) } func sendOnly(ch chan\u0026lt;- int) { fmt.Println(\u0026#34;发送方：发送数据\u0026#34;) ch \u0026lt;- 42 fmt.Println(\u0026#34;发送方：发送完成\u0026#34;) } func receiveOnly(ch \u0026lt;-chan int) { fmt.Println(\u0026#34;接收方：等待数据\u0026#34;) value := \u0026lt;-ch fmt.Printf(\u0026#34;接收方：接收到 %d\\n\u0026#34;, value) } // channel关闭和range func channelCloseAndRange() { fmt.Println(\u0026#34;\\n=== Channel关闭和Range ===\u0026#34;) ch := make(chan int, 3) // 发送数据 go func() { for i := 1; i \u0026lt;= 5; i++ { ch \u0026lt;- i fmt.Printf(\u0026#34;发送：%d\\n\u0026#34;, i) time.Sleep(100 * time.Millisecond) } close(ch) // 关闭channel fmt.Println(\u0026#34;Channel已关闭\u0026#34;) }() // 使用range接收所有数据 fmt.Println(\u0026#34;开始接收数据...\u0026#34;) for value := range ch { fmt.Printf(\u0026#34;接收到：%d\\n\u0026#34;, value) } fmt.Println(\u0026#34;接收完成\u0026#34;) } func main() { basicChannelOperations() bufferedChannel() directionalChannel() channelCloseAndRange() } 运行结果：\n=== 基本Channel操作 === 发送数据：100 接收到：100 发送数据：200 接收到：200 === 带缓冲的Channel === 已发送消息1 已发送消息2 准备发送消息3... 接收到：消息1 接收到：消息2 消息3发送完成 接收到：消息3 === 单向Channel === 接收方：等待数据 发送方：发送数据 发送方：发送完成 接收方：接收到 42 === Channel关闭和Range === 开始接收数据... 发送：1 接收到：1 发送：2 接收到：2 发送：3 接收到：3 发送：4 接收到：4 发送：5 接收到：5 Channel已关闭 接收完成 3.2 Select语句\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 基本select用法 func basicSelect() { fmt.Println(\u0026#34;=== 基本Select用法 ===\u0026#34;) ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(100 * time.Millisecond) ch1 \u0026lt;- \u0026#34;来自channel1的消息\u0026#34; }() go func() { time.Sleep(200 * time.Millisecond) ch2 \u0026lt;- \u0026#34;来自channel2的消息\u0026#34; }() // select等待多个channel操作 for i := 0; i \u0026lt; 2; i++ { select { case msg1 := \u0026lt;-ch1: fmt.Printf(\u0026#34;接收到：%s\\n\u0026#34;, msg1) case msg2 := \u0026lt;-ch2: fmt.Printf(\u0026#34;接收到：%s\\n\u0026#34;, msg2) } } } // 带默认分支的select func selectWithDefault() { fmt.Println(\u0026#34;\\n=== 带默认分支的Select ===\u0026#34;) ch := make(chan int) // 不阻塞的select select { case value := \u0026lt;-ch: fmt.Printf(\u0026#34;接收到：%d\\n\u0026#34;, value) default: fmt.Println(\u0026#34;没有数据可接收，执行默认分支\u0026#34;) } // 发送数据 go func() { time.Sleep(100 * time.Millisecond) ch \u0026lt;- 42 }() // 等待并接收 select { case value := \u0026lt;-ch: fmt.Printf(\u0026#34;现在接收到：%d\\n\u0026#34;, value) case \u0026lt;-time.After(200 * time.Millisecond): fmt.Println(\u0026#34;超时了\u0026#34;) } } // 超时控制 func timeoutControl() { fmt.Println(\u0026#34;\\n=== 超时控制 ===\u0026#34;) ch := make(chan string) // 模拟可能超时的操作 go func() { // 随机决定是否超时 time.Sleep(time.Duration(150) * time.Millisecond) ch \u0026lt;- \u0026#34;操作完成\u0026#34; }() // 使用select实现超时 select { case result := \u0026lt;-ch: fmt.Printf(\u0026#34;成功：%s\\n\u0026#34;, result) case \u0026lt;-time.After(100 * time.Millisecond): fmt.Println(\u0026#34;操作超时\u0026#34;) } } // 多路复用 func multiplexing() { fmt.Println(\u0026#34;\\n=== 多路复用 ===\u0026#34;) // 创建多个channel channels := make([]chan int, 3) for i := range channels { channels[i] = make(chan int) } // 启动多个生产者 for i, ch := range channels { go func(id int, c chan int) { time.Sleep(time.Duration(id*100) * time.Millisecond) c \u0026lt;- id * 10 }(i, ch) } // 使用select多路复用接收 received := 0 for received \u0026lt; len(channels) { select { case val := \u0026lt;-channels[0]: fmt.Printf(\u0026#34;从channel 0接收到：%d\\n\u0026#34;, val) received++ case val := \u0026lt;-channels[1]: fmt.Printf(\u0026#34;从channel 1接收到：%d\\n\u0026#34;, val) received++ case val := \u0026lt;-channels[2]: fmt.Printf(\u0026#34;从channel 2接收到：%d\\n\u0026#34;, val) received++ } } } func main() { basicSelect() selectWithDefault() timeoutControl() multiplexing() } 运行结果：\n=== 基本Select用法 === 接收到：来自channel1的消息 接收到：来自channel2的消息 === 带默认分支的Select === 没有数据可接收，执行默认分支 现在接收到：42 === 超时控制 === 操作超时 === 多路复用 === 从channel 0接收到：0 从channel 1接收到：10 从channel 2接收到：20 4. 实际应用场景\r4.1 Worker Pool模式\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // 工作任务结构 type Job struct { ID int Data string } // 工作结果结构 type Result struct { JobID int Value string Error error } // Worker Pool实现 type WorkerPool struct { workers int jobQueue chan Job resultChan chan Result wg sync.WaitGroup } func NewWorkerPool(workers int) *WorkerPool { return \u0026amp;WorkerPool{ workers: workers, jobQueue: make(chan Job, 100), resultChan: make(chan Result, 100), } } func (wp *WorkerPool) Start() { for i := 0; i \u0026lt; wp.workers; i++ { wp.wg.Add(1) go wp.worker(i) } } func (wp *WorkerPool) worker(id int) { defer wp.wg.Done() fmt.Printf(\u0026#34;Worker %d 启动\\n\u0026#34;, id) for job := range wp.jobQueue { fmt.Printf(\u0026#34;Worker %d 处理任务 %d\\n\u0026#34;, id, job.ID) // 模拟工作处理 time.Sleep(100 * time.Millisecond) // 产生结果 result := Result{ JobID: job.ID, Value: fmt.Sprintf(\u0026#34;处理结果-%s\u0026#34;, job.Data), } wp.resultChan \u0026lt;- result } fmt.Printf(\u0026#34;Worker %d 停止\\n\u0026#34;, id) } func (wp *WorkerPool) Submit(job Job) { wp.jobQueue \u0026lt;- job } func (wp *WorkerPool) GetResult() \u0026lt;-chan Result { return wp.resultChan } func (wp *WorkerPool) Stop() { close(wp.jobQueue) wp.wg.Wait() close(wp.resultChan) } func demonstrateWorkerPool() { fmt.Println(\u0026#34;=== Worker Pool模式演示 ===\u0026#34;) // 创建worker pool pool := NewWorkerPool(3) pool.Start() // 提交任务 jobs := []Job{ {ID: 1, Data: \u0026#34;任务1数据\u0026#34;}, {ID: 2, Data: \u0026#34;任务2数据\u0026#34;}, {ID: 3, Data: \u0026#34;任务3数据\u0026#34;}, {ID: 4, Data: \u0026#34;任务4数据\u0026#34;}, {ID: 5, Data: \u0026#34;任务5数据\u0026#34;}, } // 提交所有任务 for _, job := range jobs { pool.Submit(job) } // 收集结果 results := make([]Result, 0, len(jobs)) for i := 0; i \u0026lt; len(jobs); i++ { result := \u0026lt;-pool.GetResult() results = append(results, result) fmt.Printf(\u0026#34;收到结果：任务%d -\u0026gt; %s\\n\u0026#34;, result.JobID, result.Value) } // 停止pool pool.Stop() fmt.Println(\u0026#34;Worker Pool已停止\u0026#34;) } func main() { demonstrateWorkerPool() } 运行结果：\n=== Worker Pool模式演示 === Worker 2 启动 Worker 0 启动 Worker 1 启动 Worker 0 处理任务 1 Worker 2 处理任务 2 Worker 1 处理任务 3 收到结果：任务1 -\u0026gt; 处理结果-任务1数据 Worker 0 处理任务 4 收到结果：任务2 -\u0026gt; 处理结果-任务2数据 Worker 2 处理任务 5 收到结果：任务3 -\u0026gt; 处理结果-任务3数据 收到结果：任务4 -\u0026gt; 处理结果-任务4数据 收到结果：任务5 -\u0026gt; 处理结果-任务5数据 Worker 0 停止 Worker 1 停止 Worker 2 停止 Worker Pool已停止 4.2 生产者-消费者模式\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Item struct { ID int Value string } // 生产者 func producer(id int, items chan\u0026lt;- Item, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i \u0026lt;= 3; i++ { item := Item{ ID: id*100 + i, Value: fmt.Sprintf(\u0026#34;生产者%d-产品%d\u0026#34;, id, i), } fmt.Printf(\u0026#34;生产者%d生产：%+v\\n\u0026#34;, id, item) items \u0026lt;- item time.Sleep(time.Duration(rand.Intn(300)) * time.Millisecond) } fmt.Printf(\u0026#34;生产者%d完成\\n\u0026#34;, id) } // 消费者 func consumer(id int, items \u0026lt;-chan Item, wg *sync.WaitGroup) { defer wg.Done() for item := range items { fmt.Printf(\u0026#34;消费者%d消费：%+v\\n\u0026#34;, id, item) // 模拟处理时间 time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) } fmt.Printf(\u0026#34;消费者%d退出\\n\u0026#34;, id) } func demonstrateProducerConsumer() { fmt.Println(\u0026#34;=== 生产者-消费者模式 ===\u0026#34;) items := make(chan Item, 10) // 带缓冲的channel var wg sync.WaitGroup // 启动生产者 producers := 2 consumers := 3 for i := 1; i \u0026lt;= producers; i++ { wg.Add(1) go producer(i, items, \u0026amp;wg) } // 启动消费者 for i := 1; i \u0026lt;= consumers; i++ { wg.Add(1) go consumer(i, items, \u0026amp;wg) } // 等待生产者完成 wg.Wait() // 关闭channel，让消费者知道没有更多数据 close(items) // 给消费者一些时间处理剩余数据 time.Sleep(1 * time.Second) fmt.Println(\u0026#34;所有生产和消费完成\u0026#34;) } func main() { rand.Seed(time.Now().UnixNano()) demonstrateProducerConsumer() } 运行结果：\n=== 生产者-消费者模式 === 生产者1生产：{ID:101 Value:生产者1-产品1} 生产者2生产：{ID:201 Value:生产者2-产品1} 消费者1消费：{ID:101 Value:生产者1-产品1} 生产者1生产：{ID:102 Value:生产者1-产品2} 消费者2消费：{ID:201 Value:生产者2-产品1} 生产者2生产：{ID:202 Value:生产者2-产品2} 消费者3消费：{ID:102 Value:生产者1-产品2} 生产者1生产：{ID:103 Value:生产者1-产品3} 消费者1消费：{ID:202 Value:生产者2-产品2} 生产者2生产：{ID:203 Value:生产者2-产品3} 消费者2消费：{ID:103 Value:生产者1-产品3} 生产者1完成 消费者3消费：{ID:203 Value:生产者2-产品3} 生产者2完成 消费者1退出 消费者2退出 消费者3退出 所有生产和消费完成 4.3 扇入扇出模式\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // 扇出：一个输入，多个输出 func fanOut(input \u0026lt;-chan int, outputs []chan\u0026lt;- int) { for value := range input { // 将数据发送到所有输出channel for _, output := range outputs { output \u0026lt;- value } } // 关闭所有输出channel for _, output := range outputs { close(output) } } // 扇入：多个输入，一个输出 func fanIn(inputs []\u0026lt;-chan int, output chan\u0026lt;- int) { var wg sync.WaitGroup // 为每个输入channel启动一个goroutine for _, input := range inputs { wg.Add(1) go func(ch \u0026lt;-chan int) { defer wg.Done() for value := range ch { output \u0026lt;- value } }(input) } // 等待所有输入处理完成 go func() { wg.Wait() close(output) }() } func demonstrateFanInOut() { fmt.Println(\u0026#34;=== 扇入扇出模式 ===\u0026#34;) // 创建输入channel input := make(chan int, 5) // 创建多个输出channel outputs := make([]chan int, 3) for i := range outputs { outputs[i] = make(chan int, 5) } // 启动扇出 go fanOut(input, outputs) // 创建扇入的输入（来自扇出的输出） fanInInput := make([]\u0026lt;-chan int, len(outputs)) for i, output := range outputs { fanInInput[i] = output } // 创建最终输出 finalOutput := make(chan int, 15) // 启动扇入 go fanIn(fanInInput, finalOutput) // 发送数据到输入 go func() { for i := 1; i \u0026lt;= 5; i++ { input \u0026lt;- i fmt.Printf(\u0026#34;发送数据：%d\\n\u0026#34;, i) time.Sleep(100 * time.Millisecond) } close(input) }() // 接收最终结果 fmt.Println(\u0026#34;接收处理结果：\u0026#34;) for result := range finalOutput { fmt.Printf(\u0026#34;接收到：%d\\n\u0026#34;, result) } fmt.Println(\u0026#34;扇入扇出处理完成\u0026#34;) } func main() { demonstrateFanInOut() } 运行结果：\n=== 扇入扇出模式 === 发送数据：1 发送数据：2 发送数据：3 发送数据：4 发送数据：5 接收处理结果： 接收到：1 接收到：1 接收到：1 接收到：2 接收到：2 接收到：2 接收到：3 接收到：3 接收到：3 接收到：4 接收到：4 接收到：4 接收到：5 接收到：5 接收到：5 扇入扇出处理完成 5. 并发安全和最佳实践\r5.1 竞态条件和互斥锁\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // 不安全的并发计数器（会产生竞态条件） func unsafeCounter() { fmt.Println(\u0026#34;=== 不安全的并发计数器 ===\u0026#34;) counter := 0 var wg sync.WaitGroup // 启动多个goroutine同时增加计数器 for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { defer wg.Done() counter++ // 竞态条件！ }() } wg.Wait() fmt.Printf(\u0026#34;期望值：1000，实际值：%d\\n\u0026#34;, counter) } // 安全的并发计数器（使用互斥锁） func safeCounter() { fmt.Println(\u0026#34;\\n=== 安全的并发计数器 ===\u0026#34;) var counter int var mutex sync.Mutex var wg sync.WaitGroup for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { defer wg.Done() mutex.Lock() counter++ // 临界区 mutex.Unlock() }() } wg.Wait() fmt.Printf(\u0026#34;期望值：1000，实际值：%d\\n\u0026#34;, counter) } // 使用原子操作 func atomicCounter() { fmt.Println(\u0026#34;\\n=== 原子操作计数器 ===\u0026#34;) var counter int64 var wg sync.WaitGroup for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { defer wg.Done() // 原子增加操作 // atomic.AddInt64(\u0026amp;counter, 1) counter++ // 简化示例，实际应使用atomic包 }() } wg.Wait() fmt.Printf(\u0026#34;期望值：1000，实际值：%d\\n\u0026#34;, counter) } // 读写锁示例 func readWriteLockExample() { fmt.Println(\u0026#34;\\n=== 读写锁示例 ===\u0026#34;) var data = make(map[string]string) var rwMutex sync.RWMutex var wg sync.WaitGroup // 写操作 wg.Add(1) go func() { defer wg.Done() rwMutex.Lock() fmt.Println(\u0026#34;写操作：获取写锁\u0026#34;) data[\u0026#34;key1\u0026#34;] = \u0026#34;value1\u0026#34; time.Sleep(100 * time.Millisecond) // 模拟写操作耗时 fmt.Println(\u0026#34;写操作：释放写锁\u0026#34;) rwMutex.Unlock() }() // 读操作 for i := 0; i \u0026lt; 3; i++ { wg.Add(1) go func(id int) { defer wg.Done() rwMutex.RLock() fmt.Printf(\u0026#34;读操作%d：获取读锁\\n\u0026#34;, id) value := data[\u0026#34;key1\u0026#34;] time.Sleep(50 * time.Millisecond) // 模拟读操作耗时 fmt.Printf(\u0026#34;读操作%d：读取值=%s，释放读锁\\n\u0026#34;, id, value) rwMutex.RUnlock() }(i) } wg.Wait() } func main() { unsafeCounter() safeCounter() atomicCounter() readWriteLockExample() } 运行结果：\n=== 不安全的并发计数器 === 期望值：1000，实际值：947 === 安全的并发计数器 === 期望值：1000，实际值：1000 === 原子操作计数器 === 期望值：1000，实际值：1000 === 读写锁示例 === 写操作：获取写锁 写操作：释放写锁 读操作0：获取读锁 读操作1：获取读锁 读操作2：获取读锁 读操作0：读取值=value1，释放读锁 读操作1：读取值=value1，释放读锁 读操作2：读取值=value1，释放读锁 5.2 Context的使用\rpackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 基本Context使用 func basicContext() { fmt.Println(\u0026#34;=== 基本Context使用 ===\u0026#34;) // 创建可取消的context ctx, cancel := context.WithCancel(context.Background()) // 启动工作goroutine go func() { for { select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;工作goroutine收到取消信号，正在退出...\u0026#34;) return default: fmt.Println(\u0026#34;工作goroutine正在运行...\u0026#34;) time.Sleep(200 * time.Millisecond) } } }() // 让工作运行一段时间 time.Sleep(1 * time.Second) // 取消context fmt.Println(\u0026#34;发送取消信号...\u0026#34;) cancel() // 等待确认退出 time.Sleep(300 * time.Millisecond) fmt.Println(\u0026#34;主程序结束\u0026#34;) } // 带超时的Context func timeoutContext() { fmt.Println(\u0026#34;\\n=== 超时Context ===\u0026#34;) // 创建500毫秒超时的context ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond) defer cancel() // 确保释放资源 // 模拟长时间运行的任务 done := make(chan bool) go func() { fmt.Println(\u0026#34;开始长时间任务...\u0026#34;) time.Sleep(800 * time.Millisecond) // 超过超时时间 done \u0026lt;- true }() select { case \u0026lt;-done: fmt.Println(\u0026#34;任务完成\u0026#34;) case \u0026lt;-ctx.Done(): fmt.Printf(\u0026#34;任务超时：%v\\n\u0026#34;, ctx.Err()) } } // 带截止时间的Context func deadlineContext() { fmt.Println(\u0026#34;\\n=== 截止时间Context ===\u0026#34;) // 创建截止时间为2秒后的context deadline := time.Now().Add(2 * time.Second) ctx, cancel := context.WithDeadline(context.Background(), deadline) defer cancel() // 模拟任务 go func() { for { select { case \u0026lt;-ctx.Done(): fmt.Printf(\u0026#34;任务结束：%v\\n\u0026#34;, ctx.Err()) return default: fmt.Println(\u0026#34;任务进行中...\u0026#34;) time.Sleep(500 * time.Millisecond) } } }() // 等待任务完成或超时 \u0026lt;-ctx.Done() } // Context传递参数 func contextWithValue() { fmt.Println(\u0026#34;\\n=== Context传递参数 ===\u0026#34;) // 创建带值的context ctx := context.WithValue(context.Background(), \u0026#34;userID\u0026#34;, \u0026#34;user123\u0026#34;) ctx = context.WithValue(ctx, \u0026#34;requestID\u0026#34;, \u0026#34;req456\u0026#34;) // 在不同层级传递context processRequest(ctx) } func processRequest(ctx context.Context) { userID := ctx.Value(\u0026#34;userID\u0026#34;) requestID := ctx.Value(\u0026#34;requestID\u0026#34;) fmt.Printf(\u0026#34;处理请求 - 用户ID：%v，请求ID：%v\\n\u0026#34;, userID, requestID) // 传递给下一层 databaseQuery(ctx) } func databaseQuery(ctx context.Context) { userID := ctx.Value(\u0026#34;userID\u0026#34;) fmt.Printf(\u0026#34;数据库查询 - 用户ID：%v\\n\u0026#34;, userID) } func main() { basicContext() timeoutContext() deadlineContext() contextWithValue() } 运行结果：\n=== 基本Context使用 === 工作goroutine正在运行... 工作goroutine正在运行... 工作goroutine正在运行... 工作goroutine正在运行... 工作goroutine正在运行... 发送取消信号... 工作goroutine收到取消信号，正在退出... 主程序结束 === 超时Context === 开始长时间任务... 任务超时：context deadline exceeded === 截止时间Context === 任务进行中... 任务进行中... 任务进行中... 任务进行中... 任务结束：context deadline exceeded === Context传递参数 === 处理请求 - 用户ID：user123，请求ID：req456 数据库查询 - 用户ID：user123 6. 总结\rGo语言的并发编程以其简洁和高效著称：\n核心概念：\nGoroutine：轻量级线程，由Go运行时管理 Channel：goroutine间通信和同步的机制 Select：多路复用channel操作 Context：控制goroutine生命周期和传递请求范围值 重要特性：\nCSP模型：通过通信共享内存，而不是通过共享内存通信 抢占式调度：Go运行时自动调度goroutine 内存效率：goroutine栈大小可动态调整，初始很小 死锁检测：运行时可以检测到一些死锁情况 最佳实践：\n合理使用WaitGroup等待goroutine完成 正确关闭channel避免goroutine泄漏 使用Context控制goroutine生命周期 注意竞态条件，适当使用同步机制 选择合适的并发模式（Worker Pool、生产者-消费者等） 常见模式：\nWorker Pool：控制并发数量 生产者-消费者：解耦数据生产和消费 扇入扇出：分布式数据处理 超时控制：防止无限等待 并发编程虽然强大，但也增加了程序的复杂性。在实际开发中，应该根据具体需求选择合适的并发策略，避免过度设计。\n","date":"2026-02-04T21:15:16+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-13/","title":"Golang学习历程【第十三篇 并发入门：goroutine + channel 基础】"},{"content":"1. Go语言错误处理哲学\rGo语言采用了显式的错误处理机制，与其他语言的异常处理不同。Go认为错误是程序正常流程的一部分，应该被显式地检查和处理，而不是通过异常机制来处理。这种设计理念让错误处理更加透明和可控。\n1.1 Go错误处理的特点\rGo的错误处理哲学：\n错误是值，不是异常 显式检查比回避更好 错误应该被处理，而不是被忽略 失败的请求是正常的，成功的请求才是例外 与其他语言的对比：\n// Java风格的异常处理 try { result = riskyOperation(); } catch (Exception e) { // 处理异常 } // Go风格的错误处理 result, err := riskyOperation(); if err != nil { // 处理错误 return err } 1.2 为什么Go选择显式错误处理\r优点：\n清晰可见：错误处理逻辑明确，不会隐藏在深处 强制处理：编译器会提醒你处理返回的错误 性能更好：避免了异常处理的性能开销 更可控：程序员完全控制错误处理流程 缺点：\n代码冗长：需要大量的if err != nil检查 容易忽略：新手可能习惯性忽略错误检查 2. error接口详解\r2.1 error接口定义\r// error接口定义在builtin包中 type error interface { Error() string } 2.2 errors包的基本使用\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 创建简单错误 err1 := errors.New(\u0026#34;这是一个简单的错误\u0026#34;) fmt.Printf(\u0026#34;错误1：%v\\n\u0026#34;, err1) fmt.Printf(\u0026#34;错误1类型：%T\\n\u0026#34;, err1) // 使用fmt.Errorf创建格式化错误 name := \u0026#34;张三\u0026#34; age := -5 err2 := fmt.Errorf(\u0026#34;用户 %s 的年龄 %d 无效\u0026#34;, name, age) fmt.Printf(\u0026#34;错误2：%v\\n\u0026#34;, err2) // 错误的字符串表示 fmt.Printf(\u0026#34;错误1的字符串：%s\\n\u0026#34;, err1.Error()) fmt.Printf(\u0026#34;错误2的字符串：%s\\n\u0026#34;, err2.Error()) // nil错误表示没有错误 var noError error fmt.Printf(\u0026#34;nil错误：%v，是否为nil：%t\\n\u0026#34;, noError, noError == nil) } 运行结果：\n错误1：这是一个简单的错误 错误1类型：*errors.errorString 错误2：用户 张三 的年龄 -5 无效 错误1的字符串：这是一个简单的错误 错误2的字符串：用户 张三 的年龄 -5 无效 nil错误：\u0026lt;nil\u0026gt;，是否为nil：true 2.3 自定义错误类型\rpackage main import ( \u0026#34;fmt\u0026#34; ) // 自定义错误类型1：简单结构体 type ValidationError struct { Field string Value interface{} Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;验证错误 - 字段：%s，值：%v，原因：%s\u0026#34;, e.Field, e.Value, e.Message) } // 自定义错误类型2：带错误码 type APIError struct { Code int Message string Details string } func (e APIError) Error() string { return fmt.Sprintf(\u0026#34;API错误[%d]: %s (详情: %s)\u0026#34;, e.Code, e.Message, e.Details) } // 自定义错误类型3：包装其他错误 type WrappedError struct { Operation string Err error } func (e WrappedError) Error() string { return fmt.Sprintf(\u0026#34;操作 %s 失败: %v\u0026#34;, e.Operation, e.Err) } func (e WrappedError) Unwrap() error { return e.Err } // 使用自定义错误的函数 func validateUserAge(age int) error { if age \u0026lt; 0 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Value: age, Message: \u0026#34;年龄不能为负数\u0026#34;, } } if age \u0026gt; 150 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Value: age, Message: \u0026#34;年龄不能超过150岁\u0026#34;, } } return nil } func callAPI(endpoint string) error { if endpoint == \u0026#34;/admin\u0026#34; { return APIError{ Code: 403, Message: \u0026#34;权限不足\u0026#34;, Details: \u0026#34;需要管理员权限才能访问\u0026#34;, } } if endpoint == \u0026#34;/timeout\u0026#34; { return APIError{ Code: 504, Message: \u0026#34;请求超时\u0026#34;, Details: \u0026#34;服务器响应超时\u0026#34;, } } return nil } func processData(data string) error { if data == \u0026#34;\u0026#34; { return WrappedError{ Operation: \u0026#34;数据处理\u0026#34;, Err: errors.New(\u0026#34;输入数据为空\u0026#34;), } } return nil } func main() { fmt.Println(\u0026#34;=== 自定义错误类型演示 ===\u0026#34;) // 测试验证错误 ages := []int{-5, 25, 200} for _, age := range ages { fmt.Printf(\u0026#34;验证年龄 %d: \u0026#34;, age) if err := validateUserAge(age); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;✅ 验证通过\\n\u0026#34;) } } // 测试API错误 endpoints := []string{\u0026#34;/user\u0026#34;, \u0026#34;/admin\u0026#34;, \u0026#34;/timeout\u0026#34;} fmt.Println(\u0026#34;\\n=== API调用测试 ===\u0026#34;) for _, endpoint := range endpoints { fmt.Printf(\u0026#34;调用 %s: \u0026#34;, endpoint) if err := callAPI(endpoint); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;✅ 调用成功\\n\u0026#34;) } } // 测试包装错误 fmt.Println(\u0026#34;\\n=== 包装错误测试 ===\u0026#34;) testData := []string{\u0026#34;\u0026#34;, \u0026#34;有效数据\u0026#34;} for _, data := range testData { fmt.Printf(\u0026#34;处理数据 \u0026#39;%s\u0026#39;: \u0026#34;, data) if err := processData(data); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) // 解包错误 if wrapped, ok := err.(WrappedError); ok { fmt.Printf(\u0026#34; 原始错误: %v\\n\u0026#34;, wrapped.Err) } } else { fmt.Printf(\u0026#34;✅ 处理成功\\n\u0026#34;) } } } 运行结果：\n=== 自定义错误类型演示 === 验证年龄 -5: ❌ 验证错误 - 字段：age，值：-5，原因：年龄不能为负数 验证年龄 25: ✅ 验证通过 验证年龄 200: ❌ 验证错误 - 字段：age，值：200，原因：年龄不能超过150岁 === API调用测试 === 调用 /user: ✅ 调用成功 调用 /admin: ❌ API错误[403]: 权限不足 (详情: 需要管理员权限才能访问) 调用 /timeout: ❌ API错误[504]: 请求超时 (详情: 服务器响应超时) === 包装错误测试 === 处理数据 \u0026#39;\u0026#39;: ❌ 操作 数据处理 失败: 输入数据为空 原始错误: 输入数据为空 处理数据 \u0026#39;有效数据\u0026#39;: ✅ 处理成功 3. 错误检查和处理模式\r3.1 基本错误处理模式\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) // 模式1：立即处理错误 func readFileBasic(filename string) error { file, err := os.Open(filename) if err != nil { return fmt.Errorf(\u0026#34;打开文件失败 %s: %w\u0026#34;, filename, err) } defer file.Close() // 文件操作... fmt.Printf(\u0026#34;成功打开文件：%s\\n\u0026#34;, filename) return nil } // 模式2：错误累积处理 func processMultipleFiles(filenames []string) error { var errors []error for _, filename := range filenames { if err := readFileBasic(filename); err != nil { errors = append(errors, err) } } if len(errors) \u0026gt; 0 { return fmt.Errorf(\u0026#34;处理文件时发生 %d 个错误: %v\u0026#34;, len(errors), errors) } return nil } // 模式3：错误重试 func retryOperation(operation func() error, maxRetries int) error { var lastErr error for i := 0; i \u0026lt; maxRetries; i++ { err := operation() if err == nil { return nil // 成功 } lastErr = err fmt.Printf(\u0026#34;第 %d 次尝试失败：%v\\n\u0026#34;, i+1, err) } return fmt.Errorf(\u0026#34;重试 %d 次后仍然失败，最后错误：%w\u0026#34;, maxRetries, lastErr) } // 模式4：错误忽略（谨慎使用） func ignoreErrors() { // 只在确实可以忽略错误的情况下使用 dir, _ := os.Getwd() // 忽略错误 fmt.Printf(\u0026#34;当前目录：%s\\n\u0026#34;, dir) } func main() { fmt.Println(\u0026#34;=== 基本错误处理模式 ===\u0026#34;) // 测试基本模式 fmt.Println(\u0026#34;1. 基本错误处理：\u0026#34;) if err := readFileBasic(\u0026#34;不存在的文件.txt\u0026#34;); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } // 测试累积模式 fmt.Println(\u0026#34;\\n2. 错误累积处理：\u0026#34;) files := []string{\u0026#34;file1.txt\u0026#34;, \u0026#34;file2.txt\u0026#34;, \u0026#34;file3.txt\u0026#34;} if err := processMultipleFiles(files); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } // 测试重试模式 fmt.Println(\u0026#34;\\n3. 错误重试：\u0026#34;) failingOp := func() error { return fmt.Errorf(\u0026#34;模拟操作失败\u0026#34;) } if err := retryOperation(failingOp, 3); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } // 测试忽略错误 fmt.Println(\u0026#34;\\n4. 错误忽略：\u0026#34;) ignoreErrors() } 运行结果：\n=== 基本错误处理模式 === 1. 基本错误处理： ❌ 打开文件失败 不存在的文件.txt: open 不存在的文件.txt: The system cannot find the file specified. 2. 错误累积处理： ❌ 处理文件时发生 3 个错误: [打开文件失败 file1.txt: open file1.txt: The system cannot find the file specified. 打开文件失败 file2.txt: open file2.txt: The system cannot find the file specified. 打开文件失败 file3.txt: open file3.txt: The system cannot find the file specified.] 3. 错误重试： 第 1 次尝试失败：模拟操作失败 第 2 次尝试失败：模拟操作失败 第 3 次尝试失败：模拟操作失败 ❌ 重试 3 次后仍然失败，最后错误：模拟操作失败 4. 错误忽略： 当前目录：F:\\blog\\zg-blog 3.2 错误类型断言处理\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) type ValidationError struct { Field string Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;验证错误 - %s: %s\u0026#34;, e.Field, e.Message) } type NetworkError struct { Code int Message string } func (e NetworkError) Error() string { return fmt.Sprintf(\u0026#34;网络错误[%d]: %s\u0026#34;, e.Code, e.Message) } func parseAndValidate(input string) error { // 尝试转换为整数 num, err := strconv.Atoi(input) if err != nil { return ValidationError{ Field: \u0026#34;input\u0026#34;, Message: \u0026#34;输入必须是有效的整数\u0026#34;, } } // 验证数值范围 if num \u0026lt; 0 { return ValidationError{ Field: \u0026#34;number\u0026#34;, Message: \u0026#34;数字不能为负数\u0026#34;, } } // 模拟网络操作 if num == 999 { return NetworkError{ Code: 503, Message: \u0026#34;服务暂时不可用\u0026#34;, } } return nil } func handleSpecificErrors() { inputs := []string{\u0026#34;abc\u0026#34;, \u0026#34;-5\u0026#34;, \u0026#34;999\u0026#34;, \u0026#34;42\u0026#34;} for _, input := range inputs { fmt.Printf(\u0026#34;处理输入 \u0026#39;%s\u0026#39;: \u0026#34;, input) err := parseAndValidate(input) if err != nil { // 方法1：类型断言 if validationErr, ok := err.(ValidationError); ok { fmt.Printf(\u0026#34;❌ 验证错误 - 字段：%s，消息：%s\\n\u0026#34;, validationErr.Field, validationErr.Message) continue } // 方法2：类型选择 switch specificErr := err.(type) { case NetworkError: fmt.Printf(\u0026#34;❌ 网络错误 - 代码：%d，消息：%s\\n\u0026#34;, specificErr.Code, specificErr.Message) case ValidationError: fmt.Printf(\u0026#34;❌ 验证错误 - 字段：%s，消息：%s\\n\u0026#34;, specificErr.Field, specificErr.Message) default: fmt.Printf(\u0026#34;❌ 未知错误：%v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34;✅ 处理成功\\n\u0026#34;) } } } func main() { fmt.Println(\u0026#34;=== 错误类型断言处理 ===\u0026#34;) handleSpecificErrors() // 检查文件是否存在 fmt.Println(\u0026#34;\\n=== 文件错误处理 ===\u0026#34;) filenames := []string{\u0026#34;existing.txt\u0026#34;, \u0026#34;missing.txt\u0026#34;} for _, filename := range filenames { fmt.Printf(\u0026#34;检查文件 \u0026#39;%s\u0026#39;: \u0026#34;, filename) _, err := os.Stat(filename) if err != nil { if os.IsNotExist(err) { fmt.Printf(\u0026#34;❌ 文件不存在\\n\u0026#34;) } else if os.IsPermission(err) { fmt.Printf(\u0026#34;❌ 权限不足\\n\u0026#34;) } else { fmt.Printf(\u0026#34;❌ 其他错误：%v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34;✅ 文件存在\\n\u0026#34;) } } } 运行结果：\n=== 错误类型断言处理 === 处理输入 \u0026#39;abc\u0026#39;: ❌ 验证错误 - 字段：input，消息：输入必须是有效的整数 处理输入 \u0026#39;-5\u0026#39;: ❌ 验证错误 - 字段：number，消息：数字不能为负数 处理输入 \u0026#39;999\u0026#39;: ❌ 网络错误 - 代码：503，消息：服务暂时不可用 处理输入 \u0026#39;42\u0026#39;: ✅ 处理成功 === 文件错误处理 === 检查文件 \u0026#39;existing.txt\u0026#39;: ✅ 文件存在 检查文件 \u0026#39;missing.txt\u0026#39;: ❌ 文件不存在 4. 错误包装和上下文\r4.1 errors包的新功能（Go 1.13+）\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) // 模拟数据库操作 func databaseQuery(query string) error { if query == \u0026#34;invalid\u0026#34; { return errors.New(\u0026#34;数据库查询语法错误\u0026#34;) } if query == \u0026#34;timeout\u0026#34; { return errors.New(\u0026#34;数据库连接超时\u0026#34;) } return nil } // 业务层函数 func getUserData(userID string) error { // 验证用户ID if userID == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;用户ID不能为空\u0026#34;) } // 查询数据库 if err := databaseQuery(\u0026#34;SELECT * FROM users WHERE id = \u0026#34; + userID); err != nil { return fmt.Errorf(\u0026#34;获取用户数据失败: %w\u0026#34;, err) // 包装错误 } return nil } // 服务层函数 func handleUserRequest(userID string) error { if err := getUserData(userID); err != nil { return fmt.Errorf(\u0026#34;处理用户请求失败: %w\u0026#34;, err) // 再次包装 } return nil } func demonstrateErrorWrapping() { userIDs := []string{\u0026#34;\u0026#34;, \u0026#34;invalid\u0026#34;, \u0026#34;timeout\u0026#34;, \u0026#34;123\u0026#34;} for _, userID := range userIDs { fmt.Printf(\u0026#34;处理用户请求 UserID=\u0026#39;%s\u0026#39;: \u0026#34;, userID) err := handleUserRequest(userID) if err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) // 检查特定错误 if errors.Is(err, os.ErrNotExist) { fmt.Printf(\u0026#34; 原因：文件不存在\\n\u0026#34;) } // 查找特定类型的错误 var pathError *os.PathError if errors.As(err, \u0026amp;pathError) { fmt.Printf(\u0026#34; 路径错误：操作=%s，路径=%s\\n\u0026#34;, pathError.Op, pathError.Path) } // 打印错误链 fmt.Printf(\u0026#34; 错误链：\u0026#34;) for err != nil { fmt.Printf(\u0026#34;%v\u0026#34;, err) if err = errors.Unwrap(err); err != nil { fmt.Printf(\u0026#34; -\u0026gt; \u0026#34;) } } fmt.Println() } else { fmt.Printf(\u0026#34;✅ 请求处理成功\\n\u0026#34;) } fmt.Println() } } // 自定义可包装错误 type CustomError struct { Code int Message string Err error // 嵌入底层错误 } func (e CustomError) Error() string { if e.Err != nil { return fmt.Sprintf(\u0026#34;自定义错误[%d]: %s (原因: %v)\u0026#34;, e.Code, e.Message, e.Err) } return fmt.Sprintf(\u0026#34;自定义错误[%d]: %s\u0026#34;, e.Code, e.Message) } func (e CustomError) Unwrap() error { return e.Err } func main() { fmt.Println(\u0026#34;=== 错误包装和上下文 ===\u0026#34;) demonstrateErrorWrapping() // 自定义错误包装示例 fmt.Println(\u0026#34;=== 自定义错误包装 ===\u0026#34;) baseErr := errors.New(\u0026#34;底层错误\u0026#34;) wrappedErr := CustomError{ Code: 1001, Message: \u0026#34;业务逻辑错误\u0026#34;, Err: baseErr, } fmt.Printf(\u0026#34;包装错误：%v\\n\u0026#34;, wrappedErr) fmt.Printf(\u0026#34;底层错误：%v\\n\u0026#34;, errors.Unwrap(wrappedErr)) fmt.Printf(\u0026#34;是否有底层错误：%t\\n\u0026#34;, errors.Is(wrappedErr, baseErr)) } 运行结果：\n=== 错误包装和上下文 === 处理用户请求 UserID=\u0026#39;\u0026#39;: ❌ 处理用户请求失败: 获取用户数据失败: 用户ID不能为空 错误链：处理用户请求失败: 获取用户数据失败: 用户ID不能为空 处理用户请求 UserID=\u0026#39;invalid\u0026#39;: ❌ 处理用户请求失败: 获取用户数据失败: 数据库查询语法错误 错误链：处理用户请求失败: 获取用户数据失败: 数据库查询语法错误 处理用户请求 UserID=\u0026#39;timeout\u0026#39;: ❌ 处理用户请求失败: 获取用户数据失败: 数据库连接超时 错误链：处理用户请求失败: 获取用户数据失败: 数据库连接超时 处理用户请求 UserID=\u0026#39;123\u0026#39;: ✅ 请求处理成功 === 自定义错误包装 === 包装错误：自定义错误[1001]: 业务逻辑错误 (原因: 底层错误) 底层错误：底层错误 是否有底层错误：true 4.2 多错误处理\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) // 错误集合类型 type ErrorCollection []error func (ec ErrorCollection) Error() string { if len(ec) == 0 { return \u0026#34;\u0026#34; } var errorMsgs []string for _, err := range ec { errorMsgs = append(errorMsgs, err.Error()) } return fmt.Sprintf(\u0026#34;发生 %d 个错误: %s\u0026#34;, len(ec), strings.Join(errorMsgs, \u0026#34;; \u0026#34;)) } // 并行任务处理 func processTasks(taskNames []string) error { var errorsList ErrorCollection // 模拟并行处理多个任务 for _, taskName := range taskNames { if err := processSingleTask(taskName); err != nil { errorsList = append(errorsList, fmt.Errorf(\u0026#34;任务 \u0026#39;%s\u0026#39; 失败: %w\u0026#34;, taskName, err)) } } if len(errorsList) \u0026gt; 0 { return errorsList } return nil } func processSingleTask(taskName string) error { switch taskName { case \u0026#34;task1\u0026#34;: return errors.New(\u0026#34;网络连接失败\u0026#34;) case \u0026#34;task2\u0026#34;: return errors.New(\u0026#34;文件不存在\u0026#34;) case \u0026#34;task3\u0026#34;: return nil // 成功 case \u0026#34;task4\u0026#34;: return errors.New(\u0026#34;权限不足\u0026#34;) default: return errors.New(\u0026#34;未知任务\u0026#34;) } } // 错误分组处理 func handleGroupedErrors() { taskGroups := [][]string{ {\u0026#34;task1\u0026#34;, \u0026#34;task2\u0026#34;, \u0026#34;task3\u0026#34;}, {\u0026#34;task3\u0026#34;, \u0026#34;task4\u0026#34;}, {\u0026#34;task1\u0026#34;, \u0026#34;task4\u0026#34;, \u0026#34;task5\u0026#34;}, } for i, tasks := range taskGroups { fmt.Printf(\u0026#34;处理任务组 %d %v:\\n\u0026#34;, i+1, tasks) err := processTasks(tasks) if err != nil { if errorCollection, ok := err.(ErrorCollection); ok { fmt.Printf(\u0026#34; ❌ 发生 %d 个错误:\\n\u0026#34;, len(errorCollection)) for j, singleErr := range errorCollection { fmt.Printf(\u0026#34; %d. %v\\n\u0026#34;, j+1, singleErr) } } else { fmt.Printf(\u0026#34; ❌ 单个错误: %v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34; ✅ 所有任务成功完成\\n\u0026#34;) } fmt.Println() } } func main() { fmt.Println(\u0026#34;=== 多错误处理 ===\u0026#34;) handleGroupedErrors() // 错误合并示例 fmt.Println(\u0026#34;=== 错误合并 ===\u0026#34;) err1 := errors.New(\u0026#34;第一个错误\u0026#34;) err2 := errors.New(\u0026#34;第二个错误\u0026#34;) err3 := errors.New(\u0026#34;第三个错误\u0026#34;) combined := ErrorCollection{err1, err2, err3} fmt.Printf(\u0026#34;合并错误：%v\\n\u0026#34;, combined) // 空错误集合 empty := ErrorCollection{} fmt.Printf(\u0026#34;空错误集合：%v，是否为nil：%t\\n\u0026#34;, empty, empty == nil) } 运行结果：\n=== 多错误处理 === 处理任务组 1 [task1 task2 task3]: ❌ 发生 2 个错误: 1. 任务 \u0026#39;task1\u0026#39; 失败: 网络连接失败 2. 任务 \u0026#39;task2\u0026#39; 失败: 文件不存在 处理任务组 2 [task3 task4]: ❌ 发生 1 个错误: 1. 任务 \u0026#39;task4\u0026#39; 失败: 权限不足 处理任务组 3 [task1 task4 task5]: ❌ 发生 3 个错误: 1. 任务 \u0026#39;task1\u0026#39; 失败: 网络连接失败 2. 任务 \u0026#39;task4\u0026#39; 失败: 权限不足 3. 任务 \u0026#39;task5\u0026#39; 失败: 未知任务 === 错误合并 === 合并错误：发生 3 个错误: 第一个错误; 第二个错误; 第三个错误 空错误集合：，是否为nil：true 5. 实际应用中的错误处理\r5.1 Web服务错误处理\rpackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) // API错误响应结构 type APIErrorResponse struct { Error bool `json:\u0026#34;error\u0026#34;` Code int `json:\u0026#34;code\u0026#34;` Message string `json:\u0026#34;message\u0026#34;` Time string `json:\u0026#34;time\u0026#34;` } // 自定义HTTP错误类型 type HTTPError struct { Code int Message string Err error } func (e HTTPError) Error() string { if e.Err != nil { return fmt.Sprintf(\u0026#34;HTTP %d: %s (原因: %v)\u0026#34;, e.Code, e.Message, e.Err) } return fmt.Sprintf(\u0026#34;HTTP %d: %s\u0026#34;, e.Code, e.Message) } // 错误处理中间件 func errorHandler(next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { defer func() { if err := recover(); err != nil { fmt.Printf(\u0026#34;恐慌恢复：%v\\n\u0026#34;, err) sendErrorResponse(w, http.StatusInternalServerError, \u0026#34;内部服务器错误\u0026#34;) } }() next(w, r) } } // 发送错误响应 func sendErrorResponse(w http.ResponseWriter, code int, message string) { response := APIErrorResponse{ Error: true, Code: code, Message: message, Time: time.Now().Format(time.RFC3339), } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(code) if err := json.NewEncoder(w).Encode(response); err != nil { fmt.Printf(\u0026#34;JSON编码错误：%v\\n\u0026#34;, err) } } // 模拟用户服务 type UserService struct{} func (s *UserService) GetUser(id string) (map[string]interface{}, error) { if id == \u0026#34;\u0026#34; { return nil, HTTPError{ Code: http.StatusBadRequest, Message: \u0026#34;用户ID不能为空\u0026#34;, } } if id == \u0026#34;admin\u0026#34; { return nil, HTTPError{ Code: http.StatusForbidden, Message: \u0026#34;禁止访问管理员账户\u0026#34;, } } if id == \u0026#34;missing\u0026#34; { return nil, HTTPError{ Code: http.StatusNotFound, Message: \u0026#34;用户不存在\u0026#34;, } } // 成功情况 return map[string]interface{}{ \u0026#34;id\u0026#34;: id, \u0026#34;name\u0026#34;: fmt.Sprintf(\u0026#34;用户%s\u0026#34;, id), \u0026#34;age\u0026#34;: 25, }, nil } // HTTP处理器 func userHandler(w http.ResponseWriter, r *http.Request) { userID := r.URL.Query().Get(\u0026#34;id\u0026#34;) userService := \u0026amp;UserService{} user, err := userService.GetUser(userID) if err != nil { if httpErr, ok := err.(HTTPError); ok { sendErrorResponse(w, httpErr.Code, httpErr.Message) } else { sendErrorResponse(w, http.StatusInternalServerError, \u0026#34;内部错误\u0026#34;) } return } // 成功响应 w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) json.NewEncoder(w).Encode(user) } func demonstrateWebErrors() { // 模拟HTTP请求处理 testCases := []string{\u0026#34;\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;missing\u0026#34;, \u0026#34;normal\u0026#34;} fmt.Println(\u0026#34;=== Web服务错误处理演示 ===\u0026#34;) for _, userID := range testCases { fmt.Printf(\u0026#34;请求用户ID \u0026#39;%s\u0026#39;: \u0026#34;, userID) // 模拟请求 userService := \u0026amp;UserService{} user, err := userService.GetUser(userID) if err != nil { if httpErr, ok := err.(HTTPError); ok { fmt.Printf(\u0026#34;❌ HTTP错误 %d: %s\\n\u0026#34;, httpErr.Code, httpErr.Message) } else { fmt.Printf(\u0026#34;❌ 未知错误: %v\\n\u0026#34;, err) } } else { fmt.Printf(\u0026#34;✅ 成功获取用户: %+v\\n\u0026#34;, user) } } } func main() { demonstrateWebErrors() // 启动HTTP服务器示例（注释掉避免实际启动） /* http.HandleFunc(\u0026#34;/user\u0026#34;, errorHandler(userHandler)) fmt.Println(\u0026#34;服务器启动在 :8080\u0026#34;) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) */ // 错误日志记录示例 fmt.Println(\u0026#34;\\n=== 错误日志记录 ===\u0026#34;) logError := func(operation string, err error) { fmt.Printf(\u0026#34;[%s] ERROR: %v\\n\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;), err) } // 模拟各种错误场景 errorsToLog := []error{ errors.New(\u0026#34;数据库连接失败\u0026#34;), fmt.Errorf(\u0026#34;文件读取错误: %w\u0026#34;, errors.New(\u0026#34;权限不足\u0026#34;)), HTTPError{Code: 500, Message: \u0026#34;内部服务器错误\u0026#34;}, } for _, err := range errorsToLog { logError(\u0026#34;数据处理\u0026#34;, err) } } 运行结果：\n=== Web服务错误处理演示 === 请求用户ID \u0026#39;\u0026#39;: ❌ HTTP错误 400: 用户ID不能为空 请求用户ID \u0026#39;admin\u0026#39;: ❌ HTTP错误 403: 禁止访问管理员账户 请求用户ID \u0026#39;missing\u0026#39;: ❌ HTTP错误 404: 用户不存在 请求用户ID \u0026#39;normal\u0026#39;: ✅ 成功获取用户: map[age:25 id:normal name:用户normal] === 错误日志记录 === [2024-01-15 15:30:45] ERROR: 数据库连接失败 [2024-01-15 15:30:45] ERROR: 文件读取错误: 权限不足 [2024-01-15 15:30:45] ERROR: HTTP 500: 内部服务器错误 5.2 数据库操作错误处理\rpackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // 模拟数据库驱动 type MockDB struct { tables map[string][]map[string]interface{} } func NewMockDB() *MockDB { return \u0026amp;MockDB{ tables: make(map[string][]map[string]interface{}), } } func (db *MockDB) Query(query string, args ...interface{}) (*sql.Rows, error) { if query == \u0026#34;invalid sql\u0026#34; { return nil, errors.New(\u0026#34;SQL语法错误\u0026#34;) } if query == \u0026#34;timeout\u0026#34; { return nil, errors.New(\u0026#34;查询超时\u0026#34;) } // 模拟成功查询 return \u0026amp;sql.Rows{}, nil } func (db *MockDB) Exec(query string, args ...interface{}) (sql.Result, error) { if query == \u0026#34;duplicate key\u0026#34; { return nil, errors.New(\u0026#34;违反唯一约束\u0026#34;) } if query == \u0026#34;foreign key violation\u0026#34; { return nil, errors.New(\u0026#34;外键约束违规\u0026#34;) } return \u0026amp;mockResult{rowsAffected: 1}, nil } type mockResult struct { rowsAffected int64 } func (r *mockResult) LastInsertId() (int64, error) { return 1, nil } func (r *mockResult) RowsAffected() (int64, error) { return r.rowsAffected, nil } // 数据访问层 type UserRepository struct { db *MockDB } func NewUserRepository(db *MockDB) *UserRepository { return \u0026amp;UserRepository{db: db} } func (r *UserRepository) CreateUser(user map[string]interface{}) error { // 验证用户数据 if user[\u0026#34;name\u0026#34;] == nil || user[\u0026#34;name\u0026#34;] == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;用户名不能为空\u0026#34;) } if user[\u0026#34;email\u0026#34;] == nil || user[\u0026#34;email\u0026#34;] == \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;邮箱不能为空\u0026#34;) } // 执行数据库插入 query := \u0026#34;INSERT INTO users (name, email) VALUES (?, ?)\u0026#34; _, err := r.db.Exec(query, user[\u0026#34;name\u0026#34;], user[\u0026#34;email\u0026#34;]) if err != nil { // 根据不同错误类型返回不同的业务错误 if err.Error() == \u0026#34;违反唯一约束\u0026#34; { return fmt.Errorf(\u0026#34;邮箱地址已存在：%w\u0026#34;, err) } if err.Error() == \u0026#34;外键约束违规\u0026#34; { return fmt.Errorf(\u0026#34;关联数据不存在：%w\u0026#34;, err) } return fmt.Errorf(\u0026#34;数据库操作失败：%w\u0026#34;, err) } return nil } func (r *UserRepository) FindUserByEmail(email string) (map[string]interface{}, error) { if email == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;邮箱地址不能为空\u0026#34;) } query := \u0026#34;SELECT * FROM users WHERE email = ?\u0026#34; rows, err := r.db.Query(query, email) if err != nil { return nil, fmt.Errorf(\u0026#34;查询用户失败：%w\u0026#34;, err) } defer rows.Close() // 模拟查询结果 if email == \u0026#34;notfound@example.com\u0026#34; { return nil, fmt.Errorf(\u0026#34;用户不存在\u0026#34;) } return map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;email\u0026#34;: email, }, nil } func demonstrateDatabaseErrors() { db := NewMockDB() repo := NewUserRepository(db) fmt.Println(\u0026#34;=== 数据库错误处理演示 ===\u0026#34;) // 测试创建用户的各种错误情况 testUsers := []map[string]interface{}{ {\u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@example.com\u0026#34;}, // 名字为空 {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;\u0026#34;}, // 邮箱为空 {\u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;duplicate@example.com\u0026#34;}, // 邮箱重复 {\u0026#34;name\u0026#34;: \u0026#34;王五\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;valid@example.com\u0026#34;}, // 正常情况 } for i, user := range testUsers { fmt.Printf(\u0026#34;测试%d - 创建用户 %+v: \u0026#34;, i+1, user) err := repo.CreateUser(user) if err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;✅ 创建成功\\n\u0026#34;) } } // 测试查询用户 fmt.Println(\u0026#34;\\n=== 查询用户测试 ===\u0026#34;) testEmails := []string{ \u0026#34;\u0026#34;, // 空邮箱 \u0026#34;notfound@example.com\u0026#34;, // 用户不存在 \u0026#34;valid@example.com\u0026#34;, // 正常查询 } for _, email := range testEmails { fmt.Printf(\u0026#34;查询邮箱 \u0026#39;%s\u0026#39;: \u0026#34;, email) user, err := repo.FindUserByEmail(email) if err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;✅ 找到用户: %+v\\n\u0026#34;, user) } } } func main() { demonstrateDatabaseErrors() // 事务错误处理示例 fmt.Println(\u0026#34;\\n=== 事务错误处理 ===\u0026#34;) simulateTransaction := func() error { // 开始事务 fmt.Println(\u0026#34;开始事务...\u0026#34;) // 第一步：创建用户 if err := errors.New(\u0026#34;创建用户失败\u0026#34;); err != nil { fmt.Printf(\u0026#34;❌ 事务步骤1失败：%v\\n\u0026#34;, err) return fmt.Errorf(\u0026#34;事务回滚：创建用户失败 - %w\u0026#34;, err) } // 第二步：创建用户资料 if err := errors.New(\u0026#34;创建资料失败\u0026#34;); err != nil { fmt.Printf(\u0026#34;❌ 事务步骤2失败：%v\\n\u0026#34;, err) return fmt.Errorf(\u0026#34;事务回滚：创建资料失败 - %w\u0026#34;, err) } // 第三步：发送欢迎邮件 if err := errors.New(\u0026#34;发送邮件失败\u0026#34;); err != nil { fmt.Printf(\u0026#34;⚠️ 非关键步骤失败：%v\\n\u0026#34;, err) // 非关键步骤失败，可以选择继续 } fmt.Println(\u0026#34;✅ 事务提交成功\u0026#34;) return nil } if err := simulateTransaction(); err != nil { fmt.Printf(\u0026#34;事务最终失败：%v\\n\u0026#34;, err) } } 运行结果：\n=== 数据库错误处理演示 === 测试1 - 创建用户 map[email:test@example.com name:]: ❌ 用户名不能为空 测试2 - 创建用户 map[email: name:张三]: ❌ 邮箱不能为空 测试3 - 创建用户 map[email:duplicate@example.com name:李四]: ❌ 邮箱地址已存在：违反唯一约束 测试4 - 创建用户 map[email:valid@example.com name:王五]: ✅ 创建成功 === 查询用户测试 === 查询邮箱 \u0026#39;\u0026#39;: ❌ 邮箱地址不能为空 查询邮箱 \u0026#39;notfound@example.com\u0026#39;: ❌ 用户不存在 查询邮箱 \u0026#39;valid@example.com\u0026#39;: ✅ 找到用户: map[email:valid@example.com id:1 name:张三] === 事务错误处理 === 开始事务... ❌ 事务步骤1失败：创建用户失败 事务最终失败：事务回滚：创建用户失败 - 创建用户失败 6. 错误处理最佳实践\r6.1 错误处理原则\rpackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) // 好的错误处理实践 // 1. 及时处理错误，不要延迟 func goodErrorHandling1() error { data, err := readConfig() if err != nil { return fmt.Errorf(\u0026#34;读取配置失败: %w\u0026#34;, err) // 立即处理 } if err := validateConfig(data); err != nil { return fmt.Errorf(\u0026#34;配置验证失败: %w\u0026#34;, err) // 立即处理 } return nil } // 2. 提供有意义的错误信息 func goodErrorHandling2(filename string) error { file, err := openFile(filename) if err != nil { // 好的错误信息包含上下文 return fmt.Errorf(\u0026#34;无法打开配置文件 \u0026#39;%s\u0026#39;: %w\u0026#34;, filename, err) } defer file.Close() return nil } // 3. 区分不同类型的错误 func goodErrorHandling3(userID string) error { user, err := findUser(userID) if err != nil { // 根据错误类型采取不同行动 switch { case errors.Is(err, ErrUserNotFound): return fmt.Errorf(\u0026#34;用户不存在，请先注册\u0026#34;) case errors.Is(err, ErrDatabaseDown): return fmt.Errorf(\u0026#34;系统维护中，请稍后再试\u0026#34;) default: return fmt.Errorf(\u0026#34;获取用户信息失败: %w\u0026#34;, err) } } if !user.IsActive { return fmt.Errorf(\u0026#34;用户账号已被禁用\u0026#34;) } return nil } // 4. 记录错误但不暴露内部细节 func goodErrorHandling4() { if err := sensitiveOperation(); err != nil { // 记录详细错误到日志 log.Printf(\u0026#34;敏感操作失败（内部错误）：%+v\u0026#34;, err) // 返回通用错误给用户 fmt.Println(\u0026#34;操作失败，请联系管理员\u0026#34;) } } // 模拟函数 func readConfig() (interface{}, error) { return nil, errors.New(\u0026#34;文件不存在\u0026#34;) } func validateConfig(data interface{}) error { return errors.New(\u0026#34;配置格式错误\u0026#34;) } func openFile(filename string) (interface{}, error) { return nil, errors.New(\u0026#34;权限被拒绝\u0026#34;) } var ( ErrUserNotFound = errors.New(\u0026#34;用户不存在\u0026#34;) ErrDatabaseDown = errors.New(\u0026#34;数据库宕机\u0026#34;) ) func findUser(userID string) (interface{}, error) { return nil, ErrUserNotFound } type User struct { IsActive bool } func sensitiveOperation() error { return errors.New(\u0026#34;内部数据库凭证泄露\u0026#34;) } // 不好的错误处理实践 // 1. 忽略错误 func badErrorHandling1() { data, _ := readConfig() // 错误被忽略 processConfig(data) // 可能使用nil数据 } // 2. 错误信息不明确 func badErrorHandling2(filename string) error { _, err := openFile(filename) if err != nil { return err // 错误信息太简单 } return nil } // 3. 过度包装错误 func badErrorHandling3() error { err := lowLevelError() if err != nil { return fmt.Errorf(\u0026#34;高层错误: %w\u0026#34;, fmt.Errorf(\u0026#34;中层错误: %w\u0026#34;, fmt.Errorf(\u0026#34;底层错误: %w\u0026#34;, err))) // 过度包装 } return nil } func lowLevelError() error { return errors.New(\u0026#34;底层错误\u0026#34;) } func processConfig(data interface{}) { // 处理配置 } func main() { fmt.Println(\u0026#34;=== 错误处理最佳实践 ===\u0026#34;) fmt.Println(\u0026#34;好的实践示例：\u0026#34;) if err := goodErrorHandling1(); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } if err := goodErrorHandling2(\u0026#34;config.json\u0026#34;); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } if err := goodErrorHandling3(\u0026#34;user123\u0026#34;); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } goodErrorHandling4() fmt.Println(\u0026#34;\\n避免的坏实践：\u0026#34;) fmt.Println(\u0026#34;1. 忽略错误可能导致程序崩溃\u0026#34;) fmt.Println(\u0026#34;2. 不明确的错误信息难以调试\u0026#34;) fmt.Println(\u0026#34;3. 过度包装使错误链过于复杂\u0026#34;) // 演示错误日志的最佳实践 fmt.Println(\u0026#34;\\n=== 错误日志最佳实践 ===\u0026#34;) logError := func(context string, err error) { // 开发环境：详细日志 log.Printf(\u0026#34;[DEBUG] %s 失败: %+v\u0026#34;, context, err) // 生产环境：简化日志 log.Printf(\u0026#34;[ERROR] %s 失败，请查看详细日志\u0026#34;, context) } // 模拟错误记录 sampleErr := fmt.Errorf(\u0026#34;数据库连接失败: %w\u0026#34;, errors.New(\u0026#34;网络超时\u0026#34;)) logError(\u0026#34;用户登录\u0026#34;, sampleErr) } 运行结果：\n=== 错误处理最佳实践 === 好的实践示例： ❌ 读取配置失败: 文件不存在 ❌ 无法打开配置文件 \u0026#39;config.json\u0026#39;: 权限被拒绝 ❌ 用户不存在，请先注册 操作失败，请联系管理员 避免的坏实践： 1. 忽略错误可能导致程序崩溃 2. 不明确的错误信息难以调试 3. 过度包装使错误链过于复杂 === 错误日志最佳实践 === 2024/01/15 15:30:45 [DEBUG] 用户登录 失败: 数据库连接失败: 网络超时 2024/01/15 15:30:45 [ERROR] 用户登录 失败，请查看详细日志 7. 总结\rGo语言的错误处理机制体现了其\u0026quot;简单、明确、实用\u0026quot;的设计哲学：\n核心要点：\n错误是值，应该被显式检查和处理 使用error接口统一错误表示 通过errors包提供现代错误处理功能 合理使用错误包装和上下文信息 最佳实践：\n及时处理：发现错误立即处理，不要延迟 提供上下文：错误信息应该包含足够的上下文 区分错误类型：根据错误类型采取不同处理策略 记录详细日志：内部记录详细错误，对外返回适当信息 避免错误忽略：除非确实可以忽略，否则都应该处理 现代发展：\nGo 1.13+ 引入了错误包装和检查的新功能 errors.Is() 和 errors.As() 提供了更好的错误检查能力 fmt.Errorf() 的 %w 动词支持错误包装 良好的错误处理不仅能提高程序的健壮性，还能大大改善用户体验和系统的可维护性。在实际开发中，应该根据具体场景选择合适的错误处理策略。\n","date":"2026-02-04T20:15:16+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-12/","title":"Golang学习历程【第十二篇 错误处理(error)】"},{"content":"1. 什么是接口\r接口是Go语言中实现抽象和多态的核心机制。如果说结构体解决了\u0026quot;数据是什么\u0026quot;的问题，那么接口解决的就是\u0026quot;能做什么\u0026quot;的问题。接口定义了一组方法签名，任何实现了这些方法的类型都\u0026quot;实现\u0026quot;了该接口。\n1.1 接口的基本概念\r让我们通过一个生活中的例子来理解接口：\n现实场景：\nUSB接口：定义了数据传输的标准 任何符合USB标准的设备（U盘、鼠标、键盘）都可以插入使用 我们不需要关心具体是什么设备，只要符合USB标准就行 编程场景：\n接口定义了方法签名（能做什么） 任何实现了这些方法的类型都自动实现了该接口 我们可以面向接口编程，而不关心具体实现 1.2 接口的价值和意义\r接口的主要作用：\n解耦合：分离接口定义和具体实现 多态性：同一接口可以有多种实现 抽象性：隐藏具体实现细节 可扩展性：易于添加新的实现 测试友好：便于编写mock测试 2. 接口的基本语法\r2.1 接口定义语法\rtype 接口名 interface { 方法名1(参数列表) 返回值列表 方法名2(参数列表) 返回值列表 // ... 更多方法 } 2.2 简单接口示例\rpackage main import \u0026#34;fmt\u0026#34; // 定义动物接口 type Animal interface { Speak() string // 说话方法 Move() string // 移动方法 GetAge() int // 获取年龄方法 } // 狗的实现 type Dog struct { Name string Age int } func (d Dog) Speak() string { return \u0026#34;汪汪\u0026#34; } func (d Dog) Move() string { return \u0026#34;跑步\u0026#34; } func (d Dog) GetAge() int { return d.Age } // 猫的实现 type Cat struct { Name string Age int } func (c Cat) Speak() string { return \u0026#34;喵喵\u0026#34; } func (c Cat) Move() string { return \u0026#34;爬行\u0026#34; } func (c Cat) GetAge() int { return c.Age } // 鸟的实现 type Bird struct { Species string Age int } func (b Bird) Speak() string { return \u0026#34;啾啾\u0026#34; } func (b Bird) Move() string { return \u0026#34;飞翔\u0026#34; } func (b Bird) GetAge() int { return b.Age } // 使用接口的函数 func MakeAnimalSpeak(animal Animal) { fmt.Printf(\u0026#34;动物说话：%s\\n\u0026#34;, animal.Speak()) } func ShowAnimalMove(animal Animal) { fmt.Printf(\u0026#34;动物移动方式：%s\\n\u0026#34;, animal.Move()) } func main() { // 创建不同类型的动物 dog := Dog{Name: \u0026#34;旺财\u0026#34;, Age: 3} cat := Cat{Name: \u0026#34;咪咪\u0026#34;, Age: 2} bird := Bird{Species: \u0026#34;鹦鹉\u0026#34;, Age: 1} // 都可以当作Animal接口使用 animals := []Animal{dog, cat, bird} fmt.Println(\u0026#34;=== 动物表演 ===\u0026#34;) for i, animal := range animals { fmt.Printf(\u0026#34;第%d个动物：\\n\u0026#34;, i+1) MakeAnimalSpeak(animal) ShowAnimalMove(animal) fmt.Printf(\u0026#34;年龄：%d岁\\n\\n\u0026#34;, animal.GetAge()) } // 直接使用具体类型 fmt.Println(\u0026#34;=== 具体类型调用 ===\u0026#34;) fmt.Printf(\u0026#34;狗说话：%s\\n\u0026#34;, dog.Speak()) fmt.Printf(\u0026#34;猫移动：%s\\n\u0026#34;, cat.Move()) fmt.Printf(\u0026#34;鸟年龄：%d\\n\u0026#34;, bird.GetAge()) } 运行结果：\n=== 动物表演 === 第1个动物： 动物说话：汪汪 动物移动方式：跑步 年龄：3岁 第2个动物： 动物说话：喵喵 动物移动方式：爬行 年龄：2岁 第3个动物： 动物说话：啾啾 动物移动方式：飞翔 年龄：1岁 === 具体类型调用 === 狗说话：汪汪 猫移动：爬行 鸟年龄：1 3. 接口的实现机制\r3.1 隐式实现\rGo语言的接口实现是隐式的，不需要显式声明：\npackage main import \u0026#34;fmt\u0026#34; // 定义接口 type Writer interface { Write(data string) (int, error) } type Reader interface { Read() (string, error) } // 文件类型实现 type File struct { Name string Content string Pos int } func (f *File) Write(data string) (int, error) { f.Content += data return len(data), nil } func (f *File) Read() (string, error) { if f.Pos \u0026gt;= len(f.Content) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;读取结束\u0026#34;) } result := f.Content[f.Pos:] f.Pos = len(f.Content) return result, nil } // 网络连接类型实现 type NetworkConnection struct { Address string Buffer string } func (nc *NetworkConnection) Write(data string) (int, error) { nc.Buffer += data fmt.Printf(\u0026#34;网络发送到 %s: %s\\n\u0026#34;, nc.Address, data) return len(data), nil } func (nc *NetworkConnection) Read() (string, error) { if nc.Buffer == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;缓冲区为空\u0026#34;) } result := nc.Buffer nc.Buffer = \u0026#34;\u0026#34; return result, nil } // 使用接口的通用函数 func ProcessData(w Writer, r Reader, data string) { // 写入数据 n, err := w.Write(data) if err != nil { fmt.Printf(\u0026#34;写入错误：%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;成功写入%d个字符\\n\u0026#34;, n) // 读取数据 content, err := r.Read() if err != nil { fmt.Printf(\u0026#34;读取错误：%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;读取内容：%s\\n\u0026#34;, content) } func main() { // 文件操作 file := \u0026amp;File{Name: \u0026#34;test.txt\u0026#34;} fmt.Println(\u0026#34;=== 文件操作 ===\u0026#34;) ProcessData(file, file, \u0026#34;Hello, File!\u0026#34;) // 网络操作 conn := \u0026amp;NetworkConnection{Address: \u0026#34;192.168.1.1:8080\u0026#34;} fmt.Println(\u0026#34;\\n=== 网络操作 ===\u0026#34;) ProcessData(conn, conn, \u0026#34;Hello, Network!\u0026#34;) // 混合使用 fmt.Println(\u0026#34;\\n=== 混合操作 ===\u0026#34;) ProcessData(file, conn, \u0026#34;Mixed operation test\u0026#34;) } 运行结果：\n=== 文件操作 === 成功写入11个字符 读取内容：Hello, File! === 网络操作 === 网络发送到 192.168.1.1:8080: Hello, Network! 成功写入15个字符 读取内容：Hello, Network! === 混合操作 === 成功写入21个字符 网络发送到 192.168.1.1:8080: Hello, File! 读取内容：Hello, File! 3.2 接口值的内部结构\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;unsafe\u0026#34; ) type Speaker interface { Speak() string } type Dog struct { Name string } func (d Dog) Speak() string { return \u0026#34;汪汪，我是\u0026#34; + d.Name } type Cat struct { Name string } func (c Cat) Speak() string { return \u0026#34;喵喵，我是\u0026#34; + c.Name } func InspectInterface(i interface{}) { v := reflect.ValueOf(i) fmt.Printf(\u0026#34;类型：%T\\n\u0026#34;, i) fmt.Printf(\u0026#34;值：%v\\n\u0026#34;, i) fmt.Printf(\u0026#34;是否为nil：%t\\n\u0026#34;, i == nil) if v.Kind() == reflect.Interface { elem := v.Elem() fmt.Printf(\u0026#34;动态类型：%T\\n\u0026#34;, elem.Interface()) fmt.Printf(\u0026#34;动态值：%v\\n\u0026#34;, elem.Interface()) } fmt.Println(\u0026#34;---\u0026#34;) } func main() { // nil接口值 var speaker1 Speaker fmt.Println(\u0026#34;1. nil接口值：\u0026#34;) InspectInterface(speaker1) // 具体类型赋值 dog := Dog{Name: \u0026#34;旺财\u0026#34;} speaker1 = dog fmt.Println(\u0026#34;2. 赋值Dog后：\u0026#34;) InspectInterface(speaker1) // 不同类型赋值 cat := Cat{Name: \u0026#34;咪咪\u0026#34;} speaker1 = cat fmt.Println(\u0026#34;3. 赋值Cat后：\u0026#34;) InspectInterface(speaker1) // 接口切片 speakers := []Speaker{dog, cat} fmt.Println(\u0026#34;4. 接口切片：\u0026#34;) for i, s := range speakers { fmt.Printf(\u0026#34;索引%d: %T - %s\\n\u0026#34;, i, s, s.Speak()) } } 运行结果：\n1. nil接口值： 类型：\u0026lt;nil\u0026gt; 值：\u0026lt;nil\u0026gt; 是否为nil：true --- 2. 赋值Dog后： 类型：main.Dog 值：{旺财} 是否为nil：false 动态类型：main.Dog 动态值：{旺财} --- 3. 赋值Cat后： 类型：main.Cat 值：{咪咪} 是否为nil：false 动态类型：main.Cat 动态值：{咪咪} --- 4. 接口切片： 索引0: main.Dog - 汪汪，我是旺财 索引1: main.Cat - 喵喵，我是咪咪 4. 常用内置接口\r4.1 error接口\rpackage main import ( \u0026#34;fmt\u0026#34; ) // error接口的定义 // type error interface { // Error() string // } // 自定义错误类型 type ValidationError struct { Field string Message string } func (e ValidationError) Error() string { return fmt.Sprintf(\u0026#34;验证错误 - 字段：%s，消息：%s\u0026#34;, e.Field, e.Message) } type NetworkError struct { Code int Message string } func (e NetworkError) Error() string { return fmt.Sprintf(\u0026#34;网络错误[%d]: %s\u0026#34;, e.Code, e.Message) } // 返回error的函数 func ValidateAge(age int) error { if age \u0026lt; 0 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Message: \u0026#34;年龄不能为负数\u0026#34;, } } if age \u0026gt; 150 { return ValidationError{ Field: \u0026#34;age\u0026#34;, Message: \u0026#34;年龄不能超过150岁\u0026#34;, } } return nil // 没有错误 } func ConnectToServer(url string) error { if url == \u0026#34;\u0026#34; { return NetworkError{ Code: 400, Message: \u0026#34;URL不能为空\u0026#34;, } } if url == \u0026#34;timeout.com\u0026#34; { return NetworkError{ Code: 504, Message: \u0026#34;连接超时\u0026#34;, } } return nil // 连接成功 } func main() { // 测试验证错误 ages := []int{-5, 25, 200} for _, age := range ages { fmt.Printf(\u0026#34;验证年龄 %d: \u0026#34;, age) if err := ValidateAge(age); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;✅ 验证通过\\n\u0026#34;) } } // 测试网络错误 urls := []string{\u0026#34;\u0026#34;, \u0026#34;timeout.com\u0026#34;, \u0026#34;google.com\u0026#34;} fmt.Println(\u0026#34;\\n=== 网络连接测试 ===\u0026#34;) for _, url := range urls { fmt.Printf(\u0026#34;连接 %s: \u0026#34;, url) if err := ConnectToServer(url); err != nil { fmt.Printf(\u0026#34;❌ %v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;✅ 连接成功\\n\u0026#34;) } } // 错误类型断言 fmt.Println(\u0026#34;\\n=== 错误类型分析 ===\u0026#34;) err := ValidateAge(-1) if err != nil { if validationErr, ok := err.(ValidationError); ok { fmt.Printf(\u0026#34;这是验证错误：字段=%s, 消息=%s\\n\u0026#34;, validationErr.Field, validationErr.Message) } } } 运行结果：\n验证年龄 -5: ❌ 验证错误 - 字段：age，消息：年龄不能为负数 验证年龄 25: ✅ 验证通过 验证年龄 200: ❌ 验证错误 - 字段：age，消息：年龄不能超过150岁 === 网络连接测试 === 连接 : ❌ 网络错误[400]: URL不能为空 连接 timeout.com: ❌ 网络错误[504]: 连接超时 连接 google.com: ✅ 连接成功 === 错误类型分析 === 这是验证错误：字段=age, 消息=年龄不能为负数 4.2 Stringer接口\rpackage main import ( \u0026#34;fmt\u0026#34; ) // Stringer接口定义 // type Stringer interface { // String() string // } type Person struct { Name string Age int City string } func (p Person) String() string { return fmt.Sprintf(\u0026#34;姓名：%s，年龄：%d岁，来自：%s\u0026#34;, p.Name, p.Age, p.City) } type Product struct { Name string Price float64 Stock int } func (p Product) String() string { return fmt.Sprintf(\u0026#34;商品：%s，价格：¥%.2f，库存：%d件\u0026#34;, p.Name, p.Price, p.Stock) } type Point struct { X, Y int } func (p Point) String() string { return fmt.Sprintf(\u0026#34;(%d, %d)\u0026#34;, p.X, p.Y) } func main() { // 创建各种对象 person := Person{Name: \u0026#34;张三\u0026#34;, Age: 25, City: \u0026#34;北京\u0026#34;} product := Product{Name: \u0026#34;iPhone 15\u0026#34;, Price: 5999.00, Stock: 100} point := Point{X: 10, Y: 20} // 直接打印会自动调用String()方法 fmt.Println(\u0026#34;=== 自动调用String()方法 ===\u0026#34;) fmt.Println(person) fmt.Println(product) fmt.Println(point) // 显式调用String()方法 fmt.Println(\u0026#34;\\n=== 显式调用String()方法 ===\u0026#34;) fmt.Println(\u0026#34;Person字符串表示：\u0026#34;, person.String()) fmt.Println(\u0026#34;Product字符串表示：\u0026#34;, product.String()) fmt.Println(\u0026#34;Point字符串表示：\u0026#34;, point.String()) // 在格式化中的使用 fmt.Println(\u0026#34;\\n=== 格式化输出 ===\u0026#34;) fmt.Printf(\u0026#34;个人信息：%s\\n\u0026#34;, person) fmt.Printf(\u0026#34;商品信息：%s\\n\u0026#34;, product) fmt.Printf(\u0026#34;坐标信息：%s\\n\u0026#34;, point) // 切片和映射 people := []Person{ {Name: \u0026#34;李四\u0026#34;, Age: 30, City: \u0026#34;上海\u0026#34;}, {Name: \u0026#34;王五\u0026#34;, Age: 28, City: \u0026#34;广州\u0026#34;}, } fmt.Println(\u0026#34;\\n=== 对象切片 ===\u0026#34;) fmt.Println(people) } 运行结果：\n=== 自动调用String()方法 === 姓名：张三，年龄：25岁，来自：北京 商品：iPhone 15，价格：¥5999.00，库存：100件 (10, 20) === 显式调用String()方法 === Person字符串表示： 姓名：张三，年龄：25岁，来自：北京 Product字符串表示： 商品：iPhone 15，价格：¥5999.00，库存：100件 Point字符串表示： (10, 20) === 格式化输出 === 个人信息：姓名：张三，年龄：25岁，来自：北京 商品信息：商品：iPhone 15，价格：¥5999.00，库存：100件 坐标信息：(10, 20) === 对象切片 === [{李四 30 上海} {王五 28 广州}] 5. 接口组合和嵌套\r5.1 接口组合\rpackage main import \u0026#34;fmt\u0026#34; // 基础接口 type Reader interface { Read() (string, error) } type Writer interface { Write(data string) (int, error) } type Closer interface { Close() error } // 组合接口 type ReadWriter interface { Reader // 嵌入Reader接口 Writer // 嵌入Writer接口 } type ReadWriteCloser interface { Reader // 读取功能 Writer // 写入功能 Closer // 关闭功能 } // 具体实现 type File struct { Name string Content string Closed bool } func (f *File) Read() (string, error) { if f.Closed { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;文件已关闭\u0026#34;) } return f.Content, nil } func (f *File) Write(data string) (int, error) { if f.Closed { return 0, fmt.Errorf(\u0026#34;文件已关闭\u0026#34;) } f.Content += data return len(data), nil } func (f *File) Close() error { f.Closed = true fmt.Printf(\u0026#34;文件 %s 已关闭\\n\u0026#34;, f.Name) return nil } // 网络连接实现 type NetworkConnection struct { Address string Buffer string Closed bool } func (nc *NetworkConnection) Read() (string, error) { if nc.Closed { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;连接已关闭\u0026#34;) } if nc.Buffer == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;缓冲区为空\u0026#34;) } result := nc.Buffer nc.Buffer = \u0026#34;\u0026#34; return result, nil } func (nc *NetworkConnection) Write(data string) (int, error) { if nc.Closed { return 0, fmt.Errorf(\u0026#34;连接已关闭\u0026#34;) } nc.Buffer += data fmt.Printf(\u0026#34;发送到 %s: %s\\n\u0026#34;, nc.Address, data) return len(data), nil } func (nc *NetworkConnection) Close() error { nc.Closed = true fmt.Printf(\u0026#34;网络连接 %s 已关闭\\n\u0026#34;, nc.Address) return nil } // 使用组合接口的函数 func ProcessData(rwc ReadWriteCloser, data string) error { // 写入数据 _, err := rwc.Write(data) if err != nil { return err } // 读取数据 content, err := rwc.Read() if err != nil { return err } fmt.Printf(\u0026#34;读取到数据：%s\\n\u0026#34;, content) // 关闭资源 return rwc.Close() } func main() { // 文件操作 file := \u0026amp;File{Name: \u0026#34;test.txt\u0026#34;} fmt.Println(\u0026#34;=== 文件操作 ===\u0026#34;) err := ProcessData(file, \u0026#34;Hello, File System!\u0026#34;) if err != nil { fmt.Printf(\u0026#34;文件操作错误：%v\\n\u0026#34;, err) } // 网络操作 conn := \u0026amp;NetworkConnection{Address: \u0026#34;192.168.1.100:8080\u0026#34;} fmt.Println(\u0026#34;\\n=== 网络操作 ===\u0026#34;) err = ProcessData(conn, \u0026#34;Hello, Network!\u0026#34;) if err != nil { fmt.Printf(\u0026#34;网络操作错误：%v\\n\u0026#34;, err) } // 验证接口兼容性 fmt.Println(\u0026#34;\\n=== 接口兼容性测试 ===\u0026#34;) var rw ReadWriter = file fmt.Printf(\u0026#34;File实现了ReadWriter接口：%t\\n\u0026#34;, rw != nil) var reader Reader = conn fmt.Printf(\u0026#34;NetworkConnection实现了Reader接口：%t\\n\u0026#34;, reader != nil) } 运行结果：\n=== 文件操作 === 读取到数据：Hello, File System! 文件 test.txt 已关闭 === 网络操作 === 发送到 192.168.1.100:8080: Hello, Network! 读取到数据：Hello, Network! 网络连接 192.168.1.100:8080 已关闭 === 接口兼容性测试 === File实现了ReadWriter接口：true NetworkConnection实现了Reader接口：true 6. 空接口和类型断言\r6.1 空接口 interface\rpackage main import ( \u0026#34;fmt\u0026#34; ) // 空接口可以存储任何类型的值 func PrintAnything(v interface{}) { fmt.Printf(\u0026#34;值：%v，类型：%T\\n\u0026#34;, v, v) } func GetTypeDescription(v interface{}) string { switch v.(type) { case int: return \u0026#34;这是一个整数\u0026#34; case string: return \u0026#34;这是一个字符串\u0026#34; case bool: return \u0026#34;这是一个布尔值\u0026#34; case []int: return \u0026#34;这是一个整数切片\u0026#34; case map[string]int: return \u0026#34;这是一个字符串到整数的映射\u0026#34; default: return fmt.Sprintf(\u0026#34;这是 %T 类型的值\u0026#34;, v) } } func main() { // 空接口可以存储任何类型 values := []interface{}{ 42, \u0026#34;Hello\u0026#34;, true, 3.14, []int{1, 2, 3}, map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}, struct{ Name string }{Name: \u0026#34;张三\u0026#34;}, } fmt.Println(\u0026#34;=== 空接口存储不同类型 ===\u0026#34;) for i, v := range values { fmt.Printf(\u0026#34;索引%d: %v\\n\u0026#34;, i, GetTypeDescription(v)) PrintAnything(v) } // 空接口的实际应用 fmt.Println(\u0026#34;\\n=== 实际应用场景 ===\u0026#34;) // 1. 通用容器 container := make(map[string]interface{}) container[\u0026#34;name\u0026#34;] = \u0026#34;张三\u0026#34; container[\u0026#34;age\u0026#34;] = 25 container[\u0026#34;scores\u0026#34;] = []int{85, 92, 78} container[\u0026#34;active\u0026#34;] = true fmt.Println(\u0026#34;通用容器内容：\u0026#34;) for key, value := range container { fmt.Printf(\u0026#34; %s: %v (%T)\\n\u0026#34;, key, value, value) } // 2. 函数参数 processData := func(data interface{}) { switch v := data.(type) { case string: fmt.Printf(\u0026#34;处理字符串：%s (长度: %d)\\n\u0026#34;, v, len(v)) case int: fmt.Printf(\u0026#34;处理整数：%d (平方: %d)\\n\u0026#34;, v, v*v) case []int: sum := 0 for _, n := range v { sum += n } fmt.Printf(\u0026#34;处理整数切片：总和=%d\\n\u0026#34;, sum) default: fmt.Printf(\u0026#34;处理未知类型：%T\\n\u0026#34;, v) } } processData(\u0026#34;Hello World\u0026#34;) processData(5) processData([]int{1, 2, 3, 4, 5}) } 运行结果：\n=== 空接口存储不同类型 === 索引0: 这是一个整数 值：42，类型：int 索引1: 这是一个字符串 值：Hello，类型：string 索引2: 这是一个布尔值 值：true，类型：bool 索引3: 这是 float64 类型的值 值：3.14，类型：float64 索引4: 这是一个整数切片 值：[1 2 3]，类型：[]int 索引5: 这是一个字符串到整数的映射 值：map[a:1 b:2]，类型：map[string]int 索引6: 这是 struct { Name string } 类型的值 值：{张三}，类型：struct { Name string } === 实际应用场景 === 通用容器内容： active: true (bool) age: 25 (int) name: 张三 (string) scores: [85 92 78] ([]int) 处理字符串：Hello World (长度: 11) 处理整数：5 (平方: 25) 处理整数切片：总和=15 6.2 类型断言\rpackage main import \u0026#34;fmt\u0026#34; func ProcessValue(v interface{}) { fmt.Printf(\u0026#34;处理值：%v (类型：%T)\\n\u0026#34;, v, v) // 方法1：类型断言（单个类型） if str, ok := v.(string); ok { fmt.Printf(\u0026#34; ✅ 这是字符串，长度：%d，内容：%s\\n\u0026#34;, len(str), str) } if num, ok := v.(int); ok { fmt.Printf(\u0026#34; ✅ 这是整数，值：%d，平方：%d\\n\u0026#34;, num, num*num) } // 方法2：类型选择（switch） switch value := v.(type) { case string: fmt.Printf(\u0026#34; 🔤 字符串处理：转大写：%s\\n\u0026#34;, stringToUpper(value)) case int: fmt.Printf(\u0026#34; 🔢 整数处理：判断奇偶：%s\\n\u0026#34;, evenOrOdd(value)) case bool: fmt.Printf(\u0026#34; 🔘 布尔处理：取反：%t\\n\u0026#34;, !value) case []int: fmt.Printf(\u0026#34; 📊 切片处理：求和：%d\\n\u0026#34;, sumSlice(value)) case nil: fmt.Printf(\u0026#34; ⚠️ 空值处理\\n\u0026#34;) default: fmt.Printf(\u0026#34; ❓ 未知类型处理：%T\\n\u0026#34;, value) } fmt.Println() } func stringToUpper(s string) string { result := make([]rune, len(s)) for i, r := range s { if r \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;z\u0026#39; { result[i] = r - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; } else { result[i] = r } } return string(result) } func evenOrOdd(n int) string { if n%2 == 0 { return \u0026#34;偶数\u0026#34; } return \u0026#34;奇数\u0026#34; } func sumSlice(nums []int) int { sum := 0 for _, n := range nums { sum += n } return sum } func main() { // 测试不同类型 testData := []interface{}{ \u0026#34;Hello World\u0026#34;, 42, true, []int{1, 2, 3, 4, 5}, 3.14, nil, } fmt.Println(\u0026#34;=== 类型断言演示 ===\u0026#34;) for _, data := range testData { ProcessValue(data) } // 安全的类型转换示例 fmt.Println(\u0026#34;=== 安全类型转换 ===\u0026#34;) var unknown interface{} = \u0026#34;测试字符串\u0026#34; // 安全转换 if str, ok := unknown.(string); ok { fmt.Printf(\u0026#34;安全转换成功：%s\\n\u0026#34;, str) } else { fmt.Printf(\u0026#34;转换失败，不是字符串类型\\n\u0026#34;) } // 不安全转换（会panic） // str := unknown.(string) // 如果unknown不是string会panic // 批量处理示例 fmt.Println(\u0026#34;\\n=== 批量数据处理 ===\u0026#34;) mixedData := []interface{}{1, \u0026#34;two\u0026#34;, 3.0, true, \u0026#34;five\u0026#34;} strings := make([]string, 0) numbers := make([]int, 0) for _, item := range mixedData { switch v := item.(type) { case string: strings = append(strings, v) case int: numbers = append(numbers, v) } } fmt.Printf(\u0026#34;提取的字符串：%v\\n\u0026#34;, strings) fmt.Printf(\u0026#34;提取的数字：%v\\n\u0026#34;, numbers) } 运行结果：\n=== 类型断言演示 === 处理值：Hello World (类型：string) ✅ 这是字符串，长度：11，内容：Hello World 🔤 字符串处理：转大写：HELLO WORLD 处理值：42 (类型：int) ✅ 这是整数，值：42，平方：1764 🔢 整数处理：判断奇偶：偶数 处理值：true (类型：bool) 🔘 布尔处理：取反：false 处理值：[1 2 3 4 5] (类型：[]int) 📊 切片处理：求和：15 处理值：3.14 (类型：float64) ❓ 未知类型处理：float64 处理值：\u0026lt;nil\u0026gt; (类型：\u0026lt;nil\u0026gt;) ⚠️ 空值处理 === 安全类型转换 === 安全转换成功：测试字符串 === 批量数据处理 === 提取的字符串：[two five] 提取的数字：[1] 7. 接口的最佳实践\r7.1 接口设计原则\rpackage main import \u0026#34;fmt\u0026#34; // 好的接口设计：小而专一 type Shape interface { Area() float64 } type Drawable interface { Draw() } type Movable interface { Move(dx, dy float64) } // 组合使用 type Graphic interface { Shape Drawable Movable } // 具体实现 type Rectangle struct { Width, Height float64 X, Y float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r Rectangle) Draw() { fmt.Printf(\u0026#34;绘制矩形：宽=%.1f, 高=%.1f\\n\u0026#34;, r.Width, r.Height) } func (r *Rectangle) Move(dx, dy float64) { r.X += dx r.Y += dy fmt.Printf(\u0026#34;矩形移动到：(%.1f, %.1f)\\n\u0026#34;, r.X, r.Y) } // 不好的接口设计：过大过杂 type BadInterface interface { Read() string Write(string) Close() Validate() Log(string) Notify() // ... 过多方法 } func main() { rect := Rectangle{Width: 10, Height: 5} // 使用小接口 var shape Shape = rect var drawable Drawable = rect var movable Movable = \u0026amp;rect fmt.Println(\u0026#34;=== 小接口使用 ===\u0026#34;) fmt.Printf(\u0026#34;面积：%.2f\\n\u0026#34;, shape.Area()) drawable.Draw() movable.Move(5, 3) // 接口隔离原则示例 fmt.Println(\u0026#34;\\n=== 接口隔离原则 ===\u0026#34;) // 只需要绘图功能 drawOnly := func(d Drawable) { d.Draw() } drawOnly(rect) // 只需要面积计算功能 calculateOnly := func(s Shape) { fmt.Printf(\u0026#34;面积计算结果：%.2f\\n\u0026#34;, s.Area()) } calculateOnly(rect) } 运行结果：\n=== 小接口使用 === 面积：50.00 绘制矩形：宽=10.0, 高=5.0 矩形移动到：(5.0, 3.0) === 接口隔离原则 === 绘制矩形：宽=10.0, 高=5.0 面积计算结果：50.00 7.2 接口在测试中的应用\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 定义接口用于测试 type TimeProvider interface { Now() time.Time } type RealTimeProvider struct{} func (RealTimeProvider) Now() time.Time { return time.Now() } // 测试用的模拟时间提供者 type MockTimeProvider struct { CurrentTime time.Time } func (m MockTimeProvider) Now() time.Time { return m.CurrentTime } // 使用时间的服务 type UserService struct { timeProvider TimeProvider } func NewUserService(tp TimeProvider) *UserService { return \u0026amp;UserService{timeProvider: tp} } func (us *UserService) CreateUser(name string) string { now := us.timeProvider.Now() return fmt.Sprintf(\u0026#34;用户%s创建于%s\u0026#34;, name, now.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) } func (us *UserService) CheckExpiry(expiry time.Time) bool { return us.timeProvider.Now().After(expiry) } func main() { fmt.Println(\u0026#34;=== 真实时间测试 ===\u0026#34;) // 使用真实时间 realService := NewUserService(RealTimeProvider{}) userMsg := realService.CreateUser(\u0026#34;张三\u0026#34;) fmt.Println(userMsg) // 检查过期时间 futureTime := time.Now().Add(24 * time.Hour) isExpired := realService.CheckExpiry(futureTime) fmt.Printf(\u0026#34;未来时间是否过期：%t\\n\u0026#34;, isExpired) fmt.Println(\u0026#34;\\n=== 模拟时间测试 ===\u0026#34;) // 使用模拟时间进行测试 mockTime := time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC) mockProvider := MockTimeProvider{CurrentTime: mockTime} mockService := NewUserService(mockProvider) userMsg2 := mockService.CreateUser(\u0026#34;李四\u0026#34;) fmt.Println(userMsg2) // 测试过期检查 pastTime := time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC) isExpired2 := mockService.CheckExpiry(pastTime) fmt.Printf(\u0026#34;过去时间是否过期：%t\\n\u0026#34;, isExpired2) futureTime2 := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC) isExpired3 := mockService.CheckExpiry(futureTime2) fmt.Printf(\u0026#34;未来时间是否过期：%t\\n\u0026#34;, isExpired3) } 运行结果：\n=== 真实时间测试 === 用户张三创建于2024-01-15 15:30:45 未来时间是否过期：false === 模拟时间测试 === 用户李四创建于2024-01-15 10:30:00 过去时间是否过期：true 未来时间是否过期：false 8. 总结\r接口是Go语言实现抽象和多态的核心机制：\n核心特点：\n隐式实现：无需显式声明实现关系 动态类型：运行时确定具体类型 空接口：可以存储任何类型 组合能力：接口可以嵌入其他接口 设计原则：\n接口应该小而专注，遵循接口隔离原则 优先使用组合而非继承 合理使用空接口和类型断言 为测试提供良好的接口设计 应用场景：\n定义行为规范（如io.Reader, io.Writer） 实现依赖注入和控制反转 支持多态和动态分派 便于单元测试和mock 接口是Go语言\u0026quot;面向接口编程\u0026quot;理念的体现，掌握好接口的使用对于编写高质量的Go程序至关重要。\n","date":"2026-02-04T19:15:16+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-11/","title":"Golang学习历程【第十一篇 接口(interface)】"},{"content":"1. 什么是方法\r方法是Go语言中与特定类型关联的函数。如果说函数是独立的功能单元，那么方法就是\u0026quot;属于\u0026quot;某个类型的特殊函数。方法让数据类型具备了行为能力，这是面向对象编程的重要特征。\n1.1 方法与函数的区别\r让我们通过一个简单的例子来理解：\n// 普通函数 func add(a, b int) int { return a + b } // 方法（后面会详细讲解语法） // func (接收者) 方法名(参数) 返回值 { 函数体 } 主要区别：\n函数：独立存在，通过函数名调用 方法：与特定类型绑定，通过\u0026quot;类型.方法名\u0026quot;调用 1.2 为什么需要方法\r方法的主要价值：\n封装性：将数据和操作数据的方法组织在一起 可读性：student.GetName() 比 getName(student) 更直观 面向对象：为后续的接口实现打基础 代码组织：更好地组织相关功能 2. 方法的基本语法\r2.1 方法定义语法\rfunc (接收者) 方法名(参数列表) (返回值列表) { // 方法体 } 2.2 接收者的两种形式\r值接收者\rfunc (t MyType) MethodName(parameters) returnType { // t是MyType类型的副本 // 修改t不会影响原始数据 } 指针接收者\rfunc (t *MyType) MethodName(parameters) returnType { // t是指向MyType类型的指针 // 修改t会影响原始数据 } 2.3 简单示例\rpackage main import \u0026#34;fmt\u0026#34; // 定义一个矩形结构体 type Rectangle struct { Width float64 Height float64 } // 值接收者方法：计算面积 func (r Rectangle) Area() float64 { return r.Width * r.Height } // 值接收者方法：计算周长 func (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) } // 指针接收者方法：缩放矩形 func (r *Rectangle) Scale(factor float64) { r.Width *= factor r.Height *= factor } // 指针接收者方法：设置尺寸 func (r *Rectangle) SetDimensions(width, height float64) { r.Width = width r.Height = height } func main() { // 创建矩形实例 rect := Rectangle{Width: 10, Height: 5} fmt.Printf(\u0026#34;原始矩形：宽度=%.2f, 高度=%.2f\\n\u0026#34;, rect.Width, rect.Height) fmt.Printf(\u0026#34;面积：%.2f\\n\u0026#34;, rect.Area()) fmt.Printf(\u0026#34;周长：%.2f\\n\u0026#34;, rect.Perimeter()) // 使用指针方法修改数据 rect.Scale(2.0) fmt.Printf(\u0026#34;\\n缩放后矩形：宽度=%.2f, 高度=%.2f\\n\u0026#34;, rect.Width, rect.Height) fmt.Printf(\u0026#34;新面积：%.2f\\n\u0026#34;, rect.Area()) rect.SetDimensions(15, 8) fmt.Printf(\u0026#34;\\n重新设置后：宽度=%.2f, 高度=%.2f\\n\u0026#34;, rect.Width, rect.Height) fmt.Printf(\u0026#34;最终面积：%.2f\\n\u0026#34;, rect.Area()) } 运行结果：\n原始矩形：宽度=10.00, 高度=5.00 面积：50.00 周长：30.00 缩放后矩形：宽度=20.00, 高度=10.00 新面积：200.00 重新设置后：宽度=15.00, 高度=8.00 最终面积：120.00 3. 接收者的深入理解\r3.1 值接收者 vs 指针接收者\rpackage main import \u0026#34;fmt\u0026#34; type Counter struct { Count int } // 值接收者方法 func (c Counter) GetValue() int { return c.Count } // 值接收者方法（不会修改原始值） func (c Counter) IncrementByValue() { c.Count++ // 这里修改的是副本 fmt.Printf(\u0026#34;值接收者内部Count: %d\\n\u0026#34;, c.Count) } // 指针接收者方法 func (c *Counter) GetPointerValue() int { return c.Count } // 指针接收者方法（会修改原始值） func (c *Counter) IncrementByPointer() { c.Count++ // 这里修改的是原始值 fmt.Printf(\u0026#34;指针接收者内部Count: %d\\n\u0026#34;, c.Count) } func main() { counter := Counter{Count: 10} fmt.Printf(\u0026#34;初始值：%d\\n\u0026#34;, counter.Count) // 值接收者调用 counter.IncrementByValue() fmt.Printf(\u0026#34;值接收者调用后：%d\\n\u0026#34;, counter.Count) // 指针接收者调用 counter.IncrementByPointer() fmt.Printf(\u0026#34;指针接收者调用后：%d\\n\u0026#34;, counter.Count) // 验证返回值 fmt.Printf(\u0026#34;GetValue(): %d\\n\u0026#34;, counter.GetValue()) fmt.Printf(\u0026#34;GetPointerValue(): %d\\n\u0026#34;, counter.GetPointerValue()) } 运行结果：\n初始值：10 值接收者内部Count: 11 值接收者调用后：10 指针接收者内部Count: 11 指针接收者调用后：11 GetValue(): 11 GetPointerValue(): 11 3.2 接收者的选择原则\r什么时候使用值接收者： ✅ 数据类型很小（如基本类型、小结构体） ✅ 方法不需要修改接收者数据 ✅ 方法需要并发安全（值传递是安全的）\n什么时候使用指针接收者： ✅ 方法需要修改接收者数据 ✅ 数据类型较大（避免拷贝开销） ✅ 一致性考虑（类型的所有方法都用指针接收者）\npackage main import \u0026#34;fmt\u0026#34; type SmallData struct { Value int } type LargeData struct { Values [1000]int // 大数组 Name string Active bool } // SmallData使用值接收者（合理） func (s SmallData) Double() SmallData { s.Value *= 2 return s } // LargeData使用指针接收者（合理） func (l *LargeData) Activate() { l.Active = true } func main() { // 小数据类型 small := SmallData{Value: 5} doubled := small.Double() fmt.Printf(\u0026#34;SmallData - 原始: %d, 翻倍后: %d\\n\u0026#34;, small.Value, doubled.Value) // 大数据类型 large := LargeData{Name: \u0026#34;Test\u0026#34;} fmt.Printf(\u0026#34;LargeData - 修改前Active: %t\\n\u0026#34;, large.Active) large.Activate() fmt.Printf(\u0026#34;LargeData - 修改后Active: %t\\n\u0026#34;, large.Active) } 运行结果：\nSmallData - 原始: 5, 翻倍后: 10 LargeData - 修改前Active: false LargeData - 修改后Active: true 4. 不同类型的接收者\r4.1 基本类型的方法\rpackage main import \u0026#34;fmt\u0026#34; // 为int类型创建别名 type MyInt int // 为自定义类型添加方法 func (mi MyInt) Double() MyInt { return mi * 2 } func (mi MyInt) IsEven() bool { return mi%2 == 0 } func (mi *MyInt) Increment() { *mi++ } // 为内置类型创建方法（需要类型别名） type Celsius float64 type Fahrenheit float64 func (c Celsius) ToFahrenheit() Fahrenheit { return Fahrenheit(c*9/5 + 32) } func (f Fahrenheit) ToCelsius() Celsius { return Celsius((f - 32) * 5 / 9) } func main() { // 自定义int类型 num := MyInt(10) fmt.Printf(\u0026#34;原始值：%d\\n\u0026#34;, num) fmt.Printf(\u0026#34;翻倍：%d\\n\u0026#34;, num.Double()) fmt.Printf(\u0026#34;是否偶数：%t\\n\u0026#34;, num.IsEven()) num.Increment() fmt.Printf(\u0026#34;递增后：%d\\n\u0026#34;, num) // 温度转换 tempC := Celsius(25) tempF := tempC.ToFahrenheit() fmt.Printf(\u0026#34;\\n%d°C = %.1f°F\\n\u0026#34;, int(tempC), float64(tempF)) backToC := tempF.ToCelsius() fmt.Printf(\u0026#34;%.1f°F = %d°C\\n\u0026#34;, float64(tempF), int(backToC)) } 运行结果：\n原始值：10 翻倍：20 是否偶数：true 递增后：11 25°C = 77.0°F 77.0°F = 25°C 4.2 结构体方法\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Point struct { X, Y float64 } type Circle struct { Center Point Radius float64 } // Point的方法 func (p Point) Distance(other Point) float64 { dx := p.X - other.X dy := p.Y - other.Y return math.Sqrt(dx*dx + dy*dy) } func (p Point) Move(dx, dy float64) Point { return Point{X: p.X + dx, Y: p.Y + dy} } // Circle的方法 func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius } func (c Circle) Circumference() float64 { return 2 * math.Pi * c.Radius } func (c *Circle) Scale(factor float64) { c.Radius *= factor } func main() { // 点的操作 p1 := Point{X: 0, Y: 0} p2 := Point{X: 3, Y: 4} distance := p1.Distance(p2) fmt.Printf(\u0026#34;两点距离：%.2f\\n\u0026#34;, distance) p3 := p1.Move(1, 1) fmt.Printf(\u0026#34;移动后点：(%f, %f)\\n\u0026#34;, p3.X, p3.Y) // 圆的操作 circle := Circle{ Center: Point{X: 0, Y: 0}, Radius: 5, } fmt.Printf(\u0026#34;\\n圆的半径：%.2f\\n\u0026#34;, circle.Radius) fmt.Printf(\u0026#34;圆的面积：%.2f\\n\u0026#34;, circle.Area()) fmt.Printf(\u0026#34;圆的周长：%.2f\\n\u0026#34;, circle.Circumference()) circle.Scale(2) fmt.Printf(\u0026#34;\\n缩放后半径：%.2f\\n\u0026#34;, circle.Radius) fmt.Printf(\u0026#34;缩放后面积：%.2f\\n\u0026#34;, circle.Area()) } 运行结果：\n两点距离：5.00 移动后点：(1.000000, 1.000000) 圆的半径：5.00 圆的面积：78.54 圆的周长：31.42 缩放后半径：10.00 缩放后面积：314.16 4.3 切片和映射的方法\rpackage main import \u0026#34;fmt\u0026#34; // 为切片类型创建别名 type IntSlice []int // 为映射类型创建别名 type StringMap map[string]string // IntSlice的方法 func (is IntSlice) Sum() int { sum := 0 for _, v := range is { sum += v } return sum } func (is IntSlice) Average() float64 { if len(is) == 0 { return 0 } return float64(is.Sum()) / float64(len(is)) } func (is *IntSlice) Append(value int) { *is = append(*is, value) } // StringMap的方法 func (sm StringMap) Get(key string) (string, bool) { value, exists := sm[key] return value, exists } func (sm StringMap) Set(key, value string) { sm[key] = value } func (sm StringMap) Keys() []string { keys := make([]string, 0, len(sm)) for k := range sm { keys = append(keys, k) } return keys } func main() { // 切片方法 numbers := IntSlice{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;数字切片：%v\\n\u0026#34;, numbers) fmt.Printf(\u0026#34;总和：%d\\n\u0026#34;, numbers.Sum()) fmt.Printf(\u0026#34;平均值：%.2f\\n\u0026#34;, numbers.Average()) numbers.Append(6) numbers.Append(7) fmt.Printf(\u0026#34;添加元素后：%v\\n\u0026#34;, numbers) fmt.Printf(\u0026#34;新总和：%d\\n\u0026#34;, numbers.Sum()) // 映射方法 studentGrades := StringMap{ \u0026#34;张三\u0026#34;: \u0026#34;85\u0026#34;, \u0026#34;李四\u0026#34;: \u0026#34;92\u0026#34;, \u0026#34;王五\u0026#34;: \u0026#34;78\u0026#34;, } fmt.Printf(\u0026#34;\\n学生 grades：%v\\n\u0026#34;, studentGrades) // 获取值 if grade, exists := studentGrades.Get(\u0026#34;李四\u0026#34;); exists { fmt.Printf(\u0026#34;李四的成绩：%s\\n\u0026#34;, grade) } // 设置新值 studentGrades.Set(\u0026#34;赵六\u0026#34;, \u0026#34;88\u0026#34;) fmt.Printf(\u0026#34;添加赵六后：%v\\n\u0026#34;, studentGrades) // 获取所有键 keys := studentGrades.Keys() fmt.Printf(\u0026#34;所有学生：%v\\n\u0026#34;, keys) } 运行结果：\n数字切片：[1 2 3 4 5] 总和：15 平均值：3.00 添加元素后：[1 2 3 4 5 6 7] 新总和：28 学生 grades：map[张三:85 李四:92 王五:78] 李四的成绩：92 添加赵六后：map[张三:85 李四:92 王五:78 赵六:88] 所有学生：[张三 李四 王五 赵六] 5. 方法与接口的关系\r5.1 方法集的概念\rpackage main import \u0026#34;fmt\u0026#34; type Shape interface { Area() float64 Perimeter() float64 } type Rectangle struct { Width float64 Height float64 } type Circle struct { Radius float64 } // Rectangle实现Shape接口 func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) } // Circle实现Shape接口 func (c Circle) Area() float64 { return 3.14159 * c.Radius * c.Radius } func (c Circle) Perimeter() float64 { return 2 * 3.14159 * c.Radius } // 使用接口的函数 func PrintShapeInfo(s Shape) { fmt.Printf(\u0026#34;面积：%.2f\\n\u0026#34;, s.Area()) fmt.Printf(\u0026#34;周长：%.2f\\n\u0026#34;, s.Perimeter()) } func main() { rect := Rectangle{Width: 10, Height: 5} circle := Circle{Radius: 3} fmt.Println(\u0026#34;=== 矩形 ===\u0026#34;) PrintShapeInfo(rect) fmt.Println(\u0026#34;\\n=== 圆形 ===\u0026#34;) PrintShapeInfo(circle) // 接口切片 shapes := []Shape{rect, circle} fmt.Println(\u0026#34;\\n=== 批量处理 ===\u0026#34;) for i, shape := range shapes { fmt.Printf(\u0026#34;形状%d:\\n\u0026#34;, i+1) PrintShapeInfo(shape) fmt.Println() } } 运行结果：\n=== 矩形 === 面积：50.00 周长：30.00 === 圆形 === 面积：28.27 周长：18.85 === 批量处理 === 形状1: 面积：50.00 周长：30.00 形状2: 面积：28.27 周长：18.85 6. 方法的高级用法\r6.1 方法链式调用\rpackage main import \u0026#34;fmt\u0026#34; type Calculator struct { Result float64 } func (c Calculator) Add(x float64) Calculator { c.Result += x return c } func (c Calculator) Subtract(x float64) Calculator { c.Result -= x return c } func (c Calculator) Multiply(x float64) Calculator { c.Result *= x return c } func (c Calculator) Divide(x float64) Calculator { if x != 0 { c.Result /= x } return c } func (c Calculator) GetValue() float64 { return c.Result } func main() { calc := Calculator{Result: 10} result := calc. Add(5). Multiply(2). Subtract(3). Divide(2). GetValue() fmt.Printf(\u0026#34;计算结果：%.2f\\n\u0026#34;, result) // 分步演示 calc2 := Calculator{Result: 10} fmt.Printf(\u0026#34;初始值：%.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Add(5) fmt.Printf(\u0026#34;加5后：%.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Multiply(2) fmt.Printf(\u0026#34;乘2后：%.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Subtract(3) fmt.Printf(\u0026#34;减3后：%.2f\\n\u0026#34;, calc2.GetValue()) calc2 = calc2.Divide(2) fmt.Printf(\u0026#34;除2后：%.2f\\n\u0026#34;, calc2.GetValue()) } 运行结果：\n计算结果：13.50 初始值：10.00 加5后：15.00 乘2后：30.00 减3后：27.00 除2后：13.50 6.2 嵌入类型的方法提升\rpackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func (p Person) GetName() string { return p.Name } func (p Person) GetAge() int { return p.Age } type Student struct { Person // 嵌入Person School string Grade int } func (s Student) GetSchool() string { return s.School } type Teacher struct { Person // 嵌入Person Subject string Salary float64 } func (t Teacher) GetSubject() string { return t.Subject } func main() { student := Student{ Person: Person{Name: \u0026#34;小明\u0026#34;, Age: 18}, School: \u0026#34;第一中学\u0026#34;, Grade: 12, } teacher := Teacher{ Person: Person{Name: \u0026#34;王老师\u0026#34;, Age: 35}, Subject: \u0026#34;数学\u0026#34;, Salary: 8000, } // 可以直接调用嵌入类型的方法 fmt.Printf(\u0026#34;学生姓名：%s\\n\u0026#34;, student.GetName()) // 提升方法 fmt.Printf(\u0026#34;学生年龄：%d\\n\u0026#34;, student.GetAge()) // 提升方法 fmt.Printf(\u0026#34;学校：%s\\n\u0026#34;, student.GetSchool()) fmt.Printf(\u0026#34;年级：%d\\n\u0026#34;, student.Grade) fmt.Printf(\u0026#34;\\n老师姓名：%s\\n\u0026#34;, teacher.GetName()) // 提升方法 fmt.Printf(\u0026#34;老师年龄：%d\\n\u0026#34;, teacher.GetAge()) // 提升方法 fmt.Printf(\u0026#34;科目：%s\\n\u0026#34;, teacher.GetSubject()) fmt.Printf(\u0026#34;薪资：%.2f\\n\u0026#34;, teacher.Salary) // 验证类型关系 fmt.Printf(\u0026#34;\\n学生也是Person类型：%t\\n\u0026#34;, isPerson(student)) fmt.Printf(\u0026#34;老师也是Person类型：%t\\n\u0026#34;, isPerson(teacher)) } func isPerson(p Person) bool { return true } 运行结果：\n学生姓名：小明 学生年龄：18 学校：第一中学 年级：12 老师姓名：王老师 老师年龄：35 科目：数学 薪资：8000.00 学生也是Person类型：true 老师也是Person类型：true 7. 方法的注意事项\r7.1 方法名冲突\rpackage main import \u0026#34;fmt\u0026#34; type Base struct { Name string } func (b Base) GetName() string { return b.Name } type Derived struct { Base Name string // 与Base中的Name同名 } func (d Derived) GetName() string { // 明确指定调用哪个GetName return \u0026#34;Derived: \u0026#34; + d.Name + \u0026#34;, Base: \u0026#34; + d.Base.GetName() } func main() { derived := Derived{ Base: Base{Name: \u0026#34;BaseName\u0026#34;}, Name: \u0026#34;DerivedName\u0026#34;, } fmt.Printf(\u0026#34;调用派生类GetName: %s\\n\u0026#34;, derived.GetName()) fmt.Printf(\u0026#34;直接访问Name: %s\\n\u0026#34;, derived.Name) fmt.Printf(\u0026#34;访问Base.Name: %s\\n\u0026#34;, derived.Base.Name) } 运行结果：\n调用派生类GetName: Derived: DerivedName, Base: BaseName 直接访问Name: DerivedName 访问Base.Name: BaseName 7.2 空指针调用方法\rpackage main import \u0026#34;fmt\u0026#34; type Data struct { Value int } func (d *Data) GetValue() int { if d == nil { return 0 // 安全检查 } return d.Value } func (d *Data) SetValue(v int) { if d != nil { // 安全检查 d.Value = v } } func main() { var ptr *Data = nil // 空指针调用方法（安全） fmt.Printf(\u0026#34;空指针GetValue: %d\\n\u0026#34;, ptr.GetValue()) // 空指针调用修改方法（安全） ptr.SetValue(100) // 不会有问题，因为有安全检查 // 创建实际对象 actual := \u0026amp;Data{Value: 42} fmt.Printf(\u0026#34;实际对象GetValue: %d\\n\u0026#34;, actual.GetValue()) actual.SetValue(99) fmt.Printf(\u0026#34;修改后GetValue: %d\\n\u0026#34;, actual.GetValue()) } 运行结果：\n空指针GetValue: 0 实际对象GetValue: 42 修改后GetValue: 99 8. 总结\r方法是Go语言实现面向对象编程的核心机制：\n核心概念：\n方法是与特定类型绑定的函数 通过接收者将方法与类型关联 值接收者和指针接收者有不同的行为特点 使用原则：\n值接收者：适用于不修改数据、小型数据类型 指针接收者：适用于需要修改数据、大型数据类型 保持类型所有方法接收者类型的一致性 重要特性：\n方法提升：嵌入类型的方法可以被直接调用 接口实现：方法是实现接口的基础 链式调用：返回接收者类型支持方法链 掌握方法的使用是理解Go语言面向对象特性的关键，也为后续学习接口打下了坚实基础。\n","date":"2026-02-04T18:15:16+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-10/","title":"Golang学习历程【第十篇 方法(method)与接收者】"},{"content":"1. 什么是结构体\r结构体是Go语言中一种重要的复合数据类型，它可以将多个不同类型的数据组合在一起，形成一个有意义的整体。可以把结构体理解为现实世界中事物的抽象表示。\n1.1 结构体的基本概念\r想象我们要描述一个学生的信息：\n姓名：字符串类型 年龄：整数类型 成绩：浮点数类型 是否在校：布尔类型 如果没有结构体，我们需要分别定义多个变量：\nvar name string = \u0026#34;张三\u0026#34; var age int = 18 var score float64 = 95.5 var isEnrolled bool = true 这样很不方便管理和使用。而结构体可以将这些相关数据组织在一起：\ntype Student struct { Name string Age int Score float64 IsEnrolled bool } 1.2 为什么需要结构体\r结构体的主要优势：\n数据聚合：将相关的数据组织在一起 代码清晰：提高代码的可读性和可维护性 类型安全：创建专门的数据类型 面向对象：为后续的方法和接口打基础 2. 结构体的定义和声明\r2.1 基本定义语法\r// 结构体定义的基本语法 type 结构体名 struct { 字段名1 数据类型1 字段名2 数据类型2 字段名3 数据类型3 // ... 更多字段 } 2.2 结构体定义示例\rpackage main import \u0026#34;fmt\u0026#34; // 定义学生结构体 type Student struct { Name string // 姓名 Age int // 年龄 Score float64 // 成绩 IsEnrolled bool // 是否在校 } // 定义图书结构体 type Book struct { Title string // 书名 Author string // 作者 Price float64 // 价格 Pages int // 页数 ISBN string // ISBN编号 } // 定义坐标点结构体 type Point struct { X int // X坐标 Y int // Y坐标 } func main() { fmt.Println(\u0026#34;结构体定义完成\u0026#34;) } 2.3 匿名结构体\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 匿名结构体定义和使用 person := struct { Name string Age int }{ Name: \u0026#34;李四\u0026#34;, Age: 25, } fmt.Printf(\u0026#34;匿名结构体：%+v\\n\u0026#34;, person) fmt.Printf(\u0026#34;姓名：%s，年龄：%d\\n\u0026#34;, person.Name, person.Age) // 匿名结构体切片 people := []struct { Name string City string }{ {\u0026#34;王五\u0026#34;, \u0026#34;北京\u0026#34;}, {\u0026#34;赵六\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;孙七\u0026#34;, \u0026#34;广州\u0026#34;}, } fmt.Println(\u0026#34;人员列表：\u0026#34;) for _, p := range people { fmt.Printf(\u0026#34;姓名：%s，城市：%s\\n\u0026#34;, p.Name, p.City) } } 运行结果：\n匿名结构体：{Name:李四 Age:25} 姓名：李四，年龄：25 人员列表： 姓名：王五，城市：北京 姓名：赵六，城市：上海 姓名：孙七，城市：广州 3. 结构体的实例化\r3.1 各种创建方式\rpackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int Score float64 } func main() { // 方式1：完整字段初始化 student1 := Student{ Name: \u0026#34;张三\u0026#34;, Age: 18, Score: 95.5, } // 方式2：按字段顺序初始化（必须指定所有字段） student2 := Student{\u0026#34;李四\u0026#34;, 19, 88.0} // 方式3：部分字段初始化（必须指定字段名） student3 := Student{ Name: \u0026#34;王五\u0026#34;, Age: 20, // Score使用默认值0.0 } // 方式4：使用new函数创建（所有字段为零值） student4 := new(Student) student4.Name = \u0026#34;赵六\u0026#34; student4.Age = 21 student4.Score = 92.5 // 方式5：使用\u0026amp;创建并初始化 student5 := \u0026amp;Student{ Name: \u0026#34;孙七\u0026#34;, Age: 17, Score: 87.5, } fmt.Printf(\u0026#34;学生1：%+v\\n\u0026#34;, student1) fmt.Printf(\u0026#34;学生2：%+v\\n\u0026#34;, student2) fmt.Printf(\u0026#34;学生3：%+v\\n\u0026#34;, student3) fmt.Printf(\u0026#34;学生4：%+v\\n\u0026#34;, *student4) fmt.Printf(\u0026#34;学生5：%+v\\n\u0026#34;, *student5) } 运行结果：\n学生1：{Name:张三 Age:18 Score:95.5} 学生2：{Name:李四 Age:19 Score:88} 学生3：{Name:王五 Age:20 Score:0} 学生4：{Name:赵六 Age:21 Score:92.5} 学生5：{Name:孙七 Age:17 Score:87.5} 3.2 结构体的零值\rpackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int Height float64 IsActive bool Scores []int Info map[string]string } func main() { // 声明结构体变量但不初始化 var person Person fmt.Printf(\u0026#34;结构体零值：%+v\\n\u0026#34;, person) fmt.Printf(\u0026#34;字符串零值：%q\\n\u0026#34;, person.Name) fmt.Printf(\u0026#34;整数零值：%d\\n\u0026#34;, person.Age) fmt.Printf(\u0026#34;浮点数零值：%f\\n\u0026#34;, person.Height) fmt.Printf(\u0026#34;布尔零值：%t\\n\u0026#34;, person.IsActive) fmt.Printf(\u0026#34;切片零值：%v，是否为nil：%t\\n\u0026#34;, person.Scores, person.Scores == nil) fmt.Printf(\u0026#34;map零值：%v，是否为nil：%t\\n\u0026#34;, person.Info, person.Info == nil) } 运行结果：\n结构体零值：{Name: Age:0 Height:0 IsActive:false Scores:[] Info:map[]} 字符串零值：\u0026#34;\u0026#34; 整数零值：0 浮点数零值：0.000000 布尔零值：false 切片零值：[]，是否为nil：true map零值：map[]，是否为nil：true 4. 结构体字段访问和修改\r4.1 字段访问\rpackage main import \u0026#34;fmt\u0026#34; type Employee struct { Name string Age int Salary float64 Department string } func main() { // 创建员工实例 emp := Employee{ Name: \u0026#34;张三\u0026#34;, Age: 28, Salary: 15000.0, Department: \u0026#34;技术部\u0026#34;, } // 访问字段 fmt.Printf(\u0026#34;员工姓名：%s\\n\u0026#34;, emp.Name) fmt.Printf(\u0026#34;员工年龄：%d\\n\u0026#34;, emp.Age) fmt.Printf(\u0026#34;员工薪资：%.2f\\n\u0026#34;, emp.Salary) fmt.Printf(\u0026#34;所在部门：%s\\n\u0026#34;, emp.Department) // 修改字段值 emp.Age = 29 emp.Salary = 16000.0 emp.Department = \u0026#34;研发部\u0026#34; fmt.Printf(\u0026#34;\\n修改后信息：\\n\u0026#34;) fmt.Printf(\u0026#34;员工姓名：%s\\n\u0026#34;, emp.Name) fmt.Printf(\u0026#34;员工年龄：%d\\n\u0026#34;, emp.Age) fmt.Printf(\u0026#34;员工薪资：%.2f\\n\u0026#34;, emp.Salary) fmt.Printf(\u0026#34;所在部门：%s\\n\u0026#34;, emp.Department) } 运行结果：\n员工姓名：张三 员工年龄：28 员工薪资：15000.00 所在部门：技术部 修改后信息： 员工姓名：张三 员工年龄：29 员工薪资：16000.00 所在部门：研发部 4.2 指针访问结构体字段\rpackage main import \u0026#34;fmt\u0026#34; type Product struct { Name string Price float64 Stock int } func main() { // 普通结构体变量 product1 := Product{Name: \u0026#34;手机\u0026#34;, Price: 3999.0, Stock: 100} // 结构体指针 product2 := \u0026amp;Product{Name: \u0026#34;电脑\u0026#34;, Price: 8999.0, Stock: 50} // 访问方式1：通过变量名直接访问 fmt.Printf(\u0026#34;产品1 - 名称：%s，价格：%.2f，库存：%d\\n\u0026#34;, product1.Name, product1.Price, product1.Stock) // 访问方式2：通过指针访问（Go自动解引用） fmt.Printf(\u0026#34;产品2 - 名称：%s，价格：%.2f，库存：%d\\n\u0026#34;, product2.Name, product2.Price, product2.Stock) // 访问方式3：显式解引用 fmt.Printf(\u0026#34;产品2显式解引用 - 名称：%s，价格：%.2f，库存：%d\\n\u0026#34;, (*product2).Name, (*product2).Price, (*product2).Stock) // 修改值 product1.Price = 3599.0 product2.Stock = 75 // 等价于 (*product2).Stock = 75 fmt.Printf(\u0026#34;\\n修改后：\\n\u0026#34;) fmt.Printf(\u0026#34;产品1价格：%.2f\\n\u0026#34;, product1.Price) fmt.Printf(\u0026#34;产品2库存：%d\\n\u0026#34;, product2.Stock) } 运行结果：\n产品1 - 名称：手机，价格：3999.00，库存：100 产品2 - 名称：电脑，价格：8999.00，库存：50 产品2显式解引用 - 名称：电脑，价格：8999.00，库存：50 修改后： 产品1价格：3599.00 产品2库存：75 5. 结构体嵌套\r5.1 基本嵌套\rpackage main import \u0026#34;fmt\u0026#34; // 地址结构体 type Address struct { Province string City string Street string ZipCode string } // 公司结构体 type Company struct { Name string Address Address // 嵌套Address结构体 } // 员工结构体 type Employee struct { Name string Age int Company Company // 嵌套Company结构体 } func main() { // 创建嵌套结构体 employee := Employee{ Name: \u0026#34;张三\u0026#34;, Age: 30, Company: Company{ Name: \u0026#34;科技有限公司\u0026#34;, Address: Address{ Province: \u0026#34;北京市\u0026#34;, City: \u0026#34;北京市\u0026#34;, Street: \u0026#34;中关村大街1号\u0026#34;, ZipCode: \u0026#34;100080\u0026#34;, }, }, } // 访问嵌套字段 fmt.Printf(\u0026#34;员工姓名：%s\\n\u0026#34;, employee.Name) fmt.Printf(\u0026#34;员工年龄：%d\\n\u0026#34;, employee.Age) fmt.Printf(\u0026#34;公司名称：%s\\n\u0026#34;, employee.Company.Name) fmt.Printf(\u0026#34;公司省份：%s\\n\u0026#34;, employee.Company.Address.Province) fmt.Printf(\u0026#34;公司城市：%s\\n\u0026#34;, employee.Company.Address.City) fmt.Printf(\u0026#34;公司街道：%s\\n\u0026#34;, employee.Company.Address.Street) fmt.Printf(\u0026#34;邮政编码：%s\\n\u0026#34;, employee.Company.Address.ZipCode) // 修改嵌套字段 employee.Company.Address.Street = \u0026#34;中关村大街2号\u0026#34; fmt.Printf(\u0026#34;\\n修改后街道：%s\\n\u0026#34;, employee.Company.Address.Street) } 运行结果：\n员工姓名：张三 员工年龄：30 公司名称：科技有限公司 公司省份：北京市 公司城市：北京市 公司街道：中关村大街1号 邮政编码：100080 修改后街道：中关村大街2号 5.2 匿名嵌套（匿名字段）\rpackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } type Student struct { Person // 匿名嵌套Person结构体 School string Grade int } type Teacher struct { Person // 匿名嵌套Person结构体 Subject string Salary float64 } func main() { // 创建学生 student := Student{ Person: Person{Name: \u0026#34;小明\u0026#34;, Age: 18}, School: \u0026#34;第一中学\u0026#34;, Grade: 12, } // 创建老师 teacher := Teacher{ Person: Person{Name: \u0026#34;王老师\u0026#34;, Age: 35}, Subject: \u0026#34;数学\u0026#34;, Salary: 8000.0, } // 访问提升字段（可以直接访问嵌套结构体的字段） fmt.Printf(\u0026#34;学生姓名：%s\\n\u0026#34;, student.Name) // 等价于 student.Person.Name fmt.Printf(\u0026#34;学生年龄：%d\\n\u0026#34;, student.Age) // 等价于 student.Person.Age fmt.Printf(\u0026#34;学校：%s\\n\u0026#34;, student.School) fmt.Printf(\u0026#34;年级：%d\\n\u0026#34;, student.Grade) fmt.Printf(\u0026#34;\\n老师姓名：%s\\n\u0026#34;, teacher.Name) // 等价于 teacher.Person.Name fmt.Printf(\u0026#34;老师年龄：%d\\n\u0026#34;, teacher.Age) // 等价于 teacher.Person.Age fmt.Printf(\u0026#34;科目：%s\\n\u0026#34;, teacher.Subject) fmt.Printf(\u0026#34;薪资：%.2f\\n\u0026#34;, teacher.Salary) // 修改提升字段 student.Age = 19 teacher.Name = \u0026#34;李老师\u0026#34; fmt.Printf(\u0026#34;\\n修改后学生年龄：%d\\n\u0026#34;, student.Age) fmt.Printf(\u0026#34;修改后老师姓名：%s\\n\u0026#34;, teacher.Name) } 运行结果：\n学生姓名：小明 学生年龄：18 学校：第一中学 年级：12 老师姓名：王老师 老师年龄：35 科目：数学 薪资：8000.00 修改后学生年龄：19 修改后老师姓名：李老师 6. 结构体标签（Struct Tags）\r6.1 基本标签使用\rpackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { ID int `json:\u0026#34;id\u0026#34;` UserName string `json:\u0026#34;username\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` Password string `json:\u0026#34;-\u0026#34;` // -表示忽略此字段 Active bool `json:\u0026#34;active,omitempty\u0026#34;` // omitempty表示空值时忽略 } func main() { user := User{ ID: 1, UserName: \u0026#34;zhangsan\u0026#34;, Email: \u0026#34;zhangsan@example.com\u0026#34;, Password: \u0026#34;123456\u0026#34;, Active: true, } // 序列化为JSON jsonData, err := json.Marshal(user) if err != nil { fmt.Printf(\u0026#34;序列化错误：%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;JSON数据：%s\\n\u0026#34;, jsonData) // 反序列化 var newUser User jsonStr := `{\u0026#34;id\u0026#34;:2,\u0026#34;username\u0026#34;:\u0026#34;lisi\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;lisi@example.com\u0026#34;,\u0026#34;active\u0026#34;:false}` err = json.Unmarshal([]byte(jsonStr), \u0026amp;newUser) if err != nil { fmt.Printf(\u0026#34;反序列化错误：%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;反序列化结果：%+v\\n\u0026#34;, newUser) } 运行结果：\nJSON数据：{\u0026#34;id\u0026#34;:1,\u0026#34;username\u0026#34;:\u0026#34;zhangsan\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;zhangsan@example.com\u0026#34;,\u0026#34;active\u0026#34;:true} 反序列化结果：{ID:2 UserName:lisi Email:lisi@example.com Password: Active:false} 6.2 多个标签示例\rpackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Product struct { ID int `json:\u0026#34;id\u0026#34; db:\u0026#34;product_id\u0026#34;` Name string `json:\u0026#34;name\u0026#34; db:\u0026#34;product_name\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34; db:\u0026#34;price\u0026#34;` Description string `json:\u0026#34;description,omitempty\u0026#34; db:\u0026#34;description\u0026#34;` Category string `json:\u0026#34;category\u0026#34; db:\u0026#34;category\u0026#34;` } func main() { products := []Product{ { ID: 1, Name: \u0026#34;iPhone 15\u0026#34;, Price: 5999.0, Description: \u0026#34;最新款苹果手机\u0026#34;, Category: \u0026#34;电子产品\u0026#34;, }, { ID: 2, Name: \u0026#34;MacBook Pro\u0026#34;, Price: 12999.0, // Description为空，会被omitempty忽略 Category: \u0026#34;电脑\u0026#34;, }, } // JSON序列化 jsonData, _ := json.MarshalIndent(products, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;JSON格式数据：\\n%s\\n\u0026#34;, jsonData) } 运行结果：\nJSON格式数据： [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;iPhone 15\u0026#34;, \u0026#34;price\u0026#34;: 5999, \u0026#34;description\u0026#34;: \u0026#34;最新款苹果手机\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;电子产品\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;MacBook Pro\u0026#34;, \u0026#34;price\u0026#34;: 12999, \u0026#34;category\u0026#34;: \u0026#34;电脑\u0026#34; } ] 7. 结构体比较\r7.1 结构体相等性比较\rpackage main import \u0026#34;fmt\u0026#34; type Point struct { X, Y int } type Person struct { Name string Age int Data []int // 切片字段 } func main() { // 可比较的结构体 p1 := Point{1, 2} p2 := Point{1, 2} p3 := Point{3, 4} fmt.Printf(\u0026#34;p1 == p2: %t\\n\u0026#34;, p1 == p2) fmt.Printf(\u0026#34;p1 == p3: %t\\n\u0026#34;, p1 == p3) // 包含不可比较字段的结构体 person1 := Person{Name: \u0026#34;张三\u0026#34;, Age: 20, Data: []int{1, 2, 3}} person2 := Person{Name: \u0026#34;张三\u0026#34;, Age: 20, Data: []int{1, 2, 3}} // 以下代码会编译错误，因为包含切片字段 // fmt.Printf(\u0026#34;person1 == person2: %t\\n\u0026#34;, person1 == person2) // 手动比较 equal := person1.Name == person2.Name \u0026amp;\u0026amp; person1.Age == person2.Age \u0026amp;\u0026amp; len(person1.Data) == len(person2.Data) if equal { for i := range person1.Data { if person1.Data[i] != person2.Data[i] { equal = false break } } } fmt.Printf(\u0026#34;手动比较结果：%t\\n\u0026#34;, equal) } 运行结果：\np1 == p2: true p1 == p3: false 手动比较结果：true 8. 结构体工厂函数\r8.1 创建结构体的构造函数\rpackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type User struct { ID int Username string Email string CreatedAt time.Time IsActive bool } // 构造函数1：创建普通用户 func NewUser(username, email string) *User { return \u0026amp;User{ Username: username, Email: email, CreatedAt: time.Now(), IsActive: true, } } // 构造函数2：创建管理员用户 func NewAdminUser(username, email string) *User { user := NewUser(username, email) user.ID = -1 // 管理员ID设为特殊值 return user } // 构造函数3：带验证的构造函数 func NewUserWithValidation(username, email string) (*User, error) { if len(username) \u0026lt; 3 { return nil, fmt.Errorf(\u0026#34;用户名长度不能少于3个字符\u0026#34;) } if len(email) \u0026lt; 5 || !contains(email, \u0026#34;@\u0026#34;) { return nil, fmt.Errorf(\u0026#34;邮箱格式不正确\u0026#34;) } return \u0026amp;User{ Username: username, Email: email, CreatedAt: time.Now(), IsActive: true, }, nil } // 辅助函数 func contains(s, substr string) bool { for i := 0; i \u0026lt;= len(s)-len(substr); i++ { if s[i:i+len(substr)] == substr { return true } } return false } func main() { // 使用构造函数创建用户 user1 := NewUser(\u0026#34;zhangsan\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;) fmt.Printf(\u0026#34;普通用户：%+v\\n\u0026#34;, *user1) admin := NewAdminUser(\u0026#34;admin\u0026#34;, \u0026#34;admin@example.com\u0026#34;) fmt.Printf(\u0026#34;管理员用户：%+v\\n\u0026#34;, *admin) // 带验证的构造函数 user2, err := NewUserWithValidation(\u0026#34;li\u0026#34;, \u0026#34;invalid-email\u0026#34;) if err != nil { fmt.Printf(\u0026#34;创建用户失败：%v\\n\u0026#34;, err) } user3, err := NewUserWithValidation(\u0026#34;lisi\u0026#34;, \u0026#34;lisi@example.com\u0026#34;) if err != nil { fmt.Printf(\u0026#34;创建用户失败：%v\\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;验证通过的用户：%+v\\n\u0026#34;, *user3) } } 运行结果：\n普通用户：{ID:0 Username:zhangsan Email:zhangsan@example.com CreatedAt:2024-01-15 10:30:45.123456789 +0800 CST IsActive:true} 管理员用户：{ID:-1 Username:admin Email:admin@example.com CreatedAt:2024-01-15 10:30:45.123456789 +0800 CST IsActive:true} 创建用户失败：用户名长度不能少于3个字符 验证通过的用户：{ID:0 Username:lisi Email:lisi@example.com CreatedAt:2024-01-15 10:30:45.123456789 +0800 CST IsActive:true} 9. 结构体与函数\r9.1 结构体作为函数参数\rpackage main import \u0026#34;fmt\u0026#34; type Rectangle struct { Width float64 Height float64 } // 值传递 func calculateArea(rect Rectangle) float64 { return rect.Width * rect.Height } // 指针传递（可以修改原结构体） func scaleRectangle(rect *Rectangle, factor float64) { rect.Width *= factor rect.Height *= factor } // 返回结构体 func createSquare(side float64) Rectangle { return Rectangle{Width: side, Height: side} } func main() { // 创建矩形 rect := Rectangle{Width: 10, Height: 5} fmt.Printf(\u0026#34;原始矩形：%+v\\n\u0026#34;, rect) // 值传递计算面积 area := calculateArea(rect) fmt.Printf(\u0026#34;面积：%.2f\\n\u0026#34;, area) fmt.Printf(\u0026#34;计算后矩形：%+v\\n\u0026#34;, rect) // 原矩形未改变 // 指针传递缩放 scaleRectangle(\u0026amp;rect, 2.0) fmt.Printf(\u0026#34;缩放后矩形：%+v\\n\u0026#34;, rect) fmt.Printf(\u0026#34;缩放后面积：%.2f\\n\u0026#34;, calculateArea(rect)) // 创建正方形 square := createSquare(8) fmt.Printf(\u0026#34;创建的正方形：%+v\\n\u0026#34;, square) fmt.Printf(\u0026#34;正方形面积：%.2f\\n\u0026#34;, calculateArea(square)) } 运行结果：\n原始矩形：{Width:10 Height:5} 面积：50.00 计算后矩形：{Width:10 Height:5} 缩放后矩形：{Width:20 Height:10} 缩放后面积：200.00 创建的正方形：{Width:8 Height:8} 正方形面积：64.00 10. 总结\r结构体是Go语言中组织和管理相关数据的重要工具：\n核心特点：\n将多个相关的数据字段组合在一起 可以嵌套其他结构体 支持标签用于序列化等操作 可以定义构造函数来规范化创建过程 使用场景：\n表示现实世界的实体（用户、商品、订单等） 组织配置信息 作为函数参数传递复杂数据 实现面向对象编程的基础 最佳实践：\n使用构造函数来创建结构体实例 为重要的结构体添加标签 合理使用指针传递避免不必要的拷贝 注意包含不可比较字段的结构体比较问题 结构体是Go语言面向对象编程的基础，掌握好结构体的使用对后续学习方法和接口非常重要。\n","date":"2026-02-04T17:15:16+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-09/","title":"Golang学习历程【第九篇 结构体(struct)】"},{"content":"1. 什么是指针\r指针是编程中一个重要的概念，它就像一个\u0026quot;地址标签\u0026quot;，存储着内存中某个变量的具体位置信息。通过指针，我们可以直接访问和操作内存中的数据。\n1.1 指针的基本概念\r想象一下现实生活中的场景：\n你的家有一个具体地址（比如：北京市朝阳区xxx街道xxx号） 别人想要找到你家，只需要知道这个地址就可以了 指针就相当于这个\u0026quot;地址\u0026quot;，它存储的是变量在内存中的位置 在计算机中：\n每个变量都会被分配一块内存空间来存储数据 这块内存空间有一个唯一的地址 指针变量存储的就是这个内存地址 1.2 为什么需要指针\r指针主要有以下几个重要作用：\n节省内存：传递大型数据结构时，传递指针比传递整个数据更高效 直接修改：可以在函数中直接修改原始数据 动态内存管理：可以动态地分配和释放内存 数据结构实现：链表、树等复杂数据结构的实现基础 2. 指针的声明和使用\r2.1 指针的声明\r// 指针的声明语法：var 指针变量名 *数据类型 var ptr *int // 声明一个指向int类型的指针 var ptr2 *string // 声明一个指向string类型的指针 var ptr3 *float64 // 声明一个指向float64类型的指针 2.2 获取变量地址（\u0026amp;操作符）\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 声明普通变量 var num int = 100 var name string = \u0026#34;张三\u0026#34; var score float64 = 95.5 // 使用\u0026amp;操作符获取变量的内存地址 var ptrNum *int = \u0026amp;num var ptrName *string = \u0026amp;name var ptrScore *float64 = \u0026amp;score fmt.Printf(\u0026#34;变量num的值：%d，地址：%p\\n\u0026#34;, num, \u0026amp;num) fmt.Printf(\u0026#34;变量name的值：%s，地址：%p\\n\u0026#34;, name, \u0026amp;name) fmt.Printf(\u0026#34;变量score的值：%f，地址：%p\\n\u0026#34;, score, \u0026amp;score) fmt.Printf(\u0026#34;指针ptrNum存储的地址：%p，指向的值：%d\\n\u0026#34;, ptrNum, *ptrNum) fmt.Printf(\u0026#34;指针ptrName存储的地址：%p，指向的值：%s\\n\u0026#34;, ptrName, *ptrName) fmt.Printf(\u0026#34;指针ptrScore存储的地址：%p，指向的值：%f\\n\u0026#34;, ptrScore, *ptrScore) } 运行结果：\n变量num的值：100，地址：0xc0000140a8 变量name的值：张三，地址：0xc000010230 变量score的值：95.500000，地址：0xc0000140b8 指针ptrNum存储的地址：0xc0000140a8，指向的值：100 指针ptrName存储的地址：0xc000010230，指向的值：张三 指针ptrScore存储的地址：0xc0000140b8，指向的值：95.500000 2.3 访问指针指向的值（*操作符）\rpackage main import \u0026#34;fmt\u0026#34; func main() { var num int = 50 var ptr *int = \u0026amp;num // ptr指向num的地址 fmt.Printf(\u0026#34;num的值：%d\\n\u0026#34;, num) fmt.Printf(\u0026#34;ptr存储的地址：%p\\n\u0026#34;, ptr) fmt.Printf(\u0026#34;通过指针访问的值：%d\\n\u0026#34;, *ptr) // *ptr表示获取ptr指向地址处的值 // 通过指针修改值 *ptr = 100 fmt.Printf(\u0026#34;修改后num的值：%d\\n\u0026#34;, num) // num的值也被修改了 fmt.Printf(\u0026#34;通过指针访问修改后的值：%d\\n\u0026#34;, *ptr) } 运行结果：\nnum的值：50 ptr存储的地址：0xc0000140a8 通过指针访问的值：50 修改后num的值：100 通过指针访问修改后的值：100 3. 指针的零值和nil\r3.1 指针的零值\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 声明指针变量但不初始化 var ptr *int var ptr2 *string fmt.Printf(\u0026#34;未初始化的int指针：%v，是否为nil：%t\\n\u0026#34;, ptr, ptr == nil) fmt.Printf(\u0026#34;未初始化的string指针：%v，是否为nil：%t\\n\u0026#34;, ptr2, ptr2 == nil) // 尝试访问未初始化指针的值会导致panic // fmt.Println(*ptr) // 这行代码会报错！ } 运行结果：\n未初始化的int指针：\u0026lt;nil\u0026gt;，是否为nil：true 未初始化的string指针：\u0026lt;nil\u0026gt;，是否为nil：true 3.2 nil指针的安全检查\rpackage main import \u0026#34;fmt\u0026#34; func main() { var ptr *int // 安全检查 if ptr != nil { fmt.Println(\u0026#34;指针不为nil，可以安全访问\u0026#34;) fmt.Println(*ptr) } else { fmt.Println(\u0026#34;指针为nil，不能访问\u0026#34;) } // 初始化指针后 num := 42 ptr = \u0026amp;num if ptr != nil { fmt.Println(\u0026#34;指针不为nil，可以安全访问\u0026#34;) fmt.Println(\u0026#34;指针指向的值：\u0026#34;, *ptr) } } 运行结果：\n指针为nil，不能访问 指针不为nil，可以安全访问 指针指向的值： 42 4. 指针与函数\r4.1 指针作为函数参数\rpackage main import \u0026#34;fmt\u0026#34; // 传值方式 - 不会修改原始值 func changeValueByValue(x int) { x = 100 fmt.Printf(\u0026#34;函数内x的值：%d\\n\u0026#34;, x) } // 传指针方式 - 可以修改原始值 func changeValueByPointer(ptr *int) { *ptr = 200 fmt.Printf(\u0026#34;函数内通过指针修改的值：%d\\n\u0026#34;, *ptr) } func main() { num := 50 fmt.Printf(\u0026#34;调用函数前num的值：%d\\n\u0026#34;, num) // 传值调用 changeValueByValue(num) fmt.Printf(\u0026#34;传值调用后num的值：%d\\n\u0026#34;, num) // 传指针调用 changeValueByPointer(\u0026amp;num) fmt.Printf(\u0026#34;传指针调用后num的值：%d\\n\u0026#34;, num) } 运行结果：\n调用函数前num的值：50 函数内x的值：100 传值调用后num的值：50 函数内通过指针修改的值：200 传指针调用后num的值：200 4.2 返回指针的函数\rpackage main import \u0026#34;fmt\u0026#34; // 返回指向int的指针 func createIntPointer(value int) *int { return \u0026amp;value } // 返回指向结构体的指针 func createStudentPointer(name string, age int) *struct { Name string Age int } { student := struct { Name string Age int }{name, age} return \u0026amp;student } func main() { // 获取指针 ptr := createIntPointer(999) fmt.Printf(\u0026#34;指针地址：%p，指向的值：%d\\n\u0026#34;, ptr, *ptr) // 修改通过指针访问的值 *ptr = 888 fmt.Printf(\u0026#34;修改后的值：%d\\n\u0026#34;, *ptr) // 结构体指针 studentPtr := createStudentPointer(\u0026#34;李四\u0026#34;, 20) fmt.Printf(\u0026#34;学生信息：%s，%d岁\\n\u0026#34;, (*studentPtr).Name, (*studentPtr).Age) // Go语言提供了简化语法 fmt.Printf(\u0026#34;学生信息简化写法：%s，%d岁\\n\u0026#34;, studentPtr.Name, studentPtr.Age) } 运行结果：\n指针地址：0xc0000140a8，指向的值：999 修改后的值：888 学生信息：李四，20岁 学生信息简化写法：李四，20岁 5. 指针数组和数组指针\r5.1 指针数组\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 创建几个变量 a, b, c := 1, 2, 3 // 指针数组 - 数组的每个元素都是指针 ptrArray := [3]*int{\u0026amp;a, \u0026amp;b, \u0026amp;c} fmt.Println(\u0026#34;指针数组的内容：\u0026#34;) for i, ptr := range ptrArray { fmt.Printf(\u0026#34;索引%d：地址%p，值%d\\n\u0026#34;, i, ptr, *ptr) } // 通过指针数组修改原变量 *ptrArray[0] = 10 *ptrArray[1] = 20 *ptrArray[2] = 30 fmt.Printf(\u0026#34;修改后：a=%d, b=%d, c=%d\\n\u0026#34;, a, b, c) } 运行结果：\n指针数组的内容： 索引0：地址0xc0000140a8，值1 索引1：地址0xc0000140b0，值2 索引2：地址0xc0000140b8，值3 修改后：a=10, b=20, c=30 5.2 数组指针\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 普通数组 arr := [3]int{10, 20, 30} // 数组指针 - 指向整个数组的指针 arrPtr := \u0026amp;arr fmt.Printf(\u0026#34;数组地址：%p\\n\u0026#34;, \u0026amp;arr) fmt.Printf(\u0026#34;数组指针存储的地址：%p\\n\u0026#34;, arrPtr) fmt.Printf(\u0026#34;通过数组指针访问元素：%d, %d, %d\\n\u0026#34;, (*arrPtr)[0], (*arrPtr)[1], (*arrPtr)[2]) // 修改数组元素 (*arrPtr)[0] = 100 (*arrPtr)[1] = 200 (*arrPtr)[2] = 300 fmt.Printf(\u0026#34;修改后数组：%v\\n\u0026#34;, arr) // Go语言的简化写法 arrPtr[0] = 1000 // 等价于 (*arrPtr)[0] = 1000 fmt.Printf(\u0026#34;简化写法修改后：%v\\n\u0026#34;, arr) } 运行结果：\n数组地址：0xc000016060 数组指针存储的地址：0xc000016060 通过数组指针访问元素：10, 20, 30 修改后数组：[100 200 300] 简化写法修改后：[1000 200 300] 6. 指针的指针（多级指针）\rpackage main import \u0026#34;fmt\u0026#34; func main() { num := 42 // 一级指针 ptr1 := \u0026amp;num fmt.Printf(\u0026#34;num值：%d，地址：%p\\n\u0026#34;, num, \u0026amp;num) fmt.Printf(\u0026#34;一级指针ptr1：%p，指向的值：%d\\n\u0026#34;, ptr1, *ptr1) // 二级指针（指向指针的指针） ptr2 := \u0026amp;ptr1 fmt.Printf(\u0026#34;二级指针ptr2：%p，指向的地址：%p，最终值：%d\\n\u0026#34;, ptr2, *ptr2, **ptr2) // 三级指针 ptr3 := \u0026amp;ptr2 fmt.Printf(\u0026#34;三级指针ptr3：%p，最终值：%d\\n\u0026#34;, ptr3, ***ptr3) // 通过多级指针修改值 ***ptr3 = 999 fmt.Printf(\u0026#34;通过三级指针修改后num的值：%d\\n\u0026#34;, num) } 运行结果：\nnum值：42，地址：0xc0000140a8 一级指针ptr1：0xc0000140a8，指向的值：42 二级指针ptr2：0xc000006028，指向的地址：0xc0000140a8，最终值：42 三级指针ptr3：0xc000006038，最终值：42 通过三级指针修改后num的值：999 7. 指针的实际应用示例\r7.1 交换两个数的值\rpackage main import \u0026#34;fmt\u0026#34; // 使用指针交换两个数 func swap(a, b *int) { temp := *a *a = *b *b = temp } func main() { x, y := 10, 20 fmt.Printf(\u0026#34;交换前：x=%d, y=%d\\n\u0026#34;, x, y) swap(\u0026amp;x, \u0026amp;y) fmt.Printf(\u0026#34;交换后：x=%d, y=%d\\n\u0026#34;, x, y) } 运行结果：\n交换前：x=10, y=20 交换后：x=20, y=10 7.2 链表节点示例\rpackage main import \u0026#34;fmt\u0026#34; // 定义链表节点结构 type ListNode struct { Value int Next *ListNode } // 创建新节点 func NewNode(value int) *ListNode { return \u0026amp;ListNode{Value: value, Next: nil} } // 在链表末尾添加节点 func AppendNode(head **ListNode, value int) { newNode := NewNode(value) if *head == nil { *head = newNode return } current := *head for current.Next != nil { current = current.Next } current.Next = newNode } // 打印链表 func PrintList(head *ListNode) { current := head for current != nil { fmt.Printf(\u0026#34;%d -\u0026gt; \u0026#34;, current.Value) current = current.Next } fmt.Println(\u0026#34;nil\u0026#34;) } func main() { var head *ListNode = nil // 添加节点 AppendNode(\u0026amp;head, 1) AppendNode(\u0026amp;head, 2) AppendNode(\u0026amp;head, 3) AppendNode(\u0026amp;head, 4) fmt.Println(\u0026#34;链表内容：\u0026#34;) PrintList(head) } 运行结果：\n链表内容： 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; nil 8. 指针注意事项和最佳实践\r8.1 注意事项\r空指针访问危险：访问nil指针会导致程序崩溃 野指针问题：指向已释放内存的指针 内存泄漏：忘记释放动态分配的内存 8.2 最佳实践\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 1. 始终检查指针是否为nil var ptr *int if ptr != nil { fmt.Println(*ptr) // 安全访问 } // 2. 初始化指针 num := 100 ptr = \u0026amp;num fmt.Printf(\u0026#34;安全访问：%d\\n\u0026#34;, *ptr) // 3. 使用指针时要考虑生命周期 data := make([]int, 5) ptrToSlice := \u0026amp;data fmt.Printf(\u0026#34;切片指针：%v\\n\u0026#34;, *ptrToSlice) // 4. 函数返回指针时要注意 func returnPointer() *int { value := 42 // 局部变量 return \u0026amp;value // 危险！返回局部变量的地址 } // 正确的做法 func returnPointerSafe() *int { value := new(int) // 在堆上分配内存 *value = 42 return value } } 9. new函数和make函数的区别\r9.1 new函数\rpackage main import \u0026#34;fmt\u0026#34; func main() { // new函数为指定类型分配零值内存并返回指针 ptr1 := new(int) // *int类型，值为0 ptr2 := new(string) // *string类型，值为\u0026#34;\u0026#34; ptr3 := new([3]int) // *[3]int类型，值为[0,0,0] fmt.Printf(\u0026#34;int指针：%p，值：%d\\n\u0026#34;, ptr1, *ptr1) fmt.Printf(\u0026#34;string指针：%p，值：%s\\n\u0026#34;, ptr2, *ptr2) fmt.Printf(\u0026#34;数组指针：%p，值：%v\\n\u0026#34;, ptr3, *ptr3) // 修改值 *ptr1 = 100 *ptr2 = \u0026#34;Hello\u0026#34; (*ptr3)[0] = 1 (*ptr3)[1] = 2 (*ptr3)[2] = 3 fmt.Printf(\u0026#34;修改后int值：%d\\n\u0026#34;, *ptr1) fmt.Printf(\u0026#34;修改后string值：%s\\n\u0026#34;, *ptr2) fmt.Printf(\u0026#34;修改后数组值：%v\\n\u0026#34;, *ptr3) } 运行结果：\nint指针：0xc0000140a8，值：0 string指针：0xc000010230，值： 数组指针：0xc000016060，值：[0 0 0] 修改后int值：100 修改后string值：Hello 修改后数组值：[1 2 3] 9.2 make函数\rpackage main import \u0026#34;fmt\u0026#34; func main() { // make函数用于创建切片、map、channel slice := make([]int, 5) // 创建长度为5的切片 mapData := make(map[string]int) // 创建map ch := make(chan int) // 创建channel fmt.Printf(\u0026#34;切片：%v，长度：%d\\n\u0026#34;, slice, len(slice)) fmt.Printf(\u0026#34;map：%v\\n\u0026#34;, mapData) fmt.Printf(\u0026#34;channel：%v\\n\u0026#34;, ch) // 初始化数据 slice[0] = 10 slice[1] = 20 mapData[\u0026#34;one\u0026#34;] = 1 mapData[\u0026#34;two\u0026#34;] = 2 fmt.Printf(\u0026#34;初始化后切片：%v\\n\u0026#34;, slice) fmt.Printf(\u0026#34;初始化后map：%v\\n\u0026#34;, mapData) } 10. 总结\r指针是Golang中一个强大但需要谨慎使用的特性：\n核心概念：\n指针存储的是内存地址，而不是具体的值 使用\u0026amp;获取变量地址，使用*访问指针指向的值 指针的零值是nil 主要用途：\n函数间共享和修改数据 避免大数据结构的拷贝开销 实现复杂数据结构（链表、树等） 动态内存管理 注意事项：\n始终检查指针是否为nil 注意变量的生命周期 避免悬空指针和内存泄漏 掌握指针对于深入理解Golang和编写高效的程序非常重要，虽然初学时可能会觉得复杂，但通过大量练习就能熟练运用。\n","date":"2026-02-04T16:15:16+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-08/","title":"Golang学习历程【第八篇 指针(pointer)】"},{"content":"多租户架构入门指南：小白如何快速搞懂 SaaS 系统的共享机制\r多租户（Multi-Tenancy）是现代 SaaS 系统中最常见且最重要的架构模式之一。许多初学者在学习过程中会感到概念抽象、实现方式难以把握。本文从零基础视角出发，以清晰的结构、通俗的语言和简明说明，帮助读者快速建立对多租户的整体认知。\n1. 什么是多租户？它到底是架构还是思维方式？\r官方定义\n多租户是一种软件架构模式，指单一的软件实例（或基础设施）能够同时为多个独立的租户（Tenant，通常指不同的客户、企业、组织）提供服务，同时通过技术手段保证数据隔离、安全性、隐私合规以及资源的高效利用。\n通俗理解\n可以将多租户想象为一栋大型共享公寓大楼：\n大楼的基础设施（电梯、水电、大堂、消防系统）由所有住户共同使用 但每位住户拥有独立的房间，房门上锁，内部物品与他人完全隔离 这种方式无需为每户单独建造一栋别墅，就能让多家住户共同居住，既节约成本又便于管理 多租户正是基于同样的思路：一套软件系统同时服务多家公司，但每家公司的数据与操作在逻辑上完全隔离，互不干扰。\n它不是一种抽象的思维方式，而是一种具体的、可落地的系统设计方案。\ngraph TD\rA[共享基础设施\u0026lt;br\u0026gt;服务器 / 代码 / 基础服务] --\u0026gt; B[租户 A\u0026lt;br\u0026gt;独立数据与上下文]\rA --\u0026gt; C[租户 B\u0026lt;br\u0026gt;独立数据与上下文]\rA --\u0026gt; D[租户 C\u0026lt;br\u0026gt;独立数据与上下文]\rclassDef shared fill:#e6f3ff,stroke:#0066cc,stroke-width:2px\rclassDef tenant fill:#fff3e6,stroke:#cc6600,stroke-width:2px\rclass A shared\rclass B,C,D tenant\r2. 多租户在实际项目中是如何实现的？\r多租户实现的核心在于隔离，其中最关键的部分通常是数据库隔离，其次是应用层上下文管理与基础设施隔离。\n数据库隔离的三种主流模式\r特点对比表\n方式 隔离强度 资源成本 管理复杂度 典型适用场景 独立数据库（每租户一个库） ★★★★★ 高 高 高合规要求、金融、医疗、大客户 共享数据库 + 独立 Schema ★★★★☆ 中 中 中大型 SaaS，几百至数千租户 共享数据库 + 共享 Schema + 行级隔离 ★★★☆☆ 低 低 大规模消费级 SaaS，万级以上租户 通俗比喻\n独立数据库 → 每家公司租一整层楼 独立 Schema → 每家公司租同一层楼中的独立套房 行级隔离 → 大家共用一个大空间，但每张床位贴有明确标识并有严格管控 graph LR\rA[数据库隔离方式] --\u0026gt; B[独立数据库\u0026lt;br\u0026gt;每租户一个物理库]\rA --\u0026gt; C[共享数据库 + 独立 Schema\u0026lt;br\u0026gt;逻辑命名空间隔离]\rA --\u0026gt; D[共享数据库 + 共享 Schema\u0026lt;br\u0026gt;行级隔离 tenant_id]\rB --\u0026gt;|隔离最强| E[最高合规需求\u0026lt;br\u0026gt;金融/医疗/大客户]\rC --\u0026gt;|平衡方案| F[中大型 SaaS\u0026lt;br\u0026gt;数百~数千租户]\rD --\u0026gt;|成本最低| G[大规模消费级 SaaS\u0026lt;br\u0026gt;万级以上租户]\rclassDef high fill:#ffcccc,stroke:#990000\rclassDef medium fill:#ffffcc,stroke:#996600\rclassDef low fill:#ccffcc,stroke:#006600\rclass B high\rclass C medium\rclass D low\r3. 多租户与角色权限（RBAC）有何区别？\r多租户和角色权限（RBAC）是两个不同层面的概念，经常被混淆。\n核心区别对比\n维度 多租户 角色权限（RBAC） 解决的问题 多家公司共用一套系统，数据需隔离 同一家公司内部，不同人权限不同 隔离的对象 公司 vs 公司 人 vs 人（同一公司内） 所属层级 架构层、系统边界 权限模块、功能层 配置主体 通常由平台方（SaaS 厂商）负责 通常由客户（租户管理员）自行配置 一句话总结\n多租户决定“几家公司合租一栋大楼”，角色权限决定“一家公司内部谁持有哪把钥匙”。\ngraph TD\rA[整个系统] --\u0026gt; B[多租户层\u0026lt;br\u0026gt;公司 / 组织边界隔离]\rB --\u0026gt; C[租户内部\u0026lt;br\u0026gt;RBAC 权限控制]\rsubgraph 租户边界\rC --\u0026gt; D[角色：管理员]\rC --\u0026gt; E[角色：普通员工]\rC --\u0026gt; F[角色：财务人员]\rend\rclassDef boundary fill:#f0f8ff,stroke:#4682b4,stroke-width:2px\rclassDef rbac fill:#fffacd,stroke:#dAA520,stroke-width:2px\rclass B boundary\rclass C,D,E,F rbac\r4. 客户个性化需求会让多租户变得非常复杂吗？\r个性化需求确实是多租户落地中最常见的挑战之一。\n定制化复杂度层级（由低到高）\n外观与品牌（Logo、主题色、文案、登录页） 字段与表单（增删字段、显隐规则、校验规则） 流程与规则（审批流、状态机、计算公式） 业务逻辑分叉（策略模式、Hook、插件） 全新模块或完全不同的业务模型（微服务、独立部署） 处理原则\n优先使用配置解决 次之使用规则引擎或可编辑规则 尽量避免硬编码，改为策略模式或插件机制 极少数极端定制场景可采用混合部署或独立部署 5. 结语与学习建议\r多租户的核心价值可以用一句话概括：以最少的资源投入，安全、高效地服务尽可能多的独立客户。\n","date":"2026-02-04T08:35:21+08:00","permalink":"https://zg-dd.github.io/stu/multi-tenancy-guide/","title":"多租户架构入门指南：小白如何快速搞懂 SaaS 系统的共享机制"},{"content":"概述\rDelve（简称 dlv）是 Go 语言的官方调试器，专门为 Go 的并发模型和运行时特性设计。它是目前 Go 生态中最主流、功能最强大的调试工具。\n安装\r推荐安装方式\r使用 Go Module 模式安装最新版本：\ngo install github.com/go-delve/delve/cmd/dlv@latest 验证安装\r安装完成后，在终端输入以下命令验证：\ndlv version 如果 $GOPATH/bin 不在你的 PATH 环境变量中，需要将其加入，或者直接使用完整路径：\n~/go/bin/dlv version 核心功能\rDelve 提供以下核心功能：\n设置断点：在特定行、函数名处暂停程序执行 单步执行：逐行或进入函数内部执行代码 变量查看：打印变量值、检查复杂数据结构 Goroutine 管理：查看所有 Goroutine，在特定 Goroutine 上下文中调试 运行时修改变量：动态改变变量值进行测试 调用栈查看：了解程序执行路径 基本用法\r示例代码\r创建测试文件 main.go：\npackage main import \u0026#34;fmt\u0026#34; func main() { message := \u0026#34;Hello, Delve!\u0026#34; fmt.Println(message) result := add(23, 19) fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) } func add(a, b int) int { sum := a + b return sum } 启动调试会话\r模式1：直接调试源代码\rdlv debug main.go 模式2：调试已编译的可执行文件\rgo build -o myapp main.go dlv exec ./myapp 模式3：附加到运行中的进程\r# 编译并启动程序 go build -gcflags=\u0026#34;all=-N -l\u0026#34; -o myapp main.go ./myapp \u0026amp; # 获取进程ID并附加 PID=$! dlv attach $PID 常用调试命令\r断点管理\r命令 缩写 功能 break main.main b main.main 在 main 函数设断点 break main.go:10 b main.go:10 在第10行设断点 breakpoints bp 列出所有断点 clear 1 - 删除ID为1的断点 clearall - 删除所有断点 程序执行控制\r命令 缩写 功能 continue c 继续执行直到下一个断点 next n 执行当前行，不进入函数 step s 执行当前行，进入函数内部 stepout so 执行完当前函数，返回调用者 restart r 重新运行程序 变量和表达式查看\r命令 缩写 功能 print message p message 打印变量值 locals - 打印当前函数所有局部变量 args - 打印当前函数参数 其他实用命令\r命令 缩写 功能 stack bt 打印调用栈 goroutines - 列出所有 Goroutine goroutine 1 g 1 切换到指定 Goroutine exit q 退出调试器 完整调试会话示例\r$ dlv debug main.go Type \u0026#39;help\u0026#39; for list of commands. # 设置断点 (dlv) b main.main Breakpoint 1 set at 0x... for main.main() ./main.go:5 (dlv) b main.go:11 Breakpoint 2 set at 0x... for main.main() ./main.go:11 # 开始执行 (dlv) c \u0026gt; main.main() ./main.go:5 (hits goroutine(1):1 total:1) (PC: 0x...) 1: package main 2: 3: import \u0026#34;fmt\u0026#34; 4: =\u0026gt; 5: func main() { 6: message := \u0026#34;Hello, Delve!\u0026#34; 7: fmt.Println(message) 8: result := add(23, 19) 9: fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) 10: } # 单步执行 (dlv) n \u0026gt; main.main() ./main.go:6 (PC: 0x...) 5: func main() { =\u0026gt; 6: message := \u0026#34;Hello, Delve!\u0026#34; 7: fmt.Println(message) 8: result := add(23, 19) 9: fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) 10: } # 查看变量 (dlv) p message \u0026#34;\u0026#34; (dlv) n \u0026gt; main.main() ./main.go:7 (PC: 0x...) (dlv) p message \u0026#34;Hello, Delve!\u0026#34; # 步入函数 (dlv) s \u0026gt; fmt.Println(...) # 步出函数 (dlv) so Hello, Delve! \u0026gt; main.main() ./main.go:8 (PC: 0x...) # 继续执行 (dlv) c Result: 42 \u0026gt; main.main() ./main.go:11 (hits goroutine(1):1 total:1) (PC: 0x...) (dlv) p result 42 # 退出 (dlv) q 高级功能\r条件断点\r设置只在特定条件下触发的断点：\n# 当 i == 5 时才在第10行暂停 (dlv) b main.go:10 Breakpoint 1 set at main.go:10 (dlv) cond 1 i == 5 调试测试代码\rDelve 可以直接调试测试用例：\ndlv test main_test.go 在测试函数上设置断点：\n(dlv) b TestMyFunction 传递命令行参数\r如果程序需要命令行参数：\ndlv debug -- arg1 arg2 # 或 dlv exec ./myapp -- arg1 arg2 Goroutine 调试\r调试并发程序时的 Goroutine 操作：\n# 查看所有 Goroutine (dlv) goroutines # 切换到特定 Goroutine (dlv) goroutine 5 # 在当前 Goroutine 上下文中查看变量 (dlv) p localVar 实用技巧\r1. 生产环境调试\r对于生产环境程序，编译时禁用优化：\ngo build -gcflags=\u0026#34;all=-N -l\u0026#34; -o myapp main.go 2. 性能考虑\r调试版本程序运行较慢，仅用于调试目的 生产环境使用标准编译选项 3. IDE 集成\rVS Code：安装 Go 扩展，使用内置调试界面 Goland：原生支持 Delve，提供图形化调试界面 掌握命令行操作有助于理解 IDE 调试过程 4. 常见问题排查\r问题：断点无法命中\n检查代码优化选项，确保使用 -gcflags=\u0026quot;all=-N -l\u0026quot; 确认断点设置在正确的行号和函数 问题：变量显示优化值\n由于编译器优化，变量值可能显示不准确 使用禁用优化的方式编译调试版本 总结\rDelve 是 Go 开发者必备的调试工具，通过熟练掌握其使用方法，可以：\n快速定位问题：通过断点和单步执行精准定位 bug 深入理解代码：观察变量变化和程序执行流程 调试并发程序：管理 Goroutine 和排查并发问题 提高开发效率：减少调试时间，增加开发信心 建议从简单程序开始练习，逐步熟悉各种命令和场景，最终能够熟练运用 Delve 解决复杂的调试问题。\n","date":"2025-11-19T11:00:42+08:00","permalink":"https://zg-dd.github.io/stu/go-delve/","title":"Go 语言调试器 Delve (dlv) 学习笔记"},{"content":"Docker\u0026amp;Docker Complete常用命令大全\r一、镜像（Image）管理\r镜像就像是软件的安装包或模板。\n命令 描述 示例 docker imagesdocker image ls 列出本地所有镜像 docker images docker search \u0026lt;名称\u0026gt; 从仓库搜索镜像 docker search nginx docker pull \u0026lt;镜像名\u0026gt;:\u0026lt;标签\u0026gt; 下载镜像（不指定标签则默认为 latest） docker pull nginx:alpine docker rmi \u0026lt;镜像ID或名\u0026gt; 删除本地镜像 docker rmi nginx docker image prune 清理未被使用的镜像（悬空镜像） docker image prune docker build -t \u0026lt;标签\u0026gt; . 根据 Dockerfile 构建镜像（. 代表当前目录） docker build -t my-app:1.0 . 二、容器（Container）管理\r容器是从镜像运行起来的实例。\n命令 描述 示例 docker run [选项] \u0026lt;镜像\u0026gt; 创建并启动一个新容器 docker run -d -p 80:80 nginx docker start \u0026lt;容器名/ID\u0026gt; 启动一个已停止的容器 docker start my_nginx docker stop \u0026lt;容器名/ID\u0026gt; 停止一个运行中的容器（优雅停止） docker stop my_nginx docker restart \u0026lt;容器名/ID\u0026gt; 重启容器 docker restart my_nginx docker rm \u0026lt;容器名/ID\u0026gt; 删除一个已停止的容器 docker rm my_nginx docker container prune 删除所有已停止的容器 docker container prune docker ps 列出正在运行的容器 docker ps docker ps -a 列出所有容器（包括已停止的） docker ps -a docker logs \u0026lt;容器名/ID\u0026gt; 查看容器的日志输出 docker logs my_nginx docker logs -f \u0026lt;容器名/ID\u0026gt; 实时跟踪（跟随）日志输出 docker logs -f my_nginx docker exec -it \u0026lt;容器名/ID\u0026gt; \u0026lt;命令\u0026gt; 在运行中的容器内执行命令 docker exec -it my_nginx /bin/bash 三、网络（Network）管理\r命令 描述 示例 docker network ls 列出所有网络 docker network ls docker network create \u0026lt;网络名\u0026gt; 创建一个新网络 docker network create my_net docker network inspect \u0026lt;网络名\u0026gt; 查看网络详细信息 docker network inspect bridge 四、数据卷（Volume）管理\r数据卷用于持久化存储数据。\n命令 描述 示例 docker volume ls 列出所有数据卷 docker volume ls docker volume create \u0026lt;卷名\u0026gt; 创建一个数据卷 docker volume create my_data docker volume rm \u0026lt;卷名\u0026gt; 删除一个数据卷 docker volume rm my_data docker volume prune 清理未被使用的数据卷 docker volume prune 五、系统与信息\r命令 描述 示例 docker info 显示 Docker 系统信息 docker info docker version 显示 Docker 版本信息 docker version docker stats 实时显示容器资源使用统计 docker stats docker system df 查看 Docker 磁盘使用情况 docker system df 六、Docker Compose 常用命令\r用于管理多容器应用。\n命令 描述 示例 docker compose up 创建并启动所有服务 docker compose up docker compose up -d 在后台创建并启动所有服务 docker compose up -d docker compose down 停止并删除所有容器、网络 docker compose down docker compose ps 列出本项目下的所有容器 docker compose ps docker compose logs 查看所有服务的日志 docker compose logs docker compose logs -f \u0026lt;服务名\u0026gt; 实时跟踪特定服务的日志 docker compose logs -f web docker compose exec \u0026lt;服务名\u0026gt; \u0026lt;命令\u0026gt; 在指定服务的容器中执行命令 docker compose exec db mysql -u root -p 命令中的常用选项（Flags）释义\r选项 全称 含义 示例 -d --detach 后台运行容器 docker run -d nginx -it -i -t 交互式运行（分配伪终端，通常与 /bin/bash 连用） docker run -it ubuntu /bin/bash -p --publish 端口映射（主机端口:容器端口） docker run -p 8080:80 nginx -v --volume 挂载数据卷或目录 docker run -v /host/data:/container/data nginx -e --env 设置环境变量 docker run -e MY_VAR=value nginx --name 为容器指定一个名称 docker run --name my_nginx nginx --rm 容器退出时自动删除（常用于测试） docker run --rm alpine echo \u0026quot;hello\u0026quot; 🚀 最常用命令总结（快速上手）\r看状态: docker ps (看容器), docker images (看镜像) 拉镜像: docker pull \u0026lt;名字\u0026gt; 启容器: docker run -d -p ... --name ... \u0026lt;镜像名\u0026gt; 停容器: docker stop \u0026lt;名字\u0026gt; 进容器: docker exec -it \u0026lt;名字\u0026gt; /bin/bash 看日志: docker logs -f \u0026lt;名字\u0026gt; 删容器: docker rm \u0026lt;名字\u0026gt; 删镜像: docker rmi \u0026lt;名字\u0026gt; 建议: 将这份列表保存下来，作为日常操作的速查手册。\n","date":"2025-09-25T11:57:50+08:00","permalink":"https://zg-dd.github.io/stu/docker-command/","title":"Docker 常用命令速查"},{"content":"网络通讯核心知识\r一、核心概念\r1. Socket\r是什么：进程间通信(IPC)的扩展机制\n用途：建立网络通信通道（TCP/UDP）\n流程：\n服务端：socket → bind → listen → accept 客户端：socket → connect → write/read → close\n注意事项：需处理字节序转换(htonl/ntohl) 2. TCP vs UDP\r特性 TCP UDP 连接方式 面向连接（三次握手） 无连接 可靠性 可靠传输（重传机制） 不可靠传输 数据形式 流式套接字 数据报套接字 适用场景 文件传输、网页浏览 实时视频、DNS查询 二、服务器模型\r1. 迭代服务器\r缺陷：单线程阻塞，无法并发处理请求\n2. 进程/线程模型\r进程方案：\n需用waitpid()避免僵尸进程 注意：子进程结束需父进程回收资源 僵尸进程处理详解：\n产生原因：\n子进程终止但未被父进程wait() 会占用系统进程表资源 处理方法：\n同步回收： waitpid(pid, NULL, 0); // 阻塞等待 异步回收（推荐）： signal(SIGCHLD, [](int) { while(waitpid(-1, NULL, WNOHANG) \u0026gt; 0); }); 特殊情形：\n父进程先终止时，僵尸进程由init进程接管并回收 批量回收时需循环调用waitpid() 线程方案：\n需处理共享变量加锁问题 线程同步更复杂（临界区/锁机制） 3. 进程池优化\r类型 特点 静态进程池 预创建进程，限制并发上限 动态进程池 维护最小/最大空闲进程数 三、高性能I/O模型\r1. 传统阻塞模型\r特点：\n单线程阻塞等待I/O就绪 资源利用率低 2. Select/Poll\r特性 Select Poll 实现原理 位图轮询FD(描述符集) 链表轮询FD(描述符集) 最大连接数 1024（FD_SETSIZE限制） 无硬性限制 效率缺陷 O(n)线性扫描 O(n)线性扫描 跨平台性 所有平台支持 所有平台支持 3. Epoll\r核心机制：\n事件注册：通过epoll_ctl维护红黑树 就绪列表：内核维护就绪FD双向链表 触发模式： LT（Level Trigger）：类似Poll的触发方式 ET（Edge Trigger）：状态变化时单次通知 性能优势：\nO(1)事件通知复杂度 百万级连接支持（C1000K场景） 4. NIO（Non-blocking I/O）\r核心组件：\nChannel：全双工通信管道（SocketChannel/FileChannel） Buffer：结构化数据容器（ByteBuffer/CharBuffer） Selector：多路复用器（基于系统epoll/kqueue实现） 工作流程：\nstart\r: 创建Selector;\r: 注册Channel到Selector;\rrepeat\r: select()查询就绪事件;\r: 处理SelectionKey事件;\rrepeat while (有事件?) stop 5. AIO（Asynchronous I/O）\r实现原理：\n内核完成I/O操作后主动回调 无需用户线程轮询 典型场景：\n大文件异步读写 高延迟网络操作 6. 完整对比表\r模型 阻塞性 线程要求 触发方式 适用场景 阻塞I/O 完全阻塞 1:1 - 低并发简单场景 Select 非阻塞 1:N 轮询通知 跨平台中等并发 Poll 非阻塞 1:N 轮询通知 连接数\u0026lt;10K Epoll 非阻塞 1:N 事件驱动 Linux高并发系统 NIO 非阻塞 1:N 就绪选择 高吞吐应用 AIO 异步 0:1 完成回调 延迟敏感型操作 补充说明\r内核支持：\nWindows：IOCP是真正的异步I/O Linux：5.1+内核的io_uring接近真异步 性能临界点：\nC10K：Select/Poll达到性能瓶颈 C100K：必须使用Epoll/NIO C1000K：需要Epoll+零拷贝优化 编程复杂度：\n阻塞I/O \u0026lt; Select \u0026lt; Poll \u0026lt; Epoll \u0026lt; NIO \u0026lt; AIO 四、实践要点\r1. 守护进程\r关键步骤：\nfork() setsid()\n需重定向标准I/O至/dev/null 2. UDP服务器\r特点：\n无需listen()/accept() 直接使用recvfrom()/sendto() 3. 其他\rReuse Address：避免TIME_WAIT状态占用端口 惊群效应：多进程Accept互相竞争导致，需内核锁优化\n服务器类型： IO密集型：LNMP(nginx) CPU密集型：LAMP(Apache) 协程：是用户态线程，用户态调度，避免内核切换开销，线程是内核调用。对比线程：切换速度更快，资源消耗更低 五、学习建议\r1. 诊断工具\rnetstat -anp # 查看网络连接 2. 经典书籍\r《Unix网络编程》 《Unix环境高级编程》 ","date":"2025-08-15T19:08:51+08:00","permalink":"https://zg-dd.github.io/stu/socket/","title":"网络通讯核心知识"},{"content":" 个人学习笔记\n1. MCP的定义\rMCP全称（Model Content Protocol, 模型上下文协议）是2024年由Anthropic公司推出的一项开放标准协议，旨在大模型（LLM）与外部工具、数据源和服务提供统一的交互框架。其核心目标是解决AI生态中的“数据孤岛”问题，通过标准化接口实现模型与外部资源的无缝连接，类似于“AI领域的USB-C接口”或者“万能适配器”。\n2. 核心特性与技术原理\r2.1 标准化三层架构\r主机（Host）：运行AI模型的核心应用（如Claude、Desktop、IDE插件） 客户端（Client）：与服务器建立1:1连接，封装请求并转发 服务器（Server）：轻量级适配器，连接具体工具或数据源（如数据库、API、文件系统） 2.2 通信机制：JSON-RPC 2.0协议\r本地通信：通过stdio(标准输入输出)传输JSON-RPC消息，适用于本地工具调用 远程通信：基于SSE(Server-Sent Events)和Streamable HTTP的HTTP长连接，支持异步数据流 消息格式：所有请求和响应均遵循JSON-RPC 2.0规范 2.3 动态发现机制\r工具级动态发现：工具通过自描述接口（如OpenAPI）声明能力，AI模型可自动识别并调用，无需要硬编码集成 服务级动态发现（不懂）： URI驱动发现，客户端通过解析自定义URI（如mcp://api.service.com）发现远程服务：客户端访问URI对应的元数据端点（如https://api.service.com/llms.txt）。服务端返回JSON描述文件，包含功能列表，API文档和认证方式。Client根据元数据自动配置工具调用权限。应用场景：用户粘贴一个MCP URI到聊天窗口，LLM自动识别并集成该服务（如股票API），无需手动配置。 3. 安全与权限控制\r本地化执行：默认MCP Server运行在本地，避免敏感数据外泄 操作确认机制：高风险操作（如删除文件）需用户手动授权 企业级安全员扩展：支持JWT令牌、RBAC权限模型和IPsec隧道加密，满足金融、医疗等场景需求 4. 与传统技术的区别\r特性 MCP 传统API Function Calling​ 集成方式​ 统一协议，动态发现工具 每个API独立定制 需硬编码绑定特定函数 通信模式​ 双向实时交互 单向请求-响应 同步执行，无实时推送 灵活性​ 即插即用，支持多工具组合 扩展需重新开发 依赖模型供应商接口 5. 总结\rMCP协议通过 “客户端-服务器解耦” + “JSON-RPC通信” + “动态发现机制”， 解决了LLM与外部资源交互的三大痛点： 灵活性：工具可热插拔，服务可动态扩展； 安全性：本地化执行与权限控制兼顾效率与隐私； 标准化：统一协议降低集成成本，推动AI生态开放。\nMCP通过协议层解耦AI模型与工具，推动AI从“对话助手”升级为“执行代理”，成为构建复杂Agent系统的底层基础。随着企业智能化升级加速（如长虹虹信EADP平台集成MCP），该协议已成为构建下一代AI Agent的核心基础设施。\n","date":"2025-08-06T15:14:07+08:00","permalink":"https://zg-dd.github.io/stu/mcp-protocol-core/","title":"MCP 协议入门与核心机制"},{"content":"在日常开发中，使用 MyBatis 作为持久层框架时，我们经常需要查看 SQL 日志以调试和优化查询。然而，MyBatis 的日志输出通常包含占位符和参数信息，这使得直接执行这些 SQL 语句变得困难。为了解决这个问题，我们开发了一个简单的 HTML 和 JavaScript 脚本，用于解析 MyBatis 的 SQL 日志并生成可执行的 SQL 语句。\n1. 脚本功能概述\r该脚本的主要功能是：\n解析 SQL 日志：从 MyBatis 日志中提取 SQL 语句和参数。 参数替换：将 SQL 语句中的占位符 ? 替换为实际的参数值。 生成可执行 SQL：输出完整的 SQL 语句，便于在数据库中直接执行。 2. 实现细节\r2.1 HTML 结构\r脚本的 HTML 部分提供了一个简单的用户界面，包含输入区域、解析按钮和输出区域。\n输入区域：用户可以在此粘贴 MyBatis 的 SQL 日志。 解析按钮：点击后触发 JavaScript 函数进行解析。 输出区域：显示解析后的可执行 SQL 语句。 2.2 JavaScript 逻辑\rJavaScript 部分实现了日志解析的核心逻辑：\n日志分割：通过换行符将日志分割为多行，逐行处理。 SQL 语句提取：识别包含 Preparing: 的行，提取 SQL 语句。 参数解析：识别包含 Parameters: 的行，提取参数并根据类型进行处理。 字符串和时间戳：用单引号包裹，处理转义字符。 空值：替换为 NULL。 其他类型：直接替换。 结果输出：将替换后的 SQL 语句显示在输出区域。 3. 脚本代码\r创建一个.html文件，编辑，将脚本内容贴至文件内，保存，用浏览器打开文件即可使用\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Mybatis SQL日志解析\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function f(obj) { try { var textVa = obj.value; var logs = textVa.split(\u0026#39;\\n\u0026#39;); // Split by newline var results = []; var currentStatement = null; logs.forEach(function(log) { // Check if this line contains \u0026#34;Preparing:\u0026#34; or \u0026#34;Parameters:\u0026#34; if (log.indexOf(\u0026#39;Preparing:\u0026#39;) !== -1) { if (currentStatement !== null) { // If we have a current statement, push it to the results results.push(currentStatement); } // Start a new statement currentStatement = log.substring(log.indexOf(\u0026#39;Preparing:\u0026#39;) + \u0026#34;Preparing:\u0026#34;.length).trim(); } else if (log.indexOf(\u0026#39;Parameters:\u0026#39;) !== -1 \u0026amp;\u0026amp; currentStatement !== null) { // If we find parameters and have a current statement, parse the parameters var parametersStr = log.substring(log.indexOf(\u0026#39;Parameters:\u0026#39;) + \u0026#34;Parameters:\u0026#34;.length).trim(); var parameters = parametersStr.split(/,(?![^()]*\\))/g); // Use regex to split correctly for (var i = 0; i \u0026lt; parameters.length; i++) { var paramValue = parameters[i].trim(); if (paramValue === \u0026#34;null\u0026#34;) { currentStatement = currentStatement.replace(\u0026#34;?\u0026#34;, \u0026#34;NULL\u0026#34;); } else { var typeStr = paramValue.substring(paramValue.indexOf(\u0026#34;(\u0026#34;) + 1, paramValue.indexOf(\u0026#34;)\u0026#34;)); paramValue = paramValue.substring(0, paramValue.indexOf(\u0026#34;(\u0026#34;)).trim(); if (typeStr === \u0026#34;String\u0026#34; || typeStr === \u0026#34;Timestamp\u0026#34;) { paramValue = \u0026#34;\u0026#39;\u0026#34; + paramValue.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;\u0026#34;; } currentStatement = currentStatement.replace(\u0026#34;?\u0026#34;, paramValue); } } // Add the final statement to the results and reset currentStatement results.push(currentStatement); currentStatement = null; } }); // If there\u0026#39;s a remaining statement, push it to the results if (currentStatement !== null) { results.push(currentStatement); } document.getElementById(\u0026#34;d1\u0026#34;).value = results.join(\u0026#34;\\n\\n\u0026#34;); } catch (e) { console.error(e); alert(\u0026#34;解析SQL时发生错误：\u0026#34; + e.message); } } function copySQL() { var SQL = document.getElementById(\u0026#34;d1\u0026#34;); navigator.clipboard.writeText(SQL.value).then(function() { var msg = document.getElementById(\u0026#34;msg\u0026#34;); msg.innerHTML = \u0026#34;已复制到剪切板\u0026#34;; setTimeout(function () { msg.innerHTML = \u0026#34;\u0026#34;; }, 3000); }).catch(function(err) { console.error(\u0026#34;复制失败：\u0026#34;, err); alert(\u0026#34;复制SQL时发生错误：\u0026#34; + err.message); }); } function clearLog(obj) { obj.value = \u0026#34;\u0026#34;; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#00bfff\u0026#34;\u0026gt; 输入Mybatis SQL日志：\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;textarea id=\u0026#34;sqlLog\u0026#34; rows=\u0026#34;12\u0026#34; cols=\u0026#34;140\u0026#34; style=\u0026#34;font-size:12px;font-family: \u0026#39;CourierNew\u0026#39;;font-weight: bold;width: 98%;\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;div style=\u0026#34;border:0px deepskyblue solid;width:1425px;height:50px;text-align:right;\u0026#34;\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;button\u0026#34; onclick=\u0026#34;clearLog(document.getElementById(\u0026#39;sqlLog\u0026#39;))\u0026#34;\u0026gt;清空\u0026lt;/button\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;submit\u0026#34; onclick=\u0026#34;f(document.getElementById(\u0026#39;sqlLog\u0026#39;))\u0026#34;\u0026gt;解析SQL\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#32cd32\u0026#34;\u0026gt;解析为可执行SQL：\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;textarea id=\u0026#34;d1\u0026#34; rows=\u0026#34;12\u0026#34; cols=\u0026#34;140\u0026#34; style=\u0026#34;font-size:12px;font-family: \u0026#39;CourierNew\u0026#39;;font-weight: bold;width: 98%;\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;div style=\u0026#34;border:0px deepskyblue solid;width:1425px;height:50px;text-align:right;\u0026#34;\u0026gt; \u0026lt;button style=\u0026#34;color:mediumblue;width:100px;height:60px\u0026#34; type=\u0026#34;button\u0026#34; onclick=\u0026#34;copySQL()\u0026#34;\u0026gt;复制SQL\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;msg\u0026#34; style=\u0026#34;color:cornflowerblue;border:0px black solid;width:800px;height:20px;text-align:right;font-style: initial;font-size: large\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. 使用方法\r将 MyBatis 的 SQL 日志粘贴到输入区域。 点击\u0026quot;解析SQL\u0026quot;按钮。 在输出区域查看并复制解析后的 SQL 语句。 4.1 示例\r假设输入的日志为：\nPreparing: INSERT INTO users (name, email) VALUES (?, ?)\rParameters: John(String), null 解析后的输出为：\nINSERT INTO users (name, email) VALUES (\u0026#39;John\u0026#39;, NULL) 5. 总结\r通过这个简单的脚本，我们可以快速将 MyBatis 的 SQL 日志转换为可执行的 SQL 语句，极大地方便了开发和调试工作。希望这个工具能对你有所帮助！\n","date":"2025-02-19T21:52:49+08:00","permalink":"https://zg-dd.github.io/blog/mybatis-sql-log-parser/","title":"MyBatis SQL 日志解析脚本"},{"content":" 在Java项目中，PO（Plain Old Java Object）对象遍布各个角落，且常常伴随着大量的日志记录需求。传统的做法是通过toString方法直接打印这些对象，然而这种方式输出的日志信息往往不够结构化，给日志排查带来了诸多不便。为了提升日志的可读性和可维护性，我们引入了一款高效工具，该工具能够将项目中约90%的日常PO对象日志自动转换为结构化的JSON格式数据。这一转变极大地简化了系统运维人员的工作，使他们能够更迅速、更准确地定位和解决问题。\n1. 解决的问题\r示例 1：简单对象\n输入：User(id=1, name=\u0026quot;Alice\u0026quot;, age=25)\n输出：{\u0026quot;User\u0026quot;: {\u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Alice\u0026quot;, \u0026quot;age\u0026quot;: 25}} 示例 2：嵌套对象\n输入：Order(id=1001, items=[Item(id=2001, name=\u0026quot;Book\u0026quot;)])\n输出：{\u0026quot;Order\u0026quot;: {\u0026quot;id\u0026quot;: 1001, \u0026quot;items\u0026quot;: [{\u0026quot;Item\u0026quot;: {\u0026quot;id\u0026quot;: 2001, \u0026quot;name\u0026quot;: \u0026quot;Book\u0026quot;}}]}}\n示例 3：复杂 Map\n输入：Config(settings={key1=\u0026quot;value1\u0026quot;, key2=[1, 2, 3]})\n输出：{\u0026quot;Config\u0026quot;: {\u0026quot;settings\u0026quot;: {\u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: [1, 2, 3]}}} 示例4：自定义复杂对象\n输入：User(username=张三, password=123456, students=[Student(name=李四, age=18, score=0.0, courses=null), Student(name=王五, age=20, score=0.0, courses=[数学, 英语, 物理])], map={aa=123, bb=456, cc=你好})\n输出：{\r\u0026quot;User\u0026quot;: {\r\u0026quot;username\u0026quot;: \u0026quot;张三\u0026quot;,\r\u0026quot;password\u0026quot;: 123456,\r\u0026quot;students\u0026quot;: [\r{\r\u0026quot;Student\u0026quot;: {\r\u0026quot;name\u0026quot;: \u0026quot;李四\u0026quot;,\r\u0026quot;age\u0026quot;: 18,\r\u0026quot;score\u0026quot;: 0.0,\r\u0026quot;courses\u0026quot;: null\r}\r},\r{\r\u0026quot;Student\u0026quot;: {\r\u0026quot;name\u0026quot;: \u0026quot;王五\u0026quot;,\r\u0026quot;age\u0026quot;: 20,\r\u0026quot;score\u0026quot;: 0.0,\r\u0026quot;courses\u0026quot;: [\r\u0026quot;数学\u0026quot;,\r\u0026quot;英语\u0026quot;,\r\u0026quot;物理\u0026quot;\r]\r}\r}\r],\r\u0026quot;map\u0026quot;: {\r\u0026quot;aa\u0026quot;: 123,\r\u0026quot;bb\u0026quot;: 456,\r\u0026quot;cc\u0026quot;: \u0026quot;你好\u0026quot;\r}\r}\r} 2. 下载地址\r下载脚本\n","date":"2025-02-19T21:48:01+08:00","permalink":"https://zg-dd.github.io/blog/java-pojo-log-json/","title":"Java PO 日志 JSON 化工具"},{"content":"1. 闭包\r1.1 闭包的定义\r闭包函数（Closure）是函数式编程中的一个重要概念。在Go语言中，闭包函数是指一个函数与其引用的环境的组合。闭包函数可以访问并修改其外部函数中的变量，即使外部函数已经执行完毕。\n1.2 闭包的特点\r闭包函数可以访问其外部函数的局部变量。 闭包函数可以修改其外部函数的局部变量。 闭包函数可以保持其外部函数的局部变量在函数执行完毕后仍然存在。 1.3 闭包的示例\rpackage main import \u0026#34;fmt\u0026#34; /** * 闭包 * 一个函数和与其相关的引用环境组合而成的实体 */ func adder() func(int) int { sum := 0 // 返回一个函数，函数引用了sum变量 return func(x int) int { // 函数引用了sum变量 sum += x return sum } } func main() { // 调用adder函数，返回一个函数，这个函数引用了sum变量 pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { // 调用返回的函数，函数引用了sum变量 fmt.Println(pos(i), neg(-2*i)) } /** - `adder` 函数返回一个闭包。每个闭包都绑定了自己的 `sum` 变量。 - `pos` 和 `neg` 是两个独立的闭包，它们各自维护自己的 `sum`。 运行结果 0 0 1 -2 3 -6 6 -12 10 -20 15 -30 21 -42 28 -56 36 -72 45 -90 */ } 2. 类型(type)\r2.1 自定义类型\rGo 允许使用 type 关键字定义新的类型。\n2.2 类型示例\rpackage main import \u0026#34;fmt\u0026#34; // 自定义一个函数类型，类型名：addFun type addFun func(int) int // 自定义一个int类型，类型名：selfint type selfint int func adder2(x int) addFun { return func(y int) int { return x + y } } func main() { // 定义一个eg函数，其类型为addFun，是一个函数类型 var eg addFun = adder2(10) // 调用eg函数 ,eg函数是adder2函数的返回闭包函数，执行eg ==\u0026gt; adder2(10) + y ==\u0026gt; 10 + 15 = 25 fmt.Println(eg(15)) var num1 selfint = 10 var num2 int = 20 // 自定义类型selfint，不能直接与int类型进行运算，需要转换 fmt.Println(num1 + selfint(num2)) // 或者使用类型转换 fmt.Println(int(num1) + num2) /** * 运行结果： * 25 * 30 * 30 */ } 3. 延迟执行（Defer）\r3.1 defer 的用法\rdefer 语句会将其后面的函数调用推迟到外层函数返回之后执行。\n3.2 defer 示例\rpackage main import \u0026#34;fmt\u0026#34; func main() { // defer 是一个关键字，用于延迟执行一个函数调用，直到包含该 defer 语句的函数执行完毕。 defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) /* * 运行结果： * hello * world */ } 4. 恐慌（Panic）和恢复（Recover）\rPanic相当与抛出异常，Recover相当于捕获异常，Golang中没有try..catch\n4.1 panic 和 recover 的用法\rpanic 用于表示程序遇到了无法处理的错误。 recover 用于从 panic 中恢复。 4.2 panic 和 recover 示例\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 定义一个延时函数并执行 defer func() { // 延时函数，等待主线程执行结束，捕获panic if r := recover(); r != nil { // 打印panic信息 fmt.Println(\u0026#34;Recovered from\u0026#34;, r) } }() // 执行语句 Starting the program fmt.Println(\u0026#34;Starting the program\u0026#34;) // 触发panic 相当于触发java的throw new Exception() panic(\u0026#34;Something went wrong!\u0026#34;) // 下面语句不会被执行 fmt.Println(\u0026#34;This line will not be executed\u0026#34;) /* * 运行结果： * - `panic` 触发了一个恐慌，程序会中止执行。 - `recover` 捕获了恐慌，程序继续执行。 * Starting the program * Recovered from Something went wrong! */ } 5. time包\rtime包是Go语言标准库中提供的一个用于处理时间的包，它提供了时间相关的函数和数据类型，可以用于获取当前时间、格式化时间、解析时间等操作。 time包中的Now函数可以获取当前时间，它返回一个Time类型的值，表示当前时间。下面是一个简单的示例：\n// 1. 获取当前时间 currentTime := time.Now() fmt.Println(\u0026#34;当前时间：\u0026#34;, currentTime) // 2. 获取当前时间的年、月、日、时、分、秒等信息 year := currentTime.Year() month := currentTime.Month() day := currentTime.Day() hour := currentTime.Hour() minute := currentTime.Minute() second := currentTime.Second() fmt.Printf(\u0026#34;当前时间：%d年%d月%d日 %d时%d分%d秒\\n\u0026#34;, year, month, day, hour, minute, second) // 3. 格式化时间 // time包提供了Format函数用于格式化时间，它接受一个格式字符串作为参数，返回一个字符串表示格式化后的时间。下面是一个简单的示例： fmt.Println(\u0026#34;格式化时间：\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) // 4. 解析时间 // time包提供了Parse函数用于解析时间，它接受一个格式字符串和一个时间字符串作为参数，返回一个Time类型的值表示解析后的时间。下面是一个简单的示例： timeStr := \u0026#34;2023-01-01 12:00:00\u0026#34; parsedTime, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err != nil { fmt.Println(\u0026#34;解析时间失败：\u0026#34;, err) return } fmt.Println(\u0026#34;解析时间：\u0026#34;, parsedTime) // 5. 时间间隔 // time包提供了Duration类型表示时间间隔，它表示两个时间点之间的时间差。下面是一个简单的示例： duration := time.Duration(10) * time.Second fmt.Println(\u0026#34;时间间隔：\u0026#34;, duration) // 6. 时间操作 // time包提供了Add函数用于将时间间隔添加到时间上，返回一个新的时间。下面是一个简单的示例： newTime := currentTime.Add(duration) fmt.Println(\u0026#34;新时间：\u0026#34;, newTime) // 7. 时间比较 // time包提供了Before、After和Equal函数用于比较两个时间的大小关系。下面是一个简单的示例： if currentTime.Before(parsedTime) { fmt.Println(\u0026#34;当前时间在解析时间之前\u0026#34;) } else if currentTime.After(parsedTime) { fmt.Println(\u0026#34;当前时间在解析时间之后\u0026#34;) } else { fmt.Println(\u0026#34;当前时间与解析时间相等\u0026#34;) } if currentTime.Equal(parsedTime) { fmt.Println(\u0026#34;当前时间与解析时间相等\u0026#34;) } /** * 以上运行结果： * 当前时间： 2023-10-13 10:18:00.0000007 +0800 CST m=+0.000014679 * 当前时间： 2023年10月13日 10时18分0秒 * 格式化时间： 2023-10-13 10:18:00 * 解析时间： 2023-01-01 12:00:00 +0000 UTC * 时间间隔： 10s * 新时间： 2023-10-13 10:28:00.0000007 +0800 CST m=+10.000014679 * 当前时间在解析时间之前 * 当前时间与解析时间不相等 */ 总结：\n获取当前时间：\ttime.Now() 获取时间的详细信息： currentTime.Year() | currentTime.Month() | currentTime.Day() | currentTime.Hour() | currentTime.Minute() | currentTime.Second() 格式化时间： currentTime.Format(\u0026ldquo;2006-01-02 15:04:05\u0026rdquo;) 解析时间： time.Parse(\u0026ldquo;2006-01-02 15:04:05\u0026rdquo;, timeStr) 时间间隔： time.Duration(10) * time.Second 时间操作： currentTime.Add(duration) 时间比较： currentTime.Before(parsedTime) | currentTime.After(parsedTime) | currentTime.Equal(parsedTime) ","date":"2025-02-13T17:45:37+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-07/","title":"Golang学习历程【第七篇 闭包\u0026type defer panic recover了解\u0026time包】"},{"content":"1. Map数据类型\rMap结构是键值对的集合，其中每个键都是唯一的，并且每个键都映射到一个值。 Map是无序的，即元素的顺序是不确定的。 Map的初始值是nil，不能直接使用，需要使用make函数来创建一个Map。 Map结构为引用数据类型\n1.1. Map声明和初始化\r// Map的声明,其中keyType是键的类型，valueType是值的类型 // 1. 先声明 var 变量名 map[keyType]valueType var map1 map[string]int // 2. 使用make函数来创建一个Map map1 = make(map[string]int) map1[\u0026#34;a\u0026#34;] = 1 map1[\u0026#34;b\u0026#34;] = 2 map1[\u0026#34;c\u0026#34;] = 3 // 2. 声明即创建 ,并赋值 var 变量名 = make(map[keyType]valueType) var map2 = make(map[string]int) map2[\u0026#34;a\u0026#34;] = 4 map2[\u0026#34;b\u0026#34;] = 5 map2[\u0026#34;c\u0026#34;] = 6 // 3. 简短声明 变量名 := map[keyType]valueType map3 := map[string]int{} map3[\u0026#34;a\u0026#34;] = 7 map3[\u0026#34;b\u0026#34;] = 8 map3[\u0026#34;c\u0026#34;] = 9 // 4. 声明即创建,并赋值 var map4 = map[string]int{\u0026#34;a\u0026#34;: 10, \u0026#34;b\u0026#34;: 11, \u0026#34;c\u0026#34;: 12} // 5. 简短声明,并赋值 map5 := map[string]int{\u0026#34;a\u0026#34;: 13, \u0026#34;b\u0026#34;: 14, \u0026#34;c\u0026#34;: 15} // 6. 声明一个map和定义一个map,其值的区别 var map6 map[string]int var map7 = map[string]int{} fmt.Printf(\u0026#34;map1 类型：%T 值：%v map1 是否为 nil %v \\n\u0026#34;, map1, map1, map1 == nil) fmt.Printf(\u0026#34;map2 类型：%T 值：%v map2 是否为 nil %v \\n\u0026#34;, map2, map2, map2 == nil) fmt.Printf(\u0026#34;map3 类型：%T 值：%v map3 是否为 nil %v \\n\u0026#34;, map3, map3, map3 == nil) fmt.Printf(\u0026#34;map4 类型：%T 值：%v map4 是否为 nil %v \\n\u0026#34;, map4, map4, map4 == nil) fmt.Printf(\u0026#34;map5 类型：%T 值：%v map5 是否为 nil %v \\n\u0026#34;, map5, map5, map5 == nil) fmt.Printf(\u0026#34;map6 类型：%T 值：%v map6 是否为 nil %v \\n\u0026#34;, map6, map6, map6 == nil) // map6 是 nil，不能使用，因为仅做了声明，没有初始化 fmt.Printf(\u0026#34;map7 类型：%T 值：%v map7 是否为 nil %v \\n\u0026#34;, map7, map7, map7 == nil) // map7 是一个空的map，可以正常使用 /** * Map获取长度函数 len()，结果为键值对个数 */ map8 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;, } fmt.Println(len(map1)) /** * 以上运行结果 * map1 类型：map[string]int 值：map[a:1 b:2 c:3] map1 是否为 nil false * map2 类型：map[string]int 值：map[a:4 b:5 c:6] map2 是否为 nil false * map3 类型：map[string]int 值：map[a:7 b:8 c:9] map3 是否为 nil false * map4 类型：map[string]int 值：map[a:10 b:11 c:12] map4 是否为 nil false * map5 类型：map[string]int 值：map[a:13 b:14 c:15] map5 是否为 nil false * map6 类型：map[string]int 值：\u0026lt;nil\u0026gt; map6 是否为 nil true * map7 类型：map[string]int 值：map[] map7 是否为 nil false * 3 */ 1.2. Map 遍历\r/** * Map的遍历 */ map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;, } // 1. fori遍历方式 fmt.Println(\u0026#34;1. fori遍历方式\u0026#34;) keys := make([]string, 0, len(map1)) for k := range map1 { keys = append(keys, k) } for i := 0; i \u0026lt; len(keys); i++ { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, keys[i], map1[keys[i]]) } // 2. forrange遍历方式 fmt.Println(\u0026#34;2. forrange遍历方式\u0026#34;) for k, v := range map1 { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, k, v) } /** * 结果： * 1. fori遍历方式 * key=one value=java * key=two value=python * key=three value=go * 2. forrange遍历方式 * key=one value=java * key=two value=python * key=three value=go */ 1.3 Map增删改查\rmap1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;, } // map的增删改查 // 增 map1[\u0026#34;four\u0026#34;] = \u0026#34;php\u0026#34; fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) // 删 delete(map1, \u0026#34;one\u0026#34;) fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) // 改 map1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; // 查 value, ok := map1[\u0026#34;two\u0026#34;] // ok为true表示存在,为false表示不存在 if ok { fmt.Println(value) } value1, ok1 := map1[\u0026#34;five\u0026#34;] // ok为true表示存在,为false表示不存在 if ok1 { fmt.Println(value1) } else { fmt.Println(\u0026#34;five不存在\u0026#34;) } /* * 结果 * map1: map[four:php three:go two:python] * map1: map[three:go two:python] * c++ * five不存在 */ 2. function (函数)\r函数是一段可重复使用的代码块，用来完成特定的功能\n函数的特点有下：\n函数的作用：提高代码的复用性，提高代码的可读性，提高代码的维护性 .】函数的返回值：函数的返回值是通过return语句来实现的，return语句可以返回一个值，也可以返回多个值 函数的参数：函数的参数是通过函数的参数列表来实现的，参数列表中的参数可以是任意类型，参数列表中的参数可以是任意个数 函数变量作用域：函数变量作用域是指在函数内部定义的变量，该变量只能在函数内部使用，函数外部无法访问该变量 函数的返回值和参数列表：函数的返回值和参数列表是函数的组成部分，函数的返回值和参数列表是函数的输出和输入，函数的返回值和参数列表是函数的接口，函数的返回值和参数列表是函数的契约 2.1 函数各种定义方式\rpackage main import \u0026#34;fmt\u0026#34; /* * 函数初识 什么是函数：函数是一段可重复使用的代码块，用来完成特定的功能 函数的作用：提高代码的复用性，提高代码的可读性，提高代码的维护性 函数的定义：func 函数名(参数列表) 返回值列表 {函数体} 函数的调用：函数名(参数列表) 函数的返回值：函数的返回值是通过return语句来实现的，return语句可以返回一个值，也可以返回多个值 函数的参数：函数的参数是通过函数的参数列表来实现的，参数列表中的参数可以是任意类型，参数列表中的参数可以是任意个数 函数的返回值和参数列表：函数的返回值和参数列表是函数的组成部分，函数的返回值和参数列表是函数的输出和输入，函数的返回值和参数列表是函数的接口，函数的返回值和参数列表是函数的契约 * */ // 函数定义 // func 函数名(参数列表) 返回值列表 { // 函数体 // } /* * 1. 无参数无返回值 */ func sayHello() { fmt.Println(\u0026#34;hello world\u0026#34;) } /* * 2. 有参数无返回值 * @param name string */ func sayHello2(name string) { fmt.Println(\u0026#34;hello\u0026#34;, name) } /** * 2. 有参数有返回值 * @param a int * @param b int * @return int */ func add(a int, b int) int { return a + b } /* * 3. 省略参数类型，此时a的类型与b的类型保持一致 * @param a int * @param b int * @return int */ func add2(a, b int) int { return a + b } /** * 4. 省略返回值，此时函数的返回值类型为int * @param a int * @param b int * @return int */ func add3(a, b int) (c int) { // c := a + b c = a + b return // return c } /** * 5. 多个返回值 * @param a int * @param b int * @return int 之和 * @return int 之差 */ func add4(a, b int) (int, int) { return a + b, a - b } /** * 6. 命名返回值 * @param a int * @param b int * @return int 之和 * @return int 之差 */ func add5(a, b int) (sum, diff int) { sum = a + b diff = a - b return } /** * 7. 可变参数 * @param a ...int * @return int */ func add6(a ...int) int { sum := 0 for _, v := range a { sum += v } return sum } /** * 8. 函数做形参 * @param a int * @param b int * @param op func(int, int) int 表示参数为一个函数，该函数接收两个int类型的参数，返回一个int类型的值 */ func opreate(a, b int, op func(int, int) int) int { return op(a, b) // 调用函数 } /** * 9. 函数做返回值 * @param a int * @param b int * @return func() string */ func add7(a, b int) func() string { // 内部定义一个函数 f := func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) // 返回一个字符串 } // 这里只是定义函数，没有调用函数，调用函数需要使用f() return f // 返回函数 } /** * 10. 匿名函数 * 解释：匿名函数是没有名字的函数，匿名函数可以赋值给变量，也可以直接调用 * * @param a int 数值1 * @param b int 数值2 * @return func() string 返回类型为一个函数，该函数返回类型为string */ func add8(a, b int) func() string { return func() string { // 匿名函数的定义，没有函数名 return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) // 返回一个字符串 } // 匿名函数的调用 } // main函数 入口函数 func main() { sayHello() sayHello2(\u0026#34;张三\u0026#34;) fmt.Printf(\u0026#34;add %d\\n\u0026#34;, add(1, 2)) fmt.Printf(\u0026#34;add2 %d\\n\u0026#34;, add2(3, 4)) fmt.Printf(\u0026#34;add3 %d\\n\u0026#34;, add3(5, 6)) sum1, diff1 := add4(7, 8) fmt.Printf(\u0026#34;add4 %d %d\\n\u0026#34;, sum1, diff1) sum2, diff2 := add5(9, 10) fmt.Printf(\u0026#34;add5 %d %d\\n\u0026#34;, sum2, diff2) fmt.Printf(\u0026#34;add6 %d\\n\u0026#34;, add6(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(1, 2, add)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(2, 4, func(i1, i2 int) int { // 自定义匿名函数做参数 return i1 * i2 // 返回两个数的乘积 })) fmt.Printf(\u0026#34;add7 %s\\n\u0026#34;, add7(1, 2)()) fmt.Printf(\u0026#34;add8 %s\\n\u0026#34;, add8(3, 4)()) /** * 以上运行结果： * hello world * hello 张三 * add 3 * add2 7 * add3 11 * add4 15 -3 * add5 19 -1 * add6 55 * opreate 3 * opreate 8 * add7 1 + 2 = 3 * add8 3 + 4 = 7 */ } ","date":"2025-02-11T20:05:09+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-06/","title":"Golang学习历程【第六篇 复合数据类型map\u0026函数初识】"},{"content":"1. 数组（Array）\r数组: 一系列固定长度、同一类型数据的集合。数组为值类型\n1.1 数组的定义\rvar 变量名 = [元素个数]\u0026lt;数据类型\u0026gt; // 声明 + 初始化，此时可将[元素个数]替换为[...]，表示初始化任意多个数据 var 变量名 = [元素个数]\u0026lt;数据类型\u0026gt;{} 变量名:= [元素个数]\u0026lt;数据类型\u0026gt;{} 示例：\n// 数组的定义 var arr1 [4]int // len获取数据长度 fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) 结果：\n类型：[4]int; 数组长度：4; 数据：[0 0 0 0] 1.2 初始化数组\r// 数组的定义 var arr1 [4]int // len获取数据长度 fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) /* 数组初始化 */ // 1.方式一 arr1[0] = 1 arr1[3] = 4 fmt.Printf(\u0026#34;方式一: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) // 2. 方式二 var 变量名 = [元素个数]\u0026lt;数据类型\u0026gt;{} var arr2 = [3]float64{1, 2, 4.6} fmt.Printf(\u0026#34;方式二: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr2, len(arr2), arr2) // 3. 方式三 变量名:= [元素个数]\u0026lt;数据类型\u0026gt;{} arr3 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;方式三: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr3, len(arr3), arr3) // 4. 方式四 var 变量名 = [...]\u0026lt;数据类型\u0026gt;{} 或 变量名:= [...]\u0026lt;数据类型\u0026gt;{} arr4 := [...]int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;方式四: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr4, len(arr4), arr4) // 5. 方式五 指定下标索引初始化索引 arr5 := [...]float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;方式五: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr5, len(arr5), arr5) 结果：\n类型：[4]int; 数组长度：4; 数据：[0 0 0 0] 方式一: 类型：[4]int; 数组长度：4; 数据：[1 0 0 4] 方式二: 类型：[3]float64; 数组长度：3; 数据：[1 2 4.6] 方式三: 类型：[3]string; 数组长度：3; 数据：[java Golang Python] 方式四: 类型：[5]int; 数组长度：5; 数据：[2 4 6 7 8] 方式五: 类型：[8]float64; 数组长度：8; 数据：[2 0 3.5 0 0 4.6 0 9] 1.3 数据的循环遍历\r/* 数组的循环遍历 */ arr6 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} // 1. 使用fori循环 fmt.Printf(\u0026#34;fori循环 \u0026#34;) for i := 0; i \u0026lt; len(arr6); i++ { fmt.Printf(\u0026#34;下标%v: 值：%v; \\t\u0026#34;, i, arr6[i]) } fmt.Println() // 2. 使用for range fmt.Printf(\u0026#34;for range循环 \u0026#34;) for index, value := range arr6 { fmt.Printf(\u0026#34;下标%v: 值：%v; \\t\u0026#34;, index, value) } 结果：\nfori循环 下标0: 值：java; 下标1: 值：Golang; 下标2: 值：Python; for range循环 下标0: 值：java; 下标1: 值：Golang; 下标2: 值：Python; 1.4 多维数组\r// 2维数组为例 var 变量名 = [行个数][列个数]数据类型{{}} var arr7 = [3][3]int{ {1, 2, 3}, // 每一行数据 {4, 5, 6}, {7, 8, 9}, } fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr7, len(arr7), arr7) // 可以忽略行的数据个数，列的数据个数不允许忽略 var arr8 = [...][2]string{ {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}, } fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr8, len(arr8), arr8) // 二维数组循环 for i := 0; i \u0026lt; len(arr7); i++ { for j := 0; j \u0026lt; len(arr7[i]); j++ { fmt.Printf(\u0026#34;%v行%v列: 值：%v; \\t\u0026#34;, i+1, j+1, arr7[i][j]) } fmt.Println() } for row, rowValue := range arr8 { for col, value := range rowValue { fmt.Printf(\u0026#34;%v行%v列: 值：%v; \\t\u0026#34;, row+1, col+1, value) } fmt.Println() } 结果：\n类型：[3][3]int; 数组长度：3; 数据：[[1 2 3] [4 5 6] [7 8 9]] 类型：[2][2]string; 数组长度：2; 数据：[[a b] [c d]] 1行1列: 值：1; 1行2列: 值：2; 1行3列: 值：3; 2行1列: 值：4; 2行2列: 值：5; 2行3列: 值：6; 3行1列: 值：7; 3行2列: 值：8; 3行3列: 值：9; 1行1列: 值：a; 1行2列: 值：b; 2行1列: 值：c; 2行2列: 值：d; 2. 切片（Slice）\r切片：基于数组实现的一层封装，可变长度的序列，可自动扩容。切片为引用类型\n2.1 切片声明、初始化\rvar 变量名 = []\u0026lt;数据类型\u0026gt; // 声明 + 初始化 var 变量名 = []\u0026lt;数据类型\u0026gt;{} 变量名:= []\u0026lt;数据类型\u0026gt;{} 示例：\n// 切片的定义 var arr1 []int // len获取数据长度 fmt.Printf(\u0026#34;类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) /* 切片初始化 */ // 1. 方式一 var 变量名 = []\u0026lt;数据类型\u0026gt;{} var arr2 = []float64{1, 2, 4.6} fmt.Printf(\u0026#34;方式一: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr2, len(arr2), arr2) // 2. 方式二 变量名:= []\u0026lt;数据类型\u0026gt;{} arr3 := []string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;方式二: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr3, len(arr3), arr3) // 3. 方式三 var 变量名 = []\u0026lt;数据类型\u0026gt;{} 或 变量名:= []\u0026lt;数据类型\u0026gt;{} arr4 := []int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;方式三: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr4, len(arr4), arr4) // 4. 方式四 指定下标索引初始化索引 arr5 := []float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;方式四: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr5, len(arr5), arr5) // 5. 切片的循环和数组一致，这里不例举 结果：\n类型：[]int; 切片长度：0; 数据：[] 方式一: 类型：[]float64; 切片长度：3; 数据：[1 2 4.6] 方式二: 类型：[]string; 切片长度：3; 数据：[java Golang Python] 方式三: 类型：[]int; 切片长度：5; 数据：[2 4 6 7 8] 方式四: 类型：[]float64; 切片长度：8; 数据：[2 0 3.5 0 0 4.6 0 9] 2.2 基于数组创建切片\r示例：\n// 基于数组定义切片 var arr1 = [5]int{10, 29, 49, 58, 32} fmt.Printf(\u0026#34;类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) // 1. 切片获取，arr1[:]获取arr1中所有的数据 s1 := arr1[:] // 切片数据类型为[]int,数组数据类型为[5]int fmt.Printf(\u0026#34;获取所有数据--类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, s1, len(s1), s1) // 2. 切片获取，arr1[2:]获取arr1中从下标为2开始之后所有的数据【包含下标2】 s2 := arr1[2:] fmt.Printf(\u0026#34;获取下标为2开始之后所有的数据--类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, s1, len(s2), s2) // 3. 切片获取，arr1[:2]获取arr1中从下标为2之前所有的数据【不包含下标2】 s3 := arr1[:2] fmt.Printf(\u0026#34;获取下标为2之前所有的数据--类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, s3, len(s3), s3) 结果：\n类型：[5]int; 长度：5; 数据：[10 29 49 58 32] 获取所有数据--类型：[]int; 长度：5; 数据：[10 29 49 58 32] 获取下标为2开始之后所有的数据--类型：[]int; 长度：3; 数据：[49 58 32] 获取下标为2之前所有的数据--类型：[]int; 长度：2; 数据：[10 29] 总结：数据的拆分：arr[start:end] 中，含义为：获取arr对应下标区间[start,end)的值，start,end可省略，表示其前或后的所有值。\n2.2 切片的长度(len)和容量(cap)*\r切片拥有自己的长度和容量： 长度：切片的长度是切片所包含的元素个数。用**len()函数获取 容量：切片的容量从他第一个元素开始，到底层数组元素末尾的个数。用cap()**函数获取\na := []int{2, 3, 4, 5, 6, 7} fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, a, len(a), cap(a), a) b := a[3:] fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, b, len(b), cap(b), b) c := a[:3] fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, c, len(c), cap(c), c) 结果：\n类型：[]int, 长度：6, 容量：6, 数据：[2 3 4 5 6 7] 类型：[]int, 长度：3, 容量：3, 数据：[5 6 7] 类型：[]int, 长度：3, 容量：6, 数据：[2 3 4] 3. nil值\rnil是一个预先声明的标识符，表示指针、通道、函数、接口、集合或切片类型的零值。\n数据类型 声明默认值 bool int,float 0 string \u0026quot;\u0026quot; 指针（pointers） nil 数组（array） 基本类型默认值的数组 切片（slices） nil 集合（maps） nil 通道（channels） nil 函数（function） nil // 数组默认值 var arr [3]int fmt.Println(arr) // 切片默认值 var slices1 []int var slices2 = []int{1} fmt.Println(slices1, slices1 == nil, slices2 == nil) 结果：\n[0 0 0] [] true false 4. 值类型和引用数据类型\r值类型: 值类型赋值的两个变量为独立个体，A变化不会引起B的同步更新 引用数据类型：引用数据类型赋值的两个变量为引用同一个变量，A变化会引起B的变化。实际上是因为指向同一片内存空间。典型的示例即：切片 示例：\na1 := [...]int{2, 3, 4, 5} // 数组 值复制 a2 := []int{2, 3, 4, 5} // 切片 引用赋值 b1 := a1 // 赋值给b1 b2 := a2 // 赋值给b2 b1[0] = 6 // 同样修改第一个元素值为6 b2[0] = 6 // 同样修改第一个元素值为6 fmt.Printf(\u0026#34;a1=%v,b1=%v \\n\u0026#34;, a1, b1) // 值类型赋值：b1的修改不会影响a1 fmt.Printf(\u0026#34;a2=%v,b2=%v \\n\u0026#34;, a2, b2) // 引用类型赋值：b2的修改影响了a2 结果：\na1=[2 3 4 5],b1=[6 3 4 5] a2=[6 3 4 5],b2=[6 3 4 5] 5. 切片常用函数\r5.1 创建切片：make\rmake创建切片，make([]int, 10, 11) 分配一个底层数组大小为10，返回长度为11、容量为10的切片int类型切片\nvar slice1 = make([]int, 10, 11) slice1[2] = 6 slice1[9] = 20 fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice1, len(slice1), cap(slice1), slice1) /* 结果： 类型：[]int, 长度：10, 容量：11, 数据：[0 0 6 0 0 0 0 0 0 20] */ 5.2 扩容切片：append\r切片扩容： append(slice, elem1, elem2)或者append(slice, anotherSlice...)，slice表示需要扩容的切片，elem*表示添加的元素，anotherSlice表示其他切片\n// 切片的扩容不能通过slice[2]下标越界方式，会报错下标越界：index out of range [2] with length 0 var slice2 = make([]int, 0, 0) // 切片中追加一个元素，并返回最终元素 slice2 = append(slice2, 12, 14, 24) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice2), cap(slice2), slice2) slice3 := []int{3, 4, 5} // 切片的合并，slice3...代表slice3中所有的元素列举 var slice4 = append(slice2, slice3...) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice4), cap(slice4), slice4) /* 结果： 类型：[]int, 长度：3, 容量：3, 数据：[12 14 24] 类型：[]int, 长度：6, 容量：6, 数据：[12 14 24 3 4 5] */ 5.3 复制切片【深克隆】：copy\r深克隆：指的是克隆前后的对象为两个独立的个体，后续修改变更互不影响 浅克隆：指的是克隆前后的对象为同一个引用类型，后续修改A同样影响B的值 copy(dst, src []Type)，dst是destination，表示目的变量，src是source，表示对象源，即将src复制给dst\n// 切片的扩容不能通过slice[2]下标越界方式，会报错下标越界：index out of range [2] with length 0 var slice2 = make([]int, 0, 0) // 切片中追加一个元素，并返回最终元素 slice2 = append(slice2, 12, 14, 24) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice2), cap(slice2), slice2) slice3 := []int{3, 4, 5} // 切片的合并，slice3...代表slice3中所有的元素列举 var slice4 = append(slice2, slice3...) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice4), cap(slice4), slice4) // 切片的复制深克隆 slice4Copy := make([]int, len(slice4)) copy(slice4Copy, slice4) slice4Copy[0] = 6666 fmt.Println(slice4, slice4Copy) /* 结果： 类型：[]int, 长度：3, 容量：3, 数据：[12 14 24] 类型：[]int, 长度：6, 容量：6, 数据：[12 14 24 3 4 5] [12 14 24 3 4 5] [6666 14 24 3 4 5] */ 5.4 切片的删除\rGo语言中没有内置删除切片方法，可以使用append方法，与切片再切片结合实现\n// 切片的删除 s1 := []int{1, 2, 3, 4, 5, 6} // 删除元素的索引下标 delIndx := 3 // 通过切片append方法，与切片再切片结合实现，即截取[0,3)和[4,5]的切片数据再合并达到删除效果 s1 = append(s1[:delIndx], s1[delIndx+1:]...) fmt.Println(s1) /* 结果： [1 2 3 5 6] */ 5.5 sort排序\r5.5.1 升序排序\r使用sort.Ints、sort.Float64s、sort.Strings进行排序\nintList := []int{3, 4, 32, 32, 423, 12} float64List := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} // 升序排序 sort.Ints(intList) sort.Float64s(float64List) sort.Strings(stringList) fmt.Println(intList) fmt.Println(float64List) fmt.Println(stringList) /* 结果： [3 4 12 32 32 423] [1.1 3.13 4.2 5.3] [A C D S] */ 5.5.2 降序排序\r结合sort.XXXSlice、sort.Reverse和sort.Sort实现\nintList := []int{3, 4, 32, 32, 423, 12} float64List := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} /* 降序排序 1. sort.IntSlice(intList)表示对intList转成interface，简单理解为将切片转为排序器接口,返回结果类型：data sort.Interface 2. sort.Reverse(data sort.Interface)表示翻转切片，返回结果类型：data sort.Interface 3. sort.Sort(data sort.Interface) 表示将结果排序返回数据 默认当做固定写法：sort.Sort(sort.Reverse(sort.XXXSlice(intList))) 另外也可以自定义排序算法实现降序排序 */ sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(float64List))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Println(intList) fmt.Println(float64List) fmt.Println(stringList) /* 结果: [423 32 32 12 4 3] [5.3 4.2 3.13 1.1] [S D C A] */ 6. 扩展技巧\r6.1 语法提示\r对一个变量输入“.”符号时，编译器自动提示语法命令，后缀携带!的表示为功能快捷提示，并生成对应的半成品代码\n截图中提示语功能\n功能提示语句 含义 append! 切片追加数据 copy! copy克隆切片 for! fori循环 forr! for range循环 ifnotnil! if not nil 条件判断 last! 等价于a[len(a -1)]获取最后一个元素 len! 等价于len(a)获取长度 print! 打印变量 range! 等价于forr! reverse! 翻转切片 sort! 自定定排序 var! 将a赋值于新的变量 6.2 方法参数、含义使用探究\r鼠标移动至方法名1s以上，显示方法名参数、返回值，含义，描述详情等信息 用ctrl按键+鼠标左键，点击方法名，即可进入方法名参数、返回值，含义，描述详情等信息，如果不懂英文，可以通过翻译工具认识逐步了解学习 ","date":"2025-01-08T22:05:33+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-05/","title":"Golang学习历程【第五篇 复合数据类型：数组\u0026切片】"},{"content":"1. 运算符\r1.1 算术运算符\r符号 描述 + 加法 - 减法 * 乘法 / 除法 % 取余 示例：\n/* 1. 算术运算符 */ num1 := 5 num2 := 3 fmt.Printf(\u0026#34;%v + %v = %v\\n\u0026#34;, num1, num2, num1+num2) // 加法运算 fmt.Printf(\u0026#34;%v - %v = %v\\n\u0026#34;, num1, num2, num1-num2) // 减法运算 fmt.Printf(\u0026#34;%v * %v = %v\\n\u0026#34;, num1, num2, num1*num2) // 乘法运算 fmt.Printf(\u0026#34;%v / %v = %v\\n\u0026#34;, num1, num2, num1/num2) // 除法运算：除法运算，取整数部分，float类型运算取全部值 // %% 转义，输出% fmt.Printf(\u0026#34;%v %% %v = %v\\n\u0026#34;, num1, num2, num1%num2) // 取余运算：取余数 /* Go中自增，自减运算为语句，不属于运算符，不能赋值，这一点不同于其他语言 ++ 自增 -- 自减 */ num2++ fmt.Printf(\u0026#34;num2自增后：%v \\n\u0026#34;, num2) num2-- fmt.Printf(\u0026#34;num2自减后：%v \\n\u0026#34;, num2) 结果：\n5 + 3 = 8 5 - 3 = 2 5 * 3 = 15 5 / 3 = 1 5 % 3 = 2 num2自增后：4 num2自减后：3 1.2 关系运算符\r符号 描述 == 等于 != 不等于 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 示例：\n/* 2. 关系运算符 */ num3, num4 := 8, 6 fmt.Printf(\u0026#34;%v == %v = %v\\n\u0026#34;, num3, num4, num3 == num4) // false fmt.Printf(\u0026#34;%v != %v = %v\\n\u0026#34;, num3, num4, num3 != num4) // true fmt.Printf(\u0026#34;%v \u0026gt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt; num4) // true fmt.Printf(\u0026#34;%v \u0026gt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt;= num4) // true fmt.Printf(\u0026#34;%v \u0026lt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt; num4) // false fmt.Printf(\u0026#34;%v \u0026lt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt;= num4) // false 结果：\n8 == 6 = false 8 != 6 = true 8 \u0026gt; 6 = true 8 \u0026gt;= 6 = true 8 \u0026lt; 6 = false 8 \u0026lt;= 6 = false 1.3 逻辑运算符\r符号 描述 \u0026amp;\u0026amp; 逻辑与 || 逻辑或 ! 取非 示例：\n/* 3. 逻辑运算符 \u0026amp;\u0026amp;: 真 \u0026amp;\u0026amp; 假 = false 假 \u0026amp;\u0026amp; 真 = false 假 \u0026amp;\u0026amp; 假 = false 真 \u0026amp;\u0026amp; 真 = true ||: 真 || 假 = true 假 || 真 = true 真 || 真 = true 假 || 假 = false !: !真 = false !假 = true */ num5, num6 := 16, 20 fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 \u0026lt; 20) // false fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026lt; 15 \u0026amp;\u0026amp; num6 == 20) // false fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 == 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 || num6 \u0026lt; 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026lt; 15 || num6 == 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 || num6 == 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026lt; 15 || num6 \u0026gt; 20) // false fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, !(num5 \u0026lt; 15)) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, !(num6 == 20)) // false 结果：\n值 = false 值 = false 值 = true 值 = true 值 = true 值 = true 值 = false 值 = true 值 = false 1.4 赋值运算符\r符号 描述 = 赋值，表达式右变赋值给左边 += 先加后赋值 -= 先减后赋值 *= 先乘后赋值 /= 先除后赋值 %= 先取余后赋值 \u0026laquo;= 先左移后赋值(高级用法) \u0026raquo;= 先右移后赋值(高级用法) \u0026amp;= 先按位与后赋值(高级用法) |= 先按位或后赋值(高级用法) ^= 先按位异或后赋值(高级用法) 示例：\n/* 1.4 赋值运算符 */ num6, num7 := 3, 6 num7 += num6 // 等价于 num7 := num7 + num6 fmt.Printf(\u0026#34;num7 += num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 -= num6 // 等价于 num7 := num7 - num6 fmt.Printf(\u0026#34;num7 -= num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 *= num6 // 等价于 num7 := num7 * num6 fmt.Printf(\u0026#34;num7 *= num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 /= num6 // 等价于 num7 := num7 / num6 fmt.Printf(\u0026#34;num7 /= num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 %= num6 // 等价于 num7 := num7 % num6 fmt.Printf(\u0026#34;num7 %%= num6 结果为： %v\\n\u0026#34;, num7) 结果：\nnum7 += num6 结果为： 9 num7 -= num6 结果为： 3 num7 *= num6 结果为： 18 num7 /= num6 结果为： 2 num7 %= num6 结果为： 0 高级用法在二进制运算中举例，点击此处跳转\n1.5 其他运算符\r符号 描述 \u0026amp; 返回变量存储地址 * 指针变量 计算机上是通过地址空间存储变量。 地址是指存储变量的内存位置，即变量的地址，一般由16进制数值表示； 指针是指向变量地址的变量； 变量的值：在当前内存空间位置上存储了变量表示的值。\n示例\n/* 1.5 其他运算符 \u0026amp;：用于获取变量的地址值 *: 用户获取地址上存储的值 */ // var p *int num8 := 100 p = \u0026amp;num8 // 将num8的地址赋值于p ,获取指针的值用*p fmt.Printf(\u0026#34;p地址值=%v,p的值=%v\u0026#34;, p, *p) 结果：\np地址值=0xc00000a0d8,p的值=100 2. 二进制运算\r以下所有的操作运算都是以二进制数值操作\n符号 描述 \u0026amp; 按位与 | 按位或 ^ 异或 \u0026laquo; 左移 \u0026raquo; 右移 运算逻辑：\np q p\u0026amp;q p|q p^q 0 0 0 0 0 1 0 0 1 1 0 1 0 1 1 1 1 1 1 0 \u0026amp;运算：运算两边全为1时值为1，其余位0 |运算：运算两边全为0时值为0，其余为1 ^运算：运算两边数值不同为1，相同为0 \u0026laquo;运算：例如 p\u0026laquo;q ，p的二进制值左移q位。右边空位补0 \u0026gt;\u0026gt;运算：例如 p\u0026raquo;q ，p的二进制值右移q位。删除左边空位0 二进制运算在操作地址运算，IP运算等偏向于硬件有着效率高，运算快的特点\n示例：\n/* 1.6 二进制运算 \u0026amp;运算：运算两边全为1时值为1，其余位0 |运算：运算两边全为0时值为0，其余为1 ^运算：运算两边数值不同为1，相同为0 \u0026lt;\u0026lt;运算：例如 p\u0026lt;\u0026lt;q ，p的二进制值左移q位。右边空位补0 \u0026gt;\u0026gt;运算：例如 p\u0026gt;\u0026gt;q ，p的二进制值右移q位。删除左边空位0 */ var num1 = 0b101011 var num2 = 0b110001 fmt.Printf(\u0026#34;%b \u0026amp; %b = %b \\n\u0026#34;, num1, num2, num1\u0026amp;num2) fmt.Printf(\u0026#34;%b | %b = %b \\n\u0026#34;, num1, num2, num1|num2) fmt.Printf(\u0026#34;%b ^ %b = %b \\n\u0026#34;, num1, num2, num1^num2) fmt.Printf(\u0026#34;%b \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, num1, 2, num1\u0026lt;\u0026lt;2) fmt.Printf(\u0026#34;%b \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, num2, 2, num2\u0026gt;\u0026gt;2) // 使用高级赋值运算符计算 num2 = 0b110001 // 初始化 num2 \u0026amp;= num1 fmt.Printf(\u0026#34;用\u0026amp;= 计算：%b \u0026amp; 110001 = %b \\n\u0026#34;, num1, num2) num2 = 0b110001 // 初始化 num2 |= num1 fmt.Printf(\u0026#34;用|= 计算：%b | 110001 = %b \\n\u0026#34;, num1, num2) num2 = 0b110001 // 初始化 num2 ^= num1 fmt.Printf(\u0026#34;用^= 计算：%b ^ 110001 = %b \\n\u0026#34;, num1, num2) num1 = 0b110001 // 初始化 num1 \u0026lt;\u0026lt;= 2 fmt.Printf(\u0026#34;用\u0026lt;\u0026lt;= 计算：110001 \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, 2, num1) num2 = 0b110001 // 初始化 num2 \u0026gt;\u0026gt;= 2 fmt.Printf(\u0026#34;用\u0026gt;\u0026gt;= 计算：110001 \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, 2, num2) 结果：\n101011 \u0026amp; 110001 = 100001 101011 | 110001 = 111011 101011 ^ 110001 = 11010 101011 \u0026lt;\u0026lt; 2 = 10101100 110001 \u0026gt;\u0026gt; 2 = 1100 用\u0026amp;= 计算：101011 \u0026amp; 110001 = 100001 用|= 计算：101011 | 110001 = 111011 用^= 计算：101011 ^ 110001 = 11010 用\u0026lt;\u0026lt;= 计算：110001 \u0026lt;\u0026lt; 2 = 11000100 用\u0026gt;\u0026gt;= 计算：110001 \u0026gt;\u0026gt; 2 = 1100 \u0026amp;和|妙用\n例：假设，用5位二进制表示座位的空闲和占用，那么全部空闲为：00000，全部占用为：11111。那么有两种场景：1. 指定第1,3,5为空闲状态；2.指定第2,4座位为占用状态的实现方式如下：\n// 默认座位代表：占用，空闲，空闲，占用，占用 var seat = 0b10011 // 将1,3,5的位置置为空闲0，即目标结果：空闲，空闲，空闲，占用，空闲 var initValue1 = 0b01010 // 解释：不管原值是0或者1，只要initValue1第1,3,5位置为0,\u0026amp;的最终结果都为0，而initValue1第2,4位置为1,保证\u0026amp;结果保留原来的值不变 fmt.Printf(\u0026#34;将1,3,5的位置置为0:%b \\n\u0026#34;, seat\u0026amp;initValue1) // 结果10，即00010，前缀0省略 // 将2,4的位置置为占用1，即目标结果：占用，占用，空闲，占用，占用 var initValue2 = 0b01010 // 解释：不管原值是0或者1，只要initValue2第2,4位置为1,|的最终结果都为1，而initValue1第1,3,5位置为0,保证|结果保留原来的值不变 fmt.Printf(\u0026#34;将2,4的位置置为1:%b \\n\u0026#34;, seat|initValue2) // 结果11011 将1,3,5的位置置为0:10 将2,4的位置置为1:11011 由上述示例可见，使用同一个二进制01010值，就能操作两种不同的场景运算，这在信号灯控制、开关控制等两种取反操作场景中非常适用\n3. 流程控制\r3.1 条件表达式if\r条件判断：按照程序顺序执行，仅可执行满足一个条件的语句内容。\n示例：\n/* 下列格式严格按照书写规范，否则报错 1. 条件判断： if 条件判断1 { } else if 条件判断2 { } else if ... { } else { } */ // 写法1 , 此时score作用于在当前范围作用域 score := 60 if score \u0026gt;= 90 { // \u0026gt;= 90 fmt.Println(\u0026#34;成绩卓越\u0026#34;) } else if score \u0026gt;= 80 { // \u0026gt;= 80 \u0026amp;\u0026amp; \u0026lt; 90 fmt.Println(\u0026#34;成绩优秀\u0026#34;) } else if score \u0026gt;= 70 { // \u0026gt;= 70 \u0026amp;\u0026amp; \u0026lt; 80 fmt.Println(\u0026#34;成绩良好\u0026#34;) } else if score \u0026gt;= 60 { // \u0026gt;= 60 \u0026amp;\u0026amp; \u0026lt; 70 fmt.Println(\u0026#34;成绩合格\u0026#34;) } else { // \u0026lt; 60 fmt.Println(\u0026#34;成绩不合格\u0026#34;) } // 写法2： 此时score1作用于在当前if内部作用域 if score1 := 80; score1 \u0026gt;= 90 { // \u0026gt;= 90 fmt.Println(\u0026#34;成绩卓越\u0026#34;) } else if score1 \u0026gt;= 80 { // \u0026gt;= 80 \u0026amp;\u0026amp; \u0026lt; 90 fmt.Println(\u0026#34;成绩优秀\u0026#34;) } else if score1 \u0026gt;= 70 { // \u0026gt;= 70 \u0026amp;\u0026amp; \u0026lt; 80 fmt.Println(\u0026#34;成绩良好\u0026#34;) } else if score1 \u0026gt;= 60 { // \u0026gt;= 60 \u0026amp;\u0026amp; \u0026lt; 70 fmt.Println(\u0026#34;成绩合格\u0026#34;) } else { // \u0026lt; 60 fmt.Println(\u0026#34;成绩不合格\u0026#34;) } // 此时使用score1会报错 fmt.Println(strconv.Itoa(score)) 结果：\n成绩合格 成绩优秀 80 在这里插入代码片 3.2 for循环\r/* ()内容可以省略 for (初始语句;)(条件表达式;)(结束语句) { 循环体 } 执行顺序： 1. 执行初始语句 2. 条件表达式 3. 循环体 4. 结束语句 5. 条件表达式,判断是否满足条件 6. 如果满足条件为true：第3,4,5步循环执行，直到条件表达式为false结束 */ var str = \u0026#34;hello world\u0026#34; // 写法1 for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) } fmt.Println() // 写法2 i := 0 for i \u0026lt; len(str) { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } fmt.Println() // 写法3 Go中没有while控制语句，该写法可替代 i = 0 for { if i \u0026gt;= len(str) { break } fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } 结果：\nh e l l o w o r l d h e l l o w o r l d h e l l o w o r l d 3.3 for range(键值循环)\r示例：\n/* for ...range 格式 for 键,值 := range 变量{ 循环体 } */ text := \u0026#34;你好,program\u0026#34; for k, v := range text { fmt.Printf(\u0026#34;k=%v,v=%c\\n\u0026#34;, k, v) } 结果：\nk=0,v=你 k=3,v=好 k=6,v=, k=7,v=p k=8,v=r k=9,v=o k=10,v=g k=11,v=r k=12,v=a k=13,v=m 3.4 switch\u0026hellip;case\r与if条件判断类型，switch\u0026hellip;case更多用于判断枚举类型\n/* switch 枚举值{ case 固定值1: (break) case 固定值2: (break) case 固定值3: (break) ... default: } 执行顺序：1. 枚举值 2. case 命中，哪一个case命中，执行哪个case下的语句 */ // 写法1 var week = 3 switch week { case 1: fmt.Println(\u0026#34;周一\u0026#34;) case 2: fmt.Println(\u0026#34;周二\u0026#34;) case 3: fmt.Println(\u0026#34;周三\u0026#34;) case 4: fmt.Println(\u0026#34;周四\u0026#34;) case 5: fmt.Println(\u0026#34;周五\u0026#34;) case 6: fmt.Println(\u0026#34;周六\u0026#34;) case 7: fmt.Println(\u0026#34;周日\u0026#34;) default: fmt.Println(\u0026#34;不存在\u0026#34;) } // 写法2，同样week1仅作用域在switch内部 switch week1 := 0; week1 { case 1: fmt.Println(\u0026#34;周一\u0026#34;) case 2: fmt.Println(\u0026#34;周二\u0026#34;) case 3: fmt.Println(\u0026#34;周三\u0026#34;) case 4: fmt.Println(\u0026#34;周四\u0026#34;) case 5: fmt.Println(\u0026#34;周五\u0026#34;) case 6: fmt.Println(\u0026#34;周六\u0026#34;) case 7: fmt.Println(\u0026#34;周日\u0026#34;) default: fmt.Println(\u0026#34;不存在\u0026#34;) } // 写法3, case 可以写多个枚举值 switch num := 10; num { case 0, 2, 4, 6, 8, 10: fmt.Println(\u0026#34;偶数\u0026#34;) case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;奇数\u0026#34;) } // 写法4，case 中可以写条件表达式 score := 80 switch { case score \u0026gt;= 90: fmt.Println(\u0026#34;卓越\u0026#34;) case score \u0026gt;= 80: fmt.Println(\u0026#34;优秀\u0026#34;) case score \u0026gt;= 70: fmt.Println(\u0026#34;良好\u0026#34;) case score \u0026gt;= 60: fmt.Println(\u0026#34;及格\u0026#34;) default: fmt.Println(\u0026#34;不及格\u0026#34;) } 结果：\n周三 不存在 偶数 优秀 Go语言的switch..case中，break默认存在的，即仅能执行case，不能语句穿透。如果需要语句穿透，可使用fallthrough语句，一次使用仅能穿透一层 例：\nswitch week1 := 5; week1 { case 1: fmt.Println(\u0026#34;周一\u0026#34;) case 2: fmt.Println(\u0026#34;周二\u0026#34;) case 3: fmt.Println(\u0026#34;周三\u0026#34;) case 4: fmt.Println(\u0026#34;周四\u0026#34;) case 5: fmt.Println(\u0026#34;周五\u0026#34;) fallthrough case 6: fmt.Println(\u0026#34;周六\u0026#34;) case 7: fmt.Println(\u0026#34;周日\u0026#34;) default: fmt.Println(\u0026#34;不存在\u0026#34;) } 结果：\n周五 周六 3.5 break,continue,goto\rbreak表示跳出当前循环 continue表示跳过档次循环执行 goto 表示跳至指定语句执行 示例：\nlable1: // 固定写法 \u0026lt;随意标签名\u0026gt;: for i := 0; i \u0026lt;= 3; i++ { if i == 0 { continue // 跳过当次循环 0跳过 } if i == 1 { continue lable1 // 跳至lable1位置 ,1跳过, 继续执行 } fmt.Printf(\u0026#34;i=%d \\n\u0026#34;, i) } lable2: for j := 0; j \u0026lt;= 3; j++ { if j == 3 { fmt.Printf(\u0026#34;跳出 \\n\u0026#34;) break // 3跳出循环 } if j == 1 { break lable2 // 跳至lable2位置, 1跳过，不执行当前循环体 } fmt.Printf(\u0026#34;j=%d \\n\u0026#34;, j) } /* goto可以任意指定标签位置，跳至指定位置执行 解释： 1. 执行语句1, 2. i 自增为1 2. goto跳至lable4，执行语句3 3. goto跳至lable3，执行语句1 4. i 自增为2 5. goto跳至lable5，执行语句4 最终跳过了执行语句2 */ i := 0 lable3: fmt.Println(\u0026#34;执行语句1\u0026#34;) i++ if i == 2 { // 执行2次之后 goto lable5 } goto lable4 fmt.Println(\u0026#34;执行语句2\u0026#34;) // 被跳过 lable4: fmt.Println(\u0026#34;执行语句3\u0026#34;) goto lable3 lable5: fmt.Println(\u0026#34;执行语句4\u0026#34;) 结果：\ni=2 i=3 j=0 执行语句1 执行语句3 执行语句1 执行语句4 ","date":"2025-01-01T11:03:08+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-04/","title":"Golang学习历程【第四篇 运算符\u0026流程控制】"},{"content":"1. 总览\rGo语言中数据类型分为：基本数据类型和复合数据类型\n基本数据类型：整型，浮点型，布尔型，字符串 复合数据类型：数组，切片，结构体，函数，map，通道（channel）、接口等\n2. 基本数据类型\r2.1 整型\r类型 范围 占用空间 有无符号 int8 $-2^7$~$2^7-1$ 1个字节 有 int16 $-2^{15}$~$2^{15}-1$ 2个字节 有 int32 $-2^{31}$~$2^{31}-1$ 4个字节 有 int64 $-2^{63}$~$2^{63}-1$ 8个字节 有 uint8 $0$~$2^8-1$ 1个字节 无 uint16 $0$~$2^{16}-1$ 2个字节 无 uint32 $0$~$2^{32}-1$ 4个字节 无 uint64 $0$~$2^{64}-1$ 8个字节 无 特殊类型：\n类型 描述 uint 32位操作系统上为uint32,64位操作系统上为uint64 int 32位操作系统上为int32,64位操作系统上为int64 uintptr 无符号整型，用于存放一个指针 简单示例：\nvar ( num1 int = 666 num2 uint = 666 // 以下赋值可选最大值，math 为math包，使用即自动引入 num1 int = 666 num2 uint = 666 // 以下赋值可选最大值 num3 int8 = math.MaxInt8 num4 int16 = math.MaxInt16 num5 int32 = math.MaxInt32 num6 int64 = math.MaxInt64 num7 uint8 = math.MaxUint8 num8 uint16 = math.MaxUint16 num9 uint32 = math.MaxUint32 num10 uint64 = math.MaxUint64 ) fmt.Println(num1, num2, num3, num4, num5, num6, num7, num8, num9, num10) 结果：\n666 666 127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615 2.2 浮点型\rGo语言支持两种浮点数：float32和float64，遵循IEEE 745标准。32位操作系统中，默认为float32；64位操作系统中默认为float64。\nfloat32：-3.4e38~3.4e38 ，占用4个字节 float64：-1.8e308~1.8e308，占用8个字节 // 1. 基本定义 var num1 float32 = 1.06 num2 := 3.1415926 // 保留小数据，可以使用%.nf或者%0.nf 指定保留n位小数， fmt.Printf(\u0026#34;原样输出：%v; 默认保留6位小数: %f; 指定保留3为小数: %0.3f \\n\u0026#34;, num1, num2, num2) // 2. 其他常用样例 var ( num3 float32 = 3.1415926 num4 float64 = 1.113 num5 = 3.14e2 // 使用科学计数法表示，3.14*10^2 的值：为314 num6 = 3.14e-2 // 使用科学计数法表示，3.14*10-2 的值：为0.0314 ) fmt.Println(num3, num4, num5, num6) 结果：\n原样输出：1.06; 默认保留6位小数: 3.141593; 指定保留3为小数: 3.142 3.1415925 1.113 314 0.0314 2.2 布尔型\rbool值仅有两个值：true和false。声明不赋值，默认为false\nvar ( bool1 bool bool2 = true ) fmt.Println(bool1, bool2) 结果：\nfalse true 2.3 字符\r字符是单个数值，属于int类型，Go语言中有两种表示：byte和rune\nbyte: int类型，代表ASCII码的值 rune: int类型，代表UTF-8编码 注：UTF-8的国际通用编码，是ASCII码的扩展，包括了各国的常用的语言文字\u0026lt;/font 常用示例：\nvar a = \u0026#39;A\u0026#39; var a = \u0026#39;A\u0026#39; // 使用%c输出字符 fmt.Printf(\u0026#34;字符ASCII值:%v; 原样编码:%c \\n\u0026#34;, a, a) var ( b = \u0026#39;B\u0026#39; c = \u0026#39;你\u0026#39; d = \u0026#34;this\u0026#34; // 可以获取字符串中的单个字符 ) fmt.Printf(\u0026#34;%c,%c,%c,%c,%c,%c\u0026#34;, b, c, d[0], d[1], d[2], d[3]) 结果：\n字符ASCII值:65; 原样编码:A B,你,t,h,i,s 2.4 字符串\r2.4.1 常用定义方式\r// 字符串定义 var val1 string = \u0026#34;hello world\u0026#34; var val2 = \u0026#34;你好 go\u0026#34; val3 := \u0026#34;Good\u0026#34; fmt.Println(val1, val2, val3) // 字符串val2中2个中文，3个英文(空格也算)；共2*3+3=9个字符，可通过len函数获取 fmt.Println(len(val2)) // 多行字符串：会原样输出 var info = `姓名：张三 年龄：18` fmt.Println(info) 结果：\nhello world 你好 go Good 9 姓名：张三 年龄：18 字符串中，英文字母占一个字节，中文占用3个字节。可使用len函数打印字符串字节长度\n2.4.2 转移字符\r转义符号使用\\表示 常用的转义字符有：\n\\r：回车符（返回行首） \\n：换行符（跳至下一行同列） \\t：制表符（可用于整齐输出一系列值） \\'：单引号，输出' \\\u0026quot;：双引号，输出\u0026quot; \\\\：反斜杠，输出\\ var val1 string = \u0026#34;hello\\r\u0026#34; var val2 string = \u0026#34;world\\n\u0026#34; var val3 string = \u0026#34;hello world\\t\u0026#34; var val4 string = \u0026#34;\u0026#39;hello\u0026#39; \\\\ \\\u0026#34;world\\\u0026#34;\u0026#34; /* var1：\\r 回车符，hello输出结束后回车，光标移动至当前行首，意味着清空hello值 val2: \\n 换行符，world输出之后换行 val3: \\t 制表符，hello world简易理解为一个大的空格，格式美观，自带对齐 val4: Go语言中\u0026#39;可以直接写在\u0026#34;内部，\\\\输出\\, \\\u0026#34; 转义字符，输出\u0026#34; */ fmt.Println(val1, val2, val3, val4) 结果：\nworld hello world \u0026#39;hello\u0026#39; \\ \u0026#34;world\u0026#34; 2.4.3 常用方法\r方法名基本上为常用英文名缩写，各语言基本通用，使用多了自然熟记\n方法 描述 len 获取字符串长度 +或fmt.Springf 拼接字符串 strings.Split 拆分字符串 strings.Contains 获取字符串长度 strings.HasPrefix,strings.HasSuffix 获取字符串长度 strings.Index,strings.LastIndex 获取字符串长度 strings.Join 获取字符串长度 strings.ToLower 字符串全转小写 strings.ToUpper 字符串全转大写 示例：\nvar val = \u0026#34;Hello World\u0026#34; // 1. len求长度 length := len(val) fmt.Printf(\u0026#34;%s长度: %d\\n\u0026#34;, val, length) // 2. + 拼接字符串，Sprint中S代表返回字符串，同理含有：Sprinf、Sprinln，与Prinf、Prinln类似，区别在于S开头函数代表返回字符串，可用变量接收 str1 := val + \u0026#34;小明\u0026#34; str2 := fmt.Sprint(val, \u0026#34;小红\u0026#34;) fmt.Printf(\u0026#34;+拼接：%s;\\tSprint函数拼接: %s \\n\u0026#34;, str1, str2) // 3. 字符串拆分结果为：切片（类似于数组）；参数为(\u0026lt;原字符串\u0026gt;, \u0026lt;切片字符串\u0026gt;)，示例中将Hello World以空格拆分为Hello和World splitVal := strings.Split(val, \u0026#34; \u0026#34;) // 切片结果为[Hello World] // 4. Join将切片拼接成新的字符串；参数为(\u0026lt;原字符串\u0026gt;, \u0026lt;连接符\u0026gt;) newStr := strings.Join(splitVal, \u0026#34;,\u0026#34;) // fmt.Printf(\u0026#34;切片值：%v;\\tJoin连接成新的字符串: %s \\n\u0026#34;, splitVal, newStr) // 5.字符串是否包含子串，Contains参数为(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;) bool1 := strings.Contains(val, \u0026#34;Hello\u0026#34;) bool2 := strings.Contains(val, \u0026#34;Hello\u0026#34;) fmt.Printf(\u0026#34;是否包含Hello：%v;\\t是否包含olleH: %v \\n\u0026#34;, bool1, bool2) // 6. 前缀判断：HasPrefix ,参数为(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;); 后缀判断：HasSuffix，参数(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;) bool3 := strings.HasPrefix(val, \u0026#34;He\u0026#34;) bool4 := strings.HasPrefix(val, \u0026#34;llo\u0026#34;) bool5 := strings.HasSuffix(val, \u0026#34;World\u0026#34;) bool6 := strings.HasSuffix(val, \u0026#34;Wor\u0026#34;) fmt.Printf(\u0026#34;前缀包含He：%v;\\t前缀包含llo: %v\\t后缀包含World：%v;\\t后缀包含Wor: %v \\n\u0026#34;, bool3, bool4, bool5, bool6) // 7. 返回子串在原字符串首次出现的位置，Index，从前向后查找；LastIndex，从后向前查找，参数都为(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;)。结果：查询到，返回下标值，查询不到，返回-1。注：下标从0开始 index1 := strings.Index(val, \u0026#34;o\u0026#34;) index2 := strings.LastIndex(val, \u0026#34;o\u0026#34;) index3 := strings.Index(val, \u0026#34;a\u0026#34;) fmt.Printf(\u0026#34;o从前到后查询在第%v位;\\to从后到前查询在第%v位\\ta从前到后查询在第%v位\\n\u0026#34;, index1, index2, index3) // 8. strings.ToLower和strings.ToUpper str3 := strings.ToLower(val) str4 := strings.ToUpper(val) fmt.Printf(\u0026#34;全小写： %v;\\t全大写：%v\\n\u0026#34;, str3, str4) 运行结果\nHello World长度: 11 +拼接：Hello World小明; Sprint函数拼接: Hello World小红 切片值：[Hello World]; Join连接成新的字符串: Hello,World 是否包含Hello：true; 是否包含olleH: true 前缀包含He：true; 前缀包含llo: false 后缀包含World：true; 后缀包含Wor: false o从前到后查询在第4位; o从后到前查询在第7位 a从前到后查询在第-1位 全小写hello world; 全大写HELLO WORLD 温馨提示：这里的len、split、contains、prefix、suffix、index、join、lower、upper等所表示的含义在各个编程语言大同小异，只要通一门语言，其他也就简单了\n2.4.3 字符串中字符替换\r// 字符串中替换字符 var val1 = \u0026#34;hello xioaming\u0026#34; byteStr := []byte(val1) // 英文字符 转成byte数组类型即可，然后替换值 byteStr[0] = \u0026#39;a\u0026#39; fmt.Println(string(byteStr)) // string(byteStr)为将数组转成字符串返回，fmt.Println再打印输出结果 var val2 = \u0026#34;你好小明\u0026#34; runeStr := []rune(val2) // 包含中文字符 需要转成rune数组类型即可，然后替换值 runeStr[0] = \u0026#39;我\u0026#39; fmt.Println(string(runeStr)) 结果：\naello xioaming 我好小明 3. 类型转换\r数字类型装换有两种：低精度转高精度，高精度转低精度 注：高精度转低精度，慎用，由于类型表示范围不同，可能造成精度丢失\n3.1 整型与整型转化\r示例：\n// 进度转换可通过 int8(\u0026lt;整型\u0026gt;),int16(\u0026lt;整型\u0026gt;),int32(\u0026lt;整型\u0026gt;),int64(\u0026lt;整型\u0026gt;)转换 // 1. 低精度转高精度 var a int8 = 127 b := int64(a) fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, a, a, b, b) // 2. 高精度转低精度 var c int64 = 127 d := int16(c) fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, c, c, d, d) 结果：\na=127,类型：int8 b=127,类型：int64 a=127,类型：int64 b=127,类型：int16 3.2 浮点数与整型转换\r示例：\n// 3. 整型转浮点型，可通过 float32(\u0026lt;整型\u0026gt;),float64(\u0026lt;整型\u0026gt;)，浮点数转浮点数据也可以这样操作 var e int16 = 256 f := float32(e) fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, e, e, f, f) // 4. 浮点型转整型 var g float64 = 3.145 h := int16(g) // 注：类型会丢失，不是四舍五入，直接截取整数部分 fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, g, g, h, h) 结果：\na=256,类型：int16 b=256,类型：float32 a=3.145,类型：float64 b=3,类型：int16 3.3 其他类型与string类型转换\rvar ( intV = 123 folatV = 3.145 boolV = true charV = \u0026#39;A\u0026#39; ) // 1. 通过 fmt.Sprintf进行转换 str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, intV) // 转换int str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, folatV) // 转换float str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, boolV) // 转换 bool str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, charV) // 转换 字符 fmt.Println(str1, str2, str3, str4) 结果：\n123 3.145000 true A 3.4 strconv 字符串类型转换工具\r3.4.1 strconv.Atoi(字符串转int) 和 strconv.Itoa(int转字符串)\r简单记忆：i(int) ，itoa中i在首字母，表示int转string。atoi中i在末尾，表示string转int\nvar str = \u0026#34;123\u0026#34; // 1. 将string转换为int类型，strconv.Atoi(\u0026lt;string\u0026gt;)， 返回类型有两个：\u0026lt;转换数据,异常err\u0026gt; num1, _ := strconv.Atoi(str) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, num1, num1) // 2. 将int类型转换为string, strconv.Itoa(\u0026lt;int\u0026gt;),类型必须int，返回类型有一个：\u0026lt;string\u0026gt; var num2 int64 = 456 str2 := strconv.Itoa(int(num2)) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str2, str2) 结果：\n转化值：123 类型：int 转化值：456 类型：string 3.4.2 strconv.Parse 字符串解析为其他类型\rstrconv.Parse能将将字符串解析为指定类型，前提：允许转换\nvar ( str1 = \u0026#34;256\u0026#34; str2 = \u0026#34;3.145\u0026#34; str3 = \u0026#34;true\u0026#34; ) // 以下的bitSize参数感觉意义不大，返回值有特定的返回类型 /* 1. ParseInt params 参数1: string数据 参数2：base 指定进制，取值范围是 2 到 36。如果 base 为 0 参数3：bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64 return int64: 返回始终为int64数值 err: 转换失败后返回的失败信息 */ num1, _ := strconv.ParseInt(str1, 10, 0) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, num1, num1) /* 2. ParseFloat params 参数1: string数据 参数2：bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； return float64: 返回始终为float64数值 err: 转换失败后返回的失败信息 */ num2, _ := strconv.ParseFloat(str2, 32) fmt.Printf(\u0026#34;转化值：%0.3f\\t类型：%T\\n\u0026#34;, num2, num2) /* 3. ParseBool params 参数1: string数据 return bool: 返回始终为bool数值 err: 转换失败后返回的失败信息 */ boo, _ := strconv.ParseBool(str3) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, boo, boo) 结果：\n转化值：256 类型：int64 转化值：3.145 类型：float64 转化值：true 类型：bool 3.4.3 strconv.Format 数字格式化为string\rvar ( intV = 123 floatV = 3.145e2 booV = true ) // 以下的bitSize参数感觉意义不大，返回值有特定的返回类型 /* 1. FormatInt params 参数1: int64数据 参数2：base 指定进制，取值范围是 2 到 36。如果 base 为 0 return string: 返回始终为string数值 */ str1 := strconv.FormatInt(int64(intV), 10) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str1, str1) /* 2. FormatFloat params 参数1: float64数据 参数2：格式化类型 \u0026#39;b\u0026#39; (-ddddp±ddd, 二进制指数), \u0026#39;e\u0026#39; (-d.dddde±dd, 十进制e指数), \u0026#39;E\u0026#39; (-d.ddddE±dd, 十进制E指数), \u0026#39;f\u0026#39; (-ddd.dddd, 无指数), \u0026#39;g\u0026#39; (\u0026#39;e\u0026#39;表示大指数，\u0026#39;f\u0026#39;表示其他指数), \u0026#39;G\u0026#39; (\u0026#39;E\u0026#39;表示大指数，\u0026#39;F\u0026#39;表示其他指数), \u0026#39;x\u0026#39; (-0xd.ddddp±ddd, 十六进制分数和二进制指数 小写), \u0026#39;X\u0026#39; (-0Xd.ddddP±ddd, 十六进制分数和二进制指数 大写). 参数3：保留的小数点位数，四舍五入。-1代表不对小数点格式化处理 参数4：bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； return string: 返回始终为string数值 */ str2 := strconv.FormatFloat(floatV, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str2, str2) /* 3. FormatFloat params 参数1: bool数据 return string: 返回始终为string数值 */ str3 := strconv.FormatBool(booV) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str3, str3) 结果：\n转化值：123 类型：string 转化值：314.5 类型：string 转化值：true 类型：string 3.4.4 其他方法\r其他还包含strconv.Append(字符换追加)、strconv.IsPrint（是否可打印） 和 strconv.IsGraphic（是否图形字符）、strconv.Quote（字符串转义） 和 strconv.Unquote（取出转义）、strconv.CanBackquote（判断是否可以表示为单行反引号字符串）等。 这里学习到这，不做详细示例分析，有印象即可，需要时再学习；可参考链接\n","date":"2024-12-21T19:37:51+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-03/","title":"Golang学习历程【第三篇 基本数据类型\u0026类型转换】"},{"content":" 前言：包是指由官方或者自定义的一系列功能集合体。使用前需要先引入，例如今日所讲的fmt包。引入方式如下： import \u0026quot;fmt\u0026quot;\n1. fmt 包\rfmt 包是一个非常重要且广泛使用的标准库包，它提供了格式化I/O（输入/输出）功能，类似于C语言中的 printf 和 scanf。通过这个包，你可以读取输入并将数据格式化输出到标准输出或其他写入器（writers）\n1.1 打印（print）\r打印功能，简单来说就是系统输出功能，英文简义为Print，驼峰命名，首字母大写，后缀ln换行含义。后缀f表示可格式化打印\n1.1.1 Print 打印\r// package 包声明： 可以理解为一个文件夹 package main // import 导入：一般指导入官方或自定义功能包 import \u0026#34;fmt\u0026#34; // main函数 入口函数 func main() { /** * 打印输出功能 */ fmt.Print(\u0026#39;C\u0026#39;) // 打印字符，单引号，语法灵活易学 fmt.Print(\u0026#34;a\u0026#34;) // 打印字符串 fmt.Print(\u0026#34;Hello World\u0026#34;) // 打印字符串，双引号 fmt.Print(123) // 打印整数 fmt.Print(3.1415926) // 打印小数 fmt.Print(true) // 打印布尔值 } 上述结果：\n67aHello World1233.1415926true 总结：Print仅打印功能，可打印任意类型，细心的朋友可能发现，单引号字符串'C'输出结果为67，单引号代表单个字符，输出的结果是ASCII值，双引号表示打印字符串。如果使用'ABC'。运行结果会报错more than one character in rune literal。中文意思是：符文文字中有多个字符。\n1.1.2 Println 打印后换行\r上述代码如果使用Println 打印，代码如下： 注：以下代码以后只显示关键代码段，main函数不予展示。\nfmt.Println(\u0026#39;C\u0026#39;) // 打印字符，单引号，语法灵活易学 fmt.Println(\u0026#34;a\u0026#34;) // 打印字符串 fmt.Println(\u0026#34;Hello World\u0026#34;,\u0026#34;你好\u0026#34;) // 打印字符串，双引号 fmt.Println(123) // 打印整数 fmt.Println(3.1415926) // 打印小数 fmt.Println(true) // 打印布尔值 效果清晰明了，如下：\n67 a Hello World 你好 123 3.1415926 true 1.1.3 Printf 打印格式化参数\r可指定格式打印。常用格式类型如下：\n格式化符号 描述 重要程度(个人观点) %T 打印变量类型 高 %v 以默认格式输出变量 高 %t 输出 true 或 false 高 %b 二进制表示 高 %c Unicode 对应字符 低 %d 十进制表示 高 %o 八进制表示 高 %x 十六进制表示（小写字母） 高 %X 十六进制表示（大写字母） 低 %U Unicode 格式输出 低 %f 十进制浮点数 高 %e 科学计数法（小写 e） 低 %E 科学计数法（大写 E） 低 %g 自动选择 %f 或 %e 的简洁表示 高 %s 普通字符串 高 %q 带双引号的字符串或字符 低 %p 指针地址 低 示例代码：\nfmt.Printf(\u0026#34;布尔值：%t \\n\u0026#34;, false) // 打印布尔值 fmt.Printf(\u0026#34;Unicode 65对应字符：%c \\n\u0026#34;, 65) // Unicode 对应字符 fmt.Printf(\u0026#34;默认格式65：%v \\n\u0026#34;, 65) // 二进制打印 fmt.Printf(\u0026#34;二进制65：%b \\n\u0026#34;, 65) // 二进制打印 fmt.Printf(\u0026#34;十进制65：%d \\n\u0026#34;, 65) // 十进制打印 fmt.Printf(\u0026#34;八进制65：%o \\n\u0026#34;, 65) // 八进制打印 fmt.Printf(\u0026#34;十六进制1024（小）：%x \\n\u0026#34;, 1024) // 十六进制小写打印 fmt.Printf(\u0026#34;十六进制1024（大）：%X \\n\u0026#34;, 1024) // 十六进制大写打印 fmt.Printf(\u0026#34;\u0026#39;C\u0026#39; Unicode值：%U \\n\u0026#34;, \u0026#39;C\u0026#39;) // Unicode输出 fmt.Printf(\u0026#34;浮点数：%f \\n\u0026#34;, 3.1415926) // 十进制浮点数 fmt.Printf(\u0026#34;科学计数法（小）：%e \\n\u0026#34;, 3.1415926) // 科学计数法（小写 e） fmt.Printf(\u0026#34;科学计数法（大）：%E \\n\u0026#34;, 3.1415926) // 科学计数法（大写 e） 运行结果：\n布尔值：false Unicode 65对应字符：A 默认格式65：65 二进制65：1000001 十进制65：65 八进制65：101 十六进制1024（小）：400 十六进制1024（大）：400 \u0026#39;C\u0026#39; Unicode值：U+0043 浮点数：3.141593 科学计数法（小）：3.141593e+00 科学计数法（大）：3.141593E+00 1.2 输入(Scan)\r输入用Scan表示，后缀f表示格式化输入\n1.2.1 Scan 输入\r示例：\n// 基本变量声明：var \u0026lt;变量名\u0026gt; \u0026lt;类型\u0026gt; var name string // 声明字符串类型 var age int // 声明整数类型 fmt.Print(\u0026#34;请输入姓名和年龄：\u0026#34;) fmt.Scan(\u0026amp;name, \u0026amp;age) // 录入姓名和年龄 fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) // 格式化输出姓名和年龄 运行结果：\n请输入姓名和年龄：张三 18 name=张三,age=18 1.2.2 Scanf 格式化输入\r示例：\n// 基本变量声明：var \u0026lt;变量名\u0026gt; \u0026lt;类型\u0026gt; var name string // 声明字符串类型 var age int // 声明整数类型 fmt.Print(\u0026#34;请输入姓名和年龄：\u0026#34;) fmt.Scanf(\u0026#34;%s %d\u0026#34;, \u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) 运行如下示例，体验到：Go语言灵活多变，适合0基础学习\nPS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 18 name=张三,age=18 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 李四 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 李四 18 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 18 李四 name=张三,age=18 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：18 张三 name=18,age=0 PS F:\\go_project\u0026gt; 2. 变量\r变量，存储数据的容器，可以存放任何数据值。变量名由字母、数字、下划线组成，数字不能开头。Go中的关键字和保留字不能作为变量名\n2.1 变量的声明\r声明变量，指的是定义变量 总共有以下几种方式：\n// var \u0026lt;变量名\u0026gt; \u0026lt;数据类型\u0026gt; var a string // var \u0026lt;变量名\u0026gt;=\u0026lt;值\u0026gt; var b = \u0026#34;张三\u0026#34; fmt.Printf(\u0026#34;a=%v,b=%v\u0026#34;, a, b) // a没有赋值，默认为空 结果：\na=,b=张三 默认初始值测试：\nvar a string // 字符串，默认为空 var b int // 整型，默认为0 var c bool // 布尔值，默认为false var d float32 // 浮点类型，默认为0 fmt.Printf(\u0026#34;a=%v, b=%v, c=%v, d=%v\u0026#34;, a, b, c, d) // a没有赋值，默认为空 结果\na=, b=0, c=false, d=0 提示：Go语言中变量声明必须使用，否则会报错提示 declared and not used，意思是声明了并没有使用\n2.2 变量初始化，赋值\r// 变量初始化声明的三种方式 // 1.1 先声明变量 格式： var \u0026lt;变量名\u0026gt; \u0026lt;变量类型\u0026gt; var name string // 1.2 后赋值 格式：\u0026lt;变量名\u0026gt; = \u0026lt;值\u0026gt; name = \u0026#34;张三\u0026#34; // 2. 声明的同时进行赋值 格式：var \u0026lt;变量名\u0026gt; = \u0026lt;值\u0026gt; var age = 18 // 3.短变量声明法 格式：\u0026lt;变量名\u0026gt; := \u0026lt;值\u0026gt; sex := \u0026#34;男\u0026#34; score := 80 fmt.Print(name, age, sex, score) 结果：\n张三18男80 2.2 声明多个变量\r// 1. 一次声明相同类型 var \u0026lt;变量名1\u0026gt;,\u0026lt;变量名2\u0026gt;... \u0026lt;数据类型\u0026gt; var a1, a2, a3 string a1 = \u0026#34;张三\u0026#34; a2 = \u0026#34;李四\u0026#34; a3 = \u0026#34;王五\u0026#34; fmt.Println(a1, a2, a3) /* * 2. 先声明，后赋值 var ( \u0026lt;变量名1\u0026gt; \u0026lt;数据类型\u0026gt; \u0026lt;变量名2\u0026gt; \u0026lt;数据类型\u0026gt; ... ) */ var ( name string age int ) name = \u0026#34;赵六\u0026#34; age = 20 fmt.Println(name, age) /* 3. 声明即赋值 var ( \u0026lt;变量名1\u0026gt; = \u0026lt;值\u0026gt; \u0026lt;变量名2\u0026gt; = \u0026lt;值\u0026gt; ... ) */ var ( num1 = 1 num2 = 2 ) fmt.Println(num1, num2) // 4. 短变量声明法 \u0026lt;变量名1\u0026gt;,\u0026lt;变量名2\u0026gt;,\u0026lt;变量名3\u0026gt; := \u0026lt;值1\u0026gt;,\u0026lt;值2\u0026gt;,\u0026lt;值3\u0026gt; num3, num4, num5 := 3, 4, \u0026#34;Hello\u0026#34; fmt.Println(num3, num4, num5) 结果：提示：Println具有加空格及换行功能\n张三 李四 王五 赵六 20 1 2 3 4 Hello var声明可用于全局定义使用，短变量声明只能用于局部变量。\n2.3 匿名变量\r匿名变量顾名思义没有变量名，一次性接收，用_表示\n示例：\npackage main import \u0026#34;fmt\u0026#34; // 先举示例，函数的定义后续学习讲解 func getUserInfo() (string, int) { return \u0026#34;zhangsan\u0026#34;, 10 } // main函数 入口函数 func main() { // var声明接收 var name, age = getUserInfo() fmt.Println(name, age) // _匿名变量，用于丢弃赋值 var _, age1 = getUserInfo() fmt.Println(age1) var name1, _ = getUserInfo() fmt.Println(name1) } 结果：\nzhangsan 10 10 zhangsan 匿名变量不占用命名空间，可以重复使用，但是var，:=声明的变量名称不可重复\n3. 常量\r变量是可以修改，变更的值，而常量是不可改变的值，用const声明\n3.1 常量的声明\r// const 定义一个常量 * 最常用 const A = \u0026#34;TEST1\u0026#34; fmt.Println(A) // 定义多个常量 const ( B = \u0026#34;TEST2\u0026#34; C = \u0026#34;TEST3\u0026#34; D = \u0026#34;TEST4\u0026#34; ) fmt.Println(B, C, D) // 定义多个常量，给定一个值 const ( E = \u0026#34;TEST5\u0026#34; F G // 值默认与上一个相同 H = \u0026#34;TEST6\u0026#34; I // 值默认与上一个相同 ) fmt.Println(E, F, G, H, I) 结果：\nTEST1 TEST2 TEST3 TEST4 TEST5 TEST5 TEST5 TEST6 TEST6 3.2 iota 自增长\riota为Go中的计数器，常与const结合使用\n示例：\n// iota 计数器使用 const ( n1 = iota // 0 n2 // 1 _ // 匿名跳过计数 n3 // 3 n4 = iota // 4 n5 // 5 n6 = 100 // 100 插队赋值 n7 = iota // 7 n8, n9, n10 = iota, iota, iota + 1 // 8,8,9 多变量声明iota不会计数叠加， ) fmt.Println(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10) 结果：\n0 1 3 4 5 100 7 8 8 9 4. 总结：Go常量变量命名规则\r变量名必须由数字，字母，下划线_组成 标识符开头不能是数字 标识符不能是保留字和关键字(var、if、for等) 变量的名字是严格区分大小写的，name、Name、NAme以及NAME是不同的四个变量。Go语法支持，但不推荐这样写。 变量定义尽可能见名思意 变量名一般采用驼峰命名法。驼峰命名：首字母小写，后续每个单子首字母大写，例如：maxAge。如果是专属名词，例如DNS,IP等，可直接采用大写。 ","date":"2024-12-21T19:36:53+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-02/","title":"Golang学习历程【第二篇 fmt包\u0026变量、常量的定义】"},{"content":" 引言：Go（又称为Golang）是一种开源的编程语言，由Google开发，于2009年首次公开发布。它旨在提供简洁、高效、可靠的软件开发解决方案。Golang是一种静态强类型、编译型语言，Golang具有很强的表达能力，得益于其并发机制，用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。\n体验感悟：待学习完成后补充\u0026hellip;\n1. 学习文档\r中文文档地址：https://go.p2hp.com/ 【不推荐，落后于官方文档】\n官方文档：https://go.dev/ 【推荐，最新，学习使用英文】\n边学边练： 中文地址 | 英文地址\nB站学习视频地址\n2. Window 本地安装Go\r2.1 安装\r安装步骤依次见下列图示： 点击箭头位置下载安装包，点击安装。注：原则上来说，开发人员不建议安装最新版本，存在一定BUG，但这里学习使用足以。 双击下载的go1.23.4.windows-amd64.msi文件进行安装\n2.2 验证\rwindows找环境变量 另外也可以通过命令方式验证GO是否安装完成。\nwin + R 组合按键唤醒运行窗口。输入: cmd。点击确认或回车： 输入下面命令，验证go是否安装成功 # go 版本号 go version # go 环境变量 go env 友情提示：当不小心点击【鼠标左键】，显示如下信息【关键信息为左上角的选择】。这个情况下表示cmd命令当前窗口为选择窗口，此时命令窗口运行的一切程序处于暂停状态，点击【鼠标右键】可恢复。 3. 开发环境——VsCode\r3.1 VsCode 安装\r安装地址\n下载好的文件将文件解压，一定点击解压文件或者解压到\u0026quot;VsCode-win***\u0026quot;，否则内部文件平铺当前目录，凌乱不堪。将解压的文件夹随意放在自己喜欢的指定磁盘文件下。\n点击解压文件才会有这一步：\n软件快捷方式放于桌面。\n打开软件，功能简要介绍\n3.2 安装插件\r3.2.1 language 语言汉化插件安装\r3.2.2 Go插件安装\r同理将Go插件安装完成\n4. Hello World 入门\r4.1 建工程\rVsCode打开项目工程\n遇到下面界面，点击信任即可\n4.2 创建项目文件\r4.3 编写Hello World程序\r// package 包声明： 可以理解为一个文件夹 package main // import 导入：一般指导入官方或自定义功能包 import \u0026#34;fmt\u0026#34; // main函数 入口函数 func main() { // 打印Hello World字符串，可不写分号，语法灵活 fmt.Println(\u0026#34;Hello World\u0026#34;) } 4.4 VsCode无代码提示解决方案\r打开cmd控制终端，输入GO代理地址\ngo env -w GOPROXY=https://goproxy.io/ 然后重启VsCode，多试几次重启，等待安装，尝试点击即可解决\n4.5 运行程序\r打开终端(本质就是windows的cmd窗口)，运行go文件命令\n// 语法命令：go run \u0026lt;文件名\u0026gt;，运行指定go文件的程序 go run main.go // 运行结果 // Hello World 4.6 构建打包程序\r// 终端执行命令 go build \u0026lt;文件名\u0026gt;。将文件打包成可运行的exe文件。 go build main.go 构建完成之后文件可双击运行在windows上。 当前示例运行后无反应。原因是程序运行完成之后自动关闭了终端窗口。\n","date":"2024-12-21T10:51:49+08:00","permalink":"https://zg-dd.github.io/stu/golang-stu-01/","title":"Golang学习历程【第一篇 入门】"},{"content":"show-busy-java-threads.sh\n#!/bin/bash # @Function # Find out the highest cpu consumed threads of java, and print the stack of these threads. # # @Usage # $ ./show-busy-java-threads.sh # # @author Jerry Lee # java目录 JAVA_HOME=/usr/local/java/jdk1.8.0_202 readonly PROG=`basename $0` readonly -a COMMAND_LINE=(\u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34;) usage() { cat \u0026lt;\u0026lt;EOF Usage: ${PROG} [OPTION]... Find out the highest cpu consumed threads of java, and print the stack of these threads. Example: ${PROG} -c 10 Options: -p, --pid find out the highest cpu consumed threads from the specifed java process, default from all java process. -c, --count set the thread count to show, default is 5 -h, --help display this help and exit EOF exit $1 } readonly ARGS=`getopt -n \u0026#34;$PROG\u0026#34; -a -o c:p:h -l count:,pid:,help -- \u0026#34;$@\u0026#34;` [ $? -ne 0 ] \u0026amp;\u0026amp; usage 1 eval set -- \u0026#34;${ARGS}\u0026#34; while true; do case \u0026#34;$1\u0026#34; in -c|--count) count=\u0026#34;$2\u0026#34; shift 2 ;; -p|--pid) pid=\u0026#34;$2\u0026#34; shift 2 ;; -h|--help) usage ;; --) shift break ;; esac done count=${count:-5} redEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;31m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } yellowEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;33m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } blueEcho() { [ -c /dev/stdout ] \u0026amp;\u0026amp; { # if stdout is console, turn on color output. echo -ne \u0026#34;\\033[1;36m\u0026#34; echo -n \u0026#34;$@\u0026#34; echo -e \u0026#34;\\033[0m\u0026#34; } || echo \u0026#34;$@\u0026#34; } # Check the existence of jstack command! if ! which jstack \u0026amp;\u0026gt; /dev/null; then [ -z \u0026#34;$JAVA_HOME\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH!\u0026#34; exit 1 } ! [ -f \u0026#34;$JAVA_HOME/bin/jstack\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH and $JAVA_HOME/bin/jstack file does NOT exists!\u0026#34; exit 1 } ! [ -x \u0026#34;$JAVA_HOME/bin/jstack\u0026#34; ] \u0026amp;\u0026amp; { redEcho \u0026#34;Error: jstack not found on PATH and $JAVA_HOME/bin/jstack is NOT executalbe!\u0026#34; exit 1 } export PATH=\u0026#34;$JAVA_HOME/bin:$PATH\u0026#34; fi readonly uuid=`date +%s`_${RANDOM}_$$ cleanupWhenExit() { rm /tmp/${uuid}_* \u0026amp;\u0026gt; /dev/null } trap \u0026#34;cleanupWhenExit\u0026#34; EXIT printStackOfThreads() { local line local count=1 while IFS=\u0026#34; \u0026#34; read -a line ; do local pid=${line[0]} local threadId=${line[1]} local threadId0x=\u0026#34;0x`printf %x ${threadId}`\u0026#34; local user=${line[2]} local pcpu=${line[4]} local jstackFile=/tmp/${uuid}_${pid} [ ! -f \u0026#34;${jstackFile}\u0026#34; ] \u0026amp;\u0026amp; { { if [ \u0026#34;${user}\u0026#34; == \u0026#34;${USER}\u0026#34; ]; then jstack ${pid} \u0026gt; ${jstackFile} else if [ $UID == 0 ]; then sudo -u ${user} jstack ${pid} \u0026gt; ${jstackFile} else redEcho \u0026#34;[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}).\u0026#34; redEcho \u0026#34;User of java process($user) is not current user($USER), need sudo to run again:\u0026#34; yellowEcho \u0026#34; sudo ${COMMAND_LINE[@]}\u0026#34; echo continue fi fi } || { redEcho \u0026#34;[$((count++))] Fail to jstack Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}).\u0026#34; echo rm ${jstackFile} continue } } blueEcho \u0026#34;[$((count++))] Busy(${pcpu}%) thread(${threadId}/${threadId0x}) stack of java process(${pid}) under user(${user}):\u0026#34; sed \u0026#34;/nid=${threadId0x} /,/^$/p\u0026#34; -n ${jstackFile} done } ps -Leo pid,lwp,user,comm,pcpu --no-headers | { [ -z \u0026#34;${pid}\u0026#34; ] \u0026amp;\u0026amp; awk \u0026#39;$4==\u0026#34;java\u0026#34;{print $0}\u0026#39; || awk -v \u0026#34;pid=${pid}\u0026#34; \u0026#39;$1==pid,$4==\u0026#34;java\u0026#34;{print $0}\u0026#39; } | sort -k5 -r -n | head --lines \u0026#34;${count}\u0026#34; | printStackOfThreads ","date":"2024-09-10T13:48:55+08:00","permalink":"https://zg-dd.github.io/blog/java-high-cpu-threads/","title":"Java 高CPU线程排查脚本"},{"content":" Byte Buddy是java的字节码增强器，一个优雅的运行时java代码生成库，使用时需要慎重\n文档地址：http://bytebuddy.net/#/tutorial-cn\n1. 引入ByteBuddy\r\u0026lt;!-- https://mvnrepository.com/artifact/net.bytebuddy/byte-buddy --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.bytebuddy\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;byte-buddy\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.14.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2. ByteBuddy学习\r2.1 类的创建\r任何类的实例创建都是从ByteBuddy的实例开始\nDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() .subclass(Object.class)// 增强方式：目标类生成子类 .name(\u0026#34;example.Type\u0026#34;) // 自定义生成的类名：包名+类名 .make();// 编译生成该类 2.2 指定类的包名\rDynamicType.Unloaded\u0026lt;?\u0026gt; dynamicType = byteBuddy .with(new NamingStrategy.AbstractBase() { @Override protected String name(TypeDescription superClass) { return \u0026#34;example.\u0026#34; + superClass.getSimpleName(); // 可自定义包名和类型 } }) .subclass(Object.class) .make(); 2.3 类的保存\rDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() dynamicType.saveIn(new File(\u0026#34;文件路径\u0026#34;));// 将类Class文件保存文件夹 2.4 类的注入\r可以将动态的生成的类注入到指定jar包中\nDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() dynamicType.inject(new File(\u0026#34;jar\u0026#34;));// 将类Class文件注入到jar包中 2.5 ByteBuddy增强方式\rByteBuddy共有三种增强方式：\nsubclass：为目标类生成子类进行增强 rebase：当对类型变基时，Byte Buddy 会保留所有被变基类的方法实现。Byte Buddy 会用兼容的签名复制所有方法的实现为一个私有的重命名过的方法， 而不像类重定义时丢弃覆写的方法。用这种方式的话，不存在方法实现的丢失，而且变基的方法可以通过调用这些重命名的方法（目前并未发现起作用） redefine：重新定义方法，会替换已存在的方法实现。 2.6 类的加载策略\rClassLoadingStrategy.Default定义了内置策略，如果不选择，系统会自动默认推导出一个策略。\nWRAPPER 策略： 1. 创建一个新的 ClassLoader 来加载动态生成的类型。 2. 适合大多数情况，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类。 WRAPPER_PERSISTENT：该策略与WRAPPER相同，但通过ClassLoader.getResourceAsStream（String）公开表示类的字节数组。为此，所有类文件都在包装类加载器中作为字节数组持久化。 CHILD_FIRST：创建一个子类优先加载的 ClassLoader，即打破了双亲委派模型。 CHILD_FIRST_PERSISTENT：该策略与CHILD_FIRST相同，但通过ClassLoader.getResourceAsStream（String）公开表示类的字节数组。为此，所有类文件都在包装类加载器中作为字节数组持久化。 INJECTION 策略：使用反射，将动态生成的类型直接注入到当前 ClassLoader 中。 2.7 运行时实例化\rDynamicType.Unloaded\u0026lt;Object\u0026gt; dynamicType = new ByteBuddy() .subclass(Object.class)// 增强方式：目标类生成子类 .name(\u0026#34;example.Type\u0026#34;) // 自定义生成的类名：包名+类名 .make();// 编译生成该类 2.8 字段和方法的声明\rDynamicType.Unloaded\u0026lt;?\u0026gt; dynamicType = new ByteBuddy() // 增强方式 .subclass(Object.class) // 类名 .name(\u0026#34;subclass.Example\u0026#34;) // 定义字段，类型、可见行 // 多个可使用|并列 .defineField(\u0026#34;username\u0026#34;, String.class, Modifier.PUBLIC | Modifier.STATIC) // 定义get方法 .defineMethod(\u0026#34;getUserName\u0026#34;, String.class, Modifier.PUBLIC) .intercept(FieldAccessor.ofField(\u0026#34;username\u0026#34;)) // 获取属性username的值 .make(); 2.9 FixedValue固定值\rFixedValue可以声明任意固定值，用于对字段，方法的定义，固定值最终会写入类的常量池中。\n2.10 ElementMatchers 元素选择器\rElementMatchers包含了大量匹配规则，用于覆写原类，常用的有：\nisDeclaredBy 匹配某一个类中的所有方法 named 指定方法名 takesArguments 指定参数个数 如下示例：\npublic class Foo { public String bar() { return null; } public String foo() { return null; } public String foo(Object o) { return null; } } // 构建一个实现类 DynamicType.Unloaded\u0026lt;?\u0026gt; dynamicType = new ByteBuddy() .with(new NamingStrategy.AbstractBase() { @Override protected String name(TypeDescription superClass) { return \u0026#34;subclass.subclass\u0026#34; + superClass.getSimpleName(); } }) .subclass(Foo.class) .method(ElementMatchers.isDeclaredBy(Foo.class)).intercept(FixedValue.value(\u0026#34;One!\u0026#34;)) .method(ElementMatchers.named(\u0026#34;foo\u0026#34;)).intercept(FixedValue.value(\u0026#34;Two!\u0026#34;)) .method(ElementMatchers.named(\u0026#34;foo\u0026#34;).and(ElementMatchers.takesArguments(1))) .intercept(FixedValue.value(\u0026#34;Three!\u0026#34;)) .make(); // 最终生成的类如下 public class subclassFoo extends Foo { public String foo(Object var1) {return \u0026#34;Three!\u0026#34;;} public String foo() {return \u0026#34;Two!\u0026#34;;} public String bar() {return \u0026#34;One!\u0026#34;;} public subclassFoo() {} } 该示例中 bar()方法仅被ElementMatchers.isDeclaredBy(Foo.class)匹配到，最终覆写了One! foo()方法被ElementMatchers.named(\u0026ldquo;foo\u0026rdquo;)和ElementMatchers.named(\u0026ldquo;foo\u0026rdquo;).and(ElementMatchers.takesArguments(1))匹配到，覆写了Tow! foo(Object var1)然后再被ElementMatchers.named(\u0026ldquo;foo\u0026rdquo;).and(ElementMatchers.takesArguments(1))匹配，再次覆写，得到Three!\n2.11 MethodDelegation(方法委托)\r方法委托给，它对方法调用做出反应时提供了最大程度的自由。Source中的方法可以委托给Target方法调用(Source和Target的方法名可以不一致)；注：所有的委托方法必须是static声明 简单示例：\n// 变基对象 public class MemoryDatabase { public void hello(String name) { System.out.println(\u0026#34;MemoryDatabase.hello origin\u0026#34;); } public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load orign：\u0026#34; + info); return Arrays.asList(info, info); } } // 委托类 public class LoggerInterceptor { public static void hello(String name) { System.out.println(\u0026#34;LoggerInterceptor.hello \u0026#34; + name + \u0026#34;!\u0026#34;); } public static List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;LoggerInterceptor.load before\u0026#34;); try { // 参数增强 List\u0026lt;String\u0026gt; list = Arrays.asList(info + \u0026#34;: foo\u0026#34;, info + \u0026#34;: bar\u0026#34;); System.out.println(\u0026#34;LoggerInterceptor.load after\u0026#34;); return list; } finally { System.out.println(\u0026#34;LoggerInterceptor.load finally\u0026#34;); } } } // 测试方法 MemoryDatabase loggingDatabase = new MemoryDatabase(); loggingDatabase.hello(\u0026#34;hello MemoryDatabase\u0026#34;); System.out.println(\u0026#34;MemoryDatabase.load return value：\u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); // 将MemoryDatabase类的指定方法进行委托变基 new ByteBuddy() .redefine(MemoryDatabase.class) .method(named(\u0026#34;hello\u0026#34;)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .method(named(\u0026#34;load\u0026#34;)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .make() .load(MemoryDatabase.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent())// ClassReloadingStrategy.fromInstalledAgent()表示使用代理修改源方法 .getLoaded(); System.out.println(\u0026#34;变基后。。。\u0026#34;); loggingDatabase = new MemoryDatabase(); loggingDatabase.hello(\u0026#34;hello MemoryDatabase\u0026#34;); System.out.println(\u0026#34;MemoryDatabase.load return value：\u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); // 运行结果 MemoryDatabase.hello origin MemoryDatabase.load orign：hello MemoryDatabase MemoryDatabase.load return value：[hello MemoryDatabase, hello MemoryDatabase] 变基后。。。 LoggerInterceptor.hello hello MemoryDatabase! LoggerInterceptor.load before LoggerInterceptor.load after LoggerInterceptor.load finally MemoryDatabase.load return value：[hello MemoryDatabase: foo, hello MemoryDatabase: bar] 上面这个简单示例可以看出，方法委托可以将原来的方法直接替换掉，进行变基修改。在进行修改源码中起到了重要作用。注：subclass是对父类的增强，不会对源类造成影响，redefine和rebase是需要代理权限的，需要再启动类加载前添加VM参数：-javaagent:路径地址\\byte-buddy-agent-1.14.17.jarbyte-buddy-agent指的是代码jar，网上搜索即可下载。下面就一一开始学习方法委托的各种场景：\n@SuperCall\npublic class MemoryDatabase { public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load orign：\u0026#34; + info); return Arrays.asList(info, info); } } public class LoggerInterceptor { public static List\u0026lt;String\u0026gt; log(@SuperCall Callable\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; zuper) { System.out.println(\u0026#34;LoggerInterceptor.log before\u0026#34;); try { // 参数增强 List\u0026lt;String\u0026gt; call = zuper.call(); System.out.println(\u0026#34;LoggerInterceptor.log after\u0026#34;); return call; } catch (Exception e) { throw new RuntimeException(e); } finally { System.out.println(\u0026#34;LoggerInterceptor.log finally\u0026#34;); } } } // 测试TEST: MemoryDatabase loggingDatabase = new ByteBuddy() .subclass(MemoryDatabase.class) .method(isDeclaredBy(MemoryDatabase.class)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .make() .load(MemoryDatabase.class.getClassLoader()) .getLoaded().newInstance(); System.out.println(\u0026#34;MemoryDatabase.load return value：\u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); 上面的示例将MemoryDatabase.load委托给了LoggerInterceptor.log；@SuperCall声明表示这是一个代理方法，指的就是MemoryDatabase.load。其中Callable\u0026lt;List\u0026gt;表示load方法的返回类型。这种方式其实就是spring aop的实现方式。\n@Super\npublic class MemoryDatabase { public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load orign：\u0026#34; + info); return Arrays.asList(info, info); } } public class LoggerInterceptor { // info表示方法参数，zuper注解@Super声明，表示代理对象 public static List\u0026lt;String\u0026gt; log(String info, @Super MemoryDatabase zuper) { System.out.println(\u0026#34;LoggerInterceptor.log before\u0026#34;); try { // 参数增强 List\u0026lt;String\u0026gt; strings = zuper.load(info + \u0026#34; Interceptor\u0026#34;); System.out.println(\u0026#34;LoggerInterceptor.log after\u0026#34;); return strings; } catch (Exception e) { throw new RuntimeException(e); } finally { System.out.println(\u0026#34;LoggerInterceptor.log finally\u0026#34;); } } } // 测试TEST: MemoryDatabase loggingDatabase = new ByteBuddy() .subclass(MemoryDatabase.class) .method(isDeclaredBy(MemoryDatabase.class)).intercept(MethodDelegation.to(LoggerInterceptor.class)) .make() .load(MemoryDatabase.class.getClassLoader()) .getLoaded().newInstance(); System.out.println(\u0026#34;MemoryDatabase.load return value：\u0026#34; + loggingDatabase.load(\u0026#34;hello MemoryDatabase\u0026#34;)); @Super是明确指定了代理实例。进行精确化的实现\n@RuntimeType\npublic class MemoryDatabase { public List\u0026lt;String\u0026gt; load(String info) { System.out.println(\u0026#34;MemoryDatabase.load orign：\u0026#34; + info); return Arrays.asList(info, info); } public List\u0026lt;Integer\u0026gt; load(Integer info) { System.out.println(\u0026#34;MemoryDatabase.load orign：\u0026#34; + info); return Arrays.asList(info, info); } } public class LoggerInterceptor { // @RuntimeType运行时指定具体参数类型 public static List\u0026lt;String\u0026gt; log(@RuntimeType Object info, @Super MemoryDatabase zuper) { // 参数增强 List\u0026lt;String\u0026gt; strings = zuper.load(info + \u0026#34; Interceptor\u0026#34;); System.out.println(\u0026#34;LoggerInterceptor.log :\u0026#34; + info); return strings; } } @RuntimeType运行时指定参数，可以实现方法重载的效果\n@Pipe 持续学习更新中。。。\n借鉴文章：https://blog.csdn.net/zhou920786312/article/details/130649115\n","date":"2024-07-21T17:14:51+08:00","permalink":"https://zg-dd.github.io/stu/byte-buddy-tutorial/","title":"Byte Buddy教程：Java字节码增强与动态代码生成指南"},{"content":"reflectasm java 高性能反射工具\r大佬文章\n官网示例\nmaven 引入 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.esotericsoftware\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reflectasm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 实体类 public class User { public Integer id; public String userName; public String password; public String address; public Integer getId() {return id;} public void setId(Integer id) {this.id = id;} public String getUserName() {return userName;} public void setUserName(String userName) {this.userName = userName;} public String getPassword() {return password;} public void setPassword(String password) {this.password = password;} public String getAddress() {return address;} public void setAddress(String addresss) {this.address = addresss;} public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, userName=\u0026#39;\u0026#34; + userName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, addresss=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 测试示例 public class ReflectasmDemo { public static void main(String[] args) { // 仅获取无参构造 ConstructorAccess\u0026lt;User\u0026gt; constructorAccess = ConstructorAccess.get(User.class); // 可获取public、protected、默认的、final修饰的属性, 不包含private static语句字段 FieldAccess fieldAccess = FieldAccess.get(User.class); // 可获取除private修饰以外的方法 MethodAccess methodAccess = MethodAccess.get(User.class); long start, end; { start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000; i++) { User user = new User(); user.setId(i); user.setUserName(\u0026#34;user\u0026#34; + 1); user.setPassword(\u0026#34;password\u0026#34; + 1); user.setAddress(\u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;对象构造耗时：\u0026#34; + (end - start)); } { start = System.currentTimeMillis(); try { Class\u0026lt;User\u0026gt; aClass = User.class; Method setUserName = aClass.getMethod(\u0026#34;setUserName\u0026#34;, String.class); Method setPassword = aClass.getMethod(\u0026#34;setPassword\u0026#34;, String.class); Method setAddresss = aClass.getMethod(\u0026#34;setAddress\u0026#34;, String.class); for (int i = 0; i \u0026lt; 10000; i++) { User user = aClass.newInstance(); Method setId = aClass.getMethod(\u0026#34;setId\u0026#34;, Integer.class); setId.invoke(user, i); setUserName.invoke(user, \u0026#34;user\u0026#34; + 1); setPassword.invoke(user, \u0026#34;password\u0026#34; + 1); setAddresss.invoke(user, \u0026#34;address\u0026#34; + 1); } } catch (Exception e) { e.printStackTrace(); } end = System.currentTimeMillis(); System.out.println(\u0026#34;反射构造：\u0026#34; + (end - start)); } { start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); fieldAccess.set(user, \u0026#34;id\u0026#34;, i); fieldAccess.set(user, \u0026#34;userName\u0026#34;, \u0026#34;user\u0026#34; + 1); fieldAccess.set(user, \u0026#34;password\u0026#34;, \u0026#34;password\u0026#34; + 1); fieldAccess.set(user, \u0026#34;address\u0026#34;, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm 使用Field 名称 构造：\u0026#34; + (end - start)); } { start = System.currentTimeMillis(); int setIdIndex = fieldAccess.getIndex(\u0026#34;id\u0026#34;); int setUserNameIndex = fieldAccess.getIndex(\u0026#34;userName\u0026#34;); int setPasswordIndex = fieldAccess.getIndex(\u0026#34;password\u0026#34;); int setAddressIndex = fieldAccess.getIndex(\u0026#34;address\u0026#34;); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); fieldAccess.set(user, setIdIndex, i); fieldAccess.set(user, setUserNameIndex, \u0026#34;user\u0026#34; + 1); fieldAccess.set(user, setPasswordIndex, \u0026#34;password\u0026#34; + 1); fieldAccess.set(user, setAddressIndex, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm 使用Field Index 构造：\u0026#34; + (end - start)); } { start = System.currentTimeMillis(); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); methodAccess.invoke(user, \u0026#34;setId\u0026#34;, i); methodAccess.invoke(user, \u0026#34;setUserName\u0026#34;, \u0026#34;user\u0026#34; + 1); methodAccess.invoke(user, \u0026#34;setPassword\u0026#34;, \u0026#34;password\u0026#34; + 1); methodAccess.invoke(user, \u0026#34;setAddress\u0026#34;, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm 使用method 名称 构造：\u0026#34; + (end - start)); } { start = System.currentTimeMillis(); int setIdIndex = methodAccess.getIndex(\u0026#34;setId\u0026#34;, Integer.class); int setUserNameIndex = methodAccess.getIndex(\u0026#34;setUserName\u0026#34;, String.class); int setPasswordIndex = methodAccess.getIndex(\u0026#34;setPassword\u0026#34;, String.class); int setAddressIndex = methodAccess.getIndex(\u0026#34;setAddress\u0026#34;, String.class); for (int i = 0; i \u0026lt; 10000; i++) { User user = constructorAccess.newInstance(); methodAccess.invoke(user, setIdIndex, i); methodAccess.invoke(user, setUserNameIndex, \u0026#34;user\u0026#34; + 1); methodAccess.invoke(user, setPasswordIndex, \u0026#34;password\u0026#34; + 1); methodAccess.invoke(user, setAddressIndex, \u0026#34;address\u0026#34; + 1); } end = System.currentTimeMillis(); System.out.println(\u0026#34;reflectasm 使用method Index 构造：\u0026#34; + (end - start)); } } } 测试结果 对象构造耗时：6\r反射构造：15\rreflectasm 使用Field 名称 构造：2\rreflectasm 使用Field Index 构造：2\rreflectasm 使用method 名称 构造：3\rreflectasm 使用method Index 构造：1 结论 几种构建方式性能由高到低排序： reflectasm 使用Field Index \u0026gt;= reflectasm 使用Field 名称 \u0026gt; reflectasm 使用method Index \u0026gt;= reflectasm 使用method 名称 \u0026gt; new对象 \u0026gt; jdk反射 ","date":"2024-04-13T21:17:40+08:00","permalink":"https://zg-dd.github.io/stu/reflectasm-intro/","title":"ReflectASM - Java高性能反射工具详解"},{"content":"项目场景：\r业务：查询功能，需要关联多张表，为一对多或多对多。 需求：要求分页，分页统计总数。 使用技术：Mybatis，PageHelper\n问题描述\r正常查询一张表的情况下，官方推荐：\n//获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); List\u0026lt;User\u0026gt; list = userMapper.selectAll(); //用PageInfo对结果进行包装 PageInfo page = new PageInfo(list); 但是这种方式实际上PageHelper会自动生成：\nselect count(0) from (selectAll() sql语句) table_count 普通查询返回正常统计数量。一对多、多对多关联返回的count不一定正确\n原因分析：\r关联查询的结果是以最小单位为一条数据进行统计的。这里的最小单位举例：学生表和成绩表关联，一个学生有多个课程成绩，那么查询学生的成绩时，一位学生+一门课程的成绩就为最小单位。但有时候我们需要根据成绩搜索学生，但是需要了解有多少个学生。 这个时候PageHelper就无法自动实现了，需要自定义count解决。\n解决方案：\r以下说明我的错误经历\n错误方式1： /** * 这里的getUserList_COUNT SQL模板是： * SELECT count(*) FROM (getUserList SQL语句) table_count * 返回值类型：Long */ // false 表示不使用统计总数，自定义统计数量 PageHelper.startPage(1, 10, false).doCount(() -\u0026gt; stopShipMapper.getUserList_COUNT(params)); // params这里指的是自定义的参数对象，可有可无，业务需求而已 List\u0026lt;User\u0026gt; userList = stopShipMapper.getUserList(params); PageInfo\u0026lt;User\u0026gt; info = new PageInfo\u0026lt;\u0026gt;(userList); 报错：在系统中发现了多个分页插件,请检查系统配置! 网上多数介绍，通过@SpringBootApplication(exclude = PageHelperAutoConfiguration.class)，但是分页会失效，然后还有说多了两次自定义配置。但是只进行了一次配置。不存在这个问题。 查看源码得知如下： 原因：也就是说查询方法名不能后缀_COUNT，否则报异常。\n错误方式2： 于是乎改了调用方法名： /** * 这里的getUserList_COUNT SQL模板是： * SELECT count(*) FROM (getUserList SQL语句) table_count * 返回值类型：Long */ // false 表示不使用统计总数，自定义统计数量 PageHelper.startPage(1, 10, false).doCount(() -\u0026gt; stopShipMapper.getUserListTotal(params)); // params这里指的是自定义的参数对象，可有可无，业务需求而已 List\u0026lt;User\u0026gt; userList = stopShipMapper.getUserList(params); PageInfo\u0026lt;User\u0026gt; info = new PageInfo\u0026lt;\u0026gt;(userList); 错误：谢天谢地，count统计正常，但是查询语句后面没有后缀limit，分页失效。 原因：PageHelper分页有效的SQL为PageHelper.startPage后紧跟着的一条SQL。上述代码紧跟着的SQL是count，干扰了分页查询。\n错误方式3： 然后进一步修改，得到如下代码 /** * 这里的getUserList_COUNT SQL模板是： * SELECT count(*) FROM (getUserList SQL语句) table_count * 返回值类型：Long */ // false 表示不使用统计总数，自定义统计数量 PageHelper.startPage(1, 10, false); // params这里指的是自定义的参数对象，可有可无，业务需求而已 List\u0026lt;User\u0026gt; userList = stopShipMapper.getUserList(params); PageHelper.count(() -\u0026gt; stopShipMapper.getUserListTotal(params)) PageInfo\u0026lt;User\u0026gt; info = new PageInfo\u0026lt;\u0026gt;(userList); 错误：然后又错啦，报错说什么要求return long 实际 return null。 猜测原因：可能使用的是两个不同的分页对象，所以第二次只统计了总数，没有检测到没有分页查询\n错误方式4： 接下来再改，得到如下代码 /** * 这里的getUserListTotal SQL模板是： * SELECT count(*) FROM (getUserList SQL语句) table_count * 返回值类型：Long */ // false 表示不使用统计总数，自定义统计数量 // false 表示不使用统计总数 Page page = PageHelper.startPage(1, 10, false); // params这里指的是自定义的参数对象，可有可无，业务需求而已 List\u0026lt;User\u0026gt; userList = stopShipMapper.getUserList(params); // 自定义统计数量 page.doCount(()-\u0026gt; stopShipMapper.getUserListTotal(params)); PageInfo\u0026lt;User\u0026gt; info = new PageInfo\u0026lt;\u0026gt;(userList); 错误：分页数据正常啦，但是统计count又成了-1。 原因：doCount是一个回调自定义处理函数，并没有对page做处理，因此需要手动处理。\n错误方式5： /** * 这里的getUserListTotal SQL模板是： * SELECT count(*) FROM (getUserList SQL语句) table_count * 返回值类型：Long */ // false 表示不使用统计总数，自定义统计数量 // false 表示不使用统计总数 Page page = PageHelper.startPage(1, 10, false); // params这里指的是自定义的参数对象，可有可无，业务需求而已 List\u0026lt;User\u0026gt; userList = stopShipMapper.getUserList(params); // 自定义统计数量 page.doCount(() -\u0026gt; page.setTotal(stopShipMapper.getUserListTotal(params))); PageInfo\u0026lt;User\u0026gt; info = new PageInfo\u0026lt;\u0026gt;(userList); 经过验证，最后一种方式也是有问题的，此时既可以分页，也可以统计数量，但是分页的结果还是最小单元。建议使用方式2，SQL使用子查询来先分页后关联数据 ","date":"2022-10-12T10:43:38+08:00","permalink":"https://zg-dd.github.io/blog/mybatis-pagehelper-pagination/","title":"MyBatis PageHelper 多表关联分页解决方案 - 自定义count查询"},{"content":"一、LambdaQueryWrapper？\rLambdaQueryWrapper是Mybatis-Plus插件的对象，实现了使用lambda形式构造查询接口。 最初接触这个的时候，第一感觉就是，太方便了，因避免是用大量的字符串，对日后的维护有着很重要的作用。\n二、类名::GET方法\r在LambdaQueryWrapper构造语句的方法中使用了大量的这种方式作为查询数据库的字段名。这种方式还可指定具体的类。\n类名::GET方法，这是lambda的调用Get方法，简化操作的，例：\nList\u0026lt;String\u0026gt; list = new ArrayLiast(); list.add(\u0026#34;Hello\u0026#34;); //化简前 list.forEach(item -\u0026gt; System.out.println(item)); //化简后 list.forEach(System.out::println); 具体使用可自行百度，:: 实现是其实使用的是Function\u0026lt;T, R\u0026gt;接口，该接口声明@FunctionalInterface，即这是函数式接口。\n二、如何结合使用？\rLambdaQueryWrapper 查询需要的是字段名，而::得到的是执行get方法。那么mybatis-plus到底是怎么将get方法转换为字段的呢。并不是执行呢？ IDEA调试方法可知如下： 类名::GET方法实际类型是Function\u0026lt;T,R\u0026gt;，而mybatis-plus使用新的接口SFunction\u0026lt;T,R\u0026gt;将Function序列化后，该Function接口会在运行时添加writeReplace方法，可以查看当前执行方法的类名、方法名等信息。然后通过方法名解析出字段名。\n三、示例代码\r@FunctionalInterface public interface SFunction\u0026lt;T,R\u0026gt; extends Function\u0026lt;T,R\u0026gt;, Serializable { } public class User { private String username; private String password; // get、set略 } public class Builder\u0026lt;T\u0026gt; { private T target; public Builder(Class\u0026lt;T\u0026gt; tClass) { try { target = tClass.newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } public static \u0026lt;T\u0026gt; Builder\u0026lt;T\u0026gt; builder(Class\u0026lt;T\u0026gt; tClass) { return new Builder(tClass); } public \u0026lt;T,R\u0026gt; String getFunName(SFunction\u0026lt;T, R\u0026gt; sFunction) { try { // 直接调用writeReplace Method methods = sFunction.getClass().getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); methods.setAccessible(true); //反射调用 Object sl = methods.invoke(sFunction); SerializedLambda serializedLambda = (SerializedLambda) sl; // 获取类 String implClass = serializedLambda.getImplClass(); Class\u0026lt;?\u0026gt; aClass = Class.forName(implClass.replace(\u0026#34;/\u0026#34;, \u0026#34;.\u0026#34;)); // 获取方法名 String methodName = serializedLambda.getImplMethodName(); return methodName; } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 获取值 return null; } } public class Main { public static void main(String[] args) { Builder\u0026lt;User\u0026gt; builder = Builder.builder(User.class); String name = builder.getFunName(User::getUsername); System.out.println(name); } } 运行结果：\ngetUsername 总结\r通过上面的示例，轻而易举可获取到方法的名或字段名或者其他信息。上面的代码在业务需求方面没有什么用处。但是在构造条件情况下，结合设计模式，有很醒目的作用，能够给编程带来便利.\n","date":"2022-09-19T15:24:42+08:00","permalink":"https://zg-dd.github.io/blog/mybatis-lambda/","title":"MyBatis-Plus LambdaQueryWrapper - 函数式编程实践"},{"content":"axios解决同步问题的方式\r至今我能想到的解决同步/异步问题的三种方式如下：\n通过函数回调解决同步异步。这种方式代码书写层层嵌套不直观。 async/await关键字，这两个关键字搭配使用完美解决同步/异步问题，但是这种方式并不能说是解决了同步问题，而是说将异步功能延续到了调用者，即父方法。当然这种方式在调用方本身就是异步函数的情况下有效。 利用引用变量的方式解决同步异步问题。这种方式完美解决了第2种方式存在的问题，调用方可以是同步方法。但是该种方式不能解决基本类型，因为基本类型不是使用引用变量的。可通过将基本类型包装在对象中，解决这个问题。 以上三种方式各有利弊，具体情况使用具体方式。下面通过示例模拟一下上述三种方式。\n回调解决\n正常情况下：\n// 模拟异步发数据 function req(str) { return new Promise((resolve, reject) =\u0026gt; { resolve(str) }) } // 请求方法 function update(data) { req(data).then(result =\u0026gt; { str = result; // 代码更新后区域 console.log(\u0026#34;结果3:\u0026#34; + str); // 代码1 }); console.log(\u0026#34;结果1:\u0026#34; + str); // 代码2 } let str = \u0026#34;你好\u0026#34;; // 代码3 update(\u0026#34;hello\u0026#34;); // 代码4 console.log(\u0026#34;结果2:\u0026#34; + str); // 代码5 结果： 分析：代码3,之后，执行代码4，其中并不会立刻执行代码1，而是执行方法内部的代码2和之后跳出代码5。因为req(data).then()是异步的，等异步请求结束后之行代码1，因此写在代码1区域能够解决实际问题，少量回调，这个方式很方便，多次回调时，降低了代码的可读性。\nasync/await关键字\n// 模拟异步发数据 function req(str) { return new Promise((resolve, reject) =\u0026gt; { resolve(str) }) } // 请求方法,通过声明async/await,可等待异步完成之后再执行 async function update(data) { await req(data).then(result =\u0026gt; { str = result; console.log(\u0026#34;结果2:\u0026#34; + str); // 代码1 }); // 代码更新后区域 console.log(\u0026#34;结果3:\u0026#34; + str); // 代码2 } let str = \u0026#34;你好\u0026#34;; // 代码3 update(\u0026#34;hello\u0026#34;); // 代码4 console.log(\u0026#34;结果1:\u0026#34; + str); // 代码5 结果： 步骤：第一步将父级方法也就是update，声明为异步方法（async），然后再需要等待同步的地方标注为await，这样即可等待req(data).then()请求执行成功之后，再执行下面代码。注意：async必不可少，否则报错。 分析：代码执行完3时，因为代码4声明为异步了，故先执行了代码5，执行请求时，发现请求为等待，故等then执行结束后，即执行了代码1，最后执行了代码2。所以代码2区域能够解决实际问题。虽然这样是解决了update方法内部的同步代码问题，但是变相的将异步问题向上拋了。update方法为异步了。\n利用引用变量的方式解决同步异步问题 下面使用新的示例，因为字符串不是使用引用的方式，需要将字符串包裹在对象中才起作用。先看正常的示例：\n// 模拟异步发数据 function req(obj) { return new Promise((resolve, reject) =\u0026gt; { resolve(obj) }) } // 请求方法,通过声明async/await,可等待异步完成之后再执行 function update(data) { req(data).then(result =\u0026gt; { obj = result; console.log(\u0026#34;结果3:\u0026#34;,obj); // 代码1 }); console.log(\u0026#34;结果1:\u0026#34;,obj); // 代码2 } let obj = { msg: \u0026#34;你好\u0026#34; }; // 代码3 update({ msg: \u0026#34;hello\u0026#34; }); // 代码4 console.log(\u0026#34;结果2:\u0026#34;,obj); // 代码5 结果： 分析：不用多说，代码执行顺序为：代码3、4、2、5、1。执行代码2和5时，obj其实是一个引用，因此这两个结果是一样的，但是，赋值使用obj = result，结果2之前将obj引用到了新的对象，因此执行结果2最后和之前不一样。 问题：怎么样才能将结果1和结果2的值和结果3是一样的呢？ 方案：这是赋值的问题，因此obj = result的意思是将obj指向了新的引用对象，之前的丢弃。所以在赋值的时候，不要丢弃之前的对象，只是做修改对象内部属性的值，那么不管再哪里引用都是一样的值了。\n// 模拟异步发数据 function req(obj) { return new Promise((resolve, reject) =\u0026gt; { resolve(obj) }) } // 请求方法,通过声明async/await,可等待异步完成之后再执行 function update(data) { req(data).then(result =\u0026gt; { // 只赋值属性的值，不改变引用地址 obj.msg = result.msg; console.log(\u0026#34;结果3:\u0026#34;,obj); // 代码1 }); console.log(\u0026#34;结果1:\u0026#34;,obj); // 代码2 } let obj = { msg: \u0026#34;你好\u0026#34; }; // 代码3 update({ msg: \u0026#34;hello\u0026#34; }); // 代码4 console.log(\u0026#34;结果2:\u0026#34;,obj); // 代码5 结果： 分析：如结果所示，最后的数据为实时的数据，但是上面的打印数据是代码执行时的值，而我们平时调用获取值时，都是使用引用来获取变量的实时数据。这种方式没有改变代码执行的顺序，也没有改变异步和同步的方式，只是改变了赋值方式。这种方式在父方法不能为异步方法时，很有效。再次强调，如果为基本类型，包装在一个对象或数组的应用下才有效。\n","date":"2022-07-15T17:07:31+08:00","permalink":"https://zg-dd.github.io/blog/axios-sync-solutions/","title":"axios同步问题 - 三种解决方案详解"},{"content":"正则表达式部分理解\r[] 使用[]表示匹配[]中括号中的一个字符，比如[abc]，表示匹配a,b,c的任意一个字符，比如字符串中abcdabcdbd，会匹配到a,b,c,a,b,c,b，本意是只要出现一个字符就会匹配，不会合并到一起。 而[abc]+，代表的是匹配abc一次或出现多次，abcdabcdbd这个例子中会匹配到abc,abc,b，也就说匹配的是a,b,c中的任何字符，出现一次或多次都匹配，如果是连续出现的会当做一个字符串匹配到。 \\ \\表示转移符号，常用的转义字符有\\n(换行)、\\t(水平制表符，一个Tab键)、\\r(回车)、\\b(退格)、\\f(换页符)、\\n(换行符)、\\v(垂直制表符)、\\\u0026rsquo;(代表 \u0026rsquo; )、\\\u0026quot;(代表 \u0026ldquo;)、\\\\(代表 \\)等等。正则表达式中还有表示的很多符号，这里就不一一举例了，下面的图片中给出了所有符号。 这里要强调的是： 写正则表达式中，\\b、\\f、\\n、\\t、\\r、\\\u0026rsquo; 这些都可以直接写，例如regex=\u0026quot;\\n\u0026rdquo;;它就表示匹配一个换行符，而regex=\u0026quot;\\\\n\u0026quot;；也表示一个换行符，这两种写法都可以，但是对于一些符号就不能这样写了，例如：\\w、\\W、\\B、\\S、\\s等等这些表示含义就不能这样写了，必须写成regex=\u0026quot;\\\\w\u0026quot;,才能使用，否则会报错。可以尝试一下，再复制这些转义字符时，会将\\自动写成\\\\，所以在写正则表达式使用到带有\\符号的，我建议使用\\\\表示。 注意： 并不是说所有的转义字符都要写成\\\\，例如：匹配 \u0026quot; 字符，不能写成regex=\u0026quot;\\\\\u0026quot;\u0026quot;，系统会将 \u0026quot; 转义为本身 \u0026quot; 含义，那么再java中上述这句话就会多出一个 \u0026quot; 。所以应该写成regex=\u0026quot;\\\\\\\u0026quot;\u0026quot;，写成regex=\u0026quot;\\\u0026quot;\u0026quot;也是可以的。 如果要匹配的是 \\ 的话，java中的表示为regex= \u0026quot; \\\\\\\\ \u0026ldquo;，为四个 \\ ，其中两个的含义表示转义字符，前两个代表转义符号 \\ ，后两个代表另外一个符号 \\ ，使用第一个 \\ 再将第二个 \\ 转义为本身字符 (这是我自己的理解，也许不正确，但是表示方式是对的)，以此类推，如果要匹配\\\\,写法为regex=\u0026rdquo; \\\\\\\\\\\\\\\\ \u0026ldquo; | 这个符号在正则表达式中表示或的意思，对于正则表达式中的x|y，表示匹配x或者y，这里的 | 运算的优先级要高于x,y，也就是说，对于regex = \u0026ldquo;[a][b]|[c][d]\u0026rdquo;，来说，它匹配的是出现ab或者出现cd的字符串，不是匹配a(b或者c)d这样的字符串。 ?\u0026lt;=和?= 这两个符号很重要，这算是个组合符号吧，匹配该某符号但不包含此符号，举个例子就能明白了，比如说要截取双引号（\u0026rdquo; \u0026ldquo;）中说的话，比如String str = \u0026ldquo;he says,\\\u0026ldquo;Hello,Java!\\\u0026rdquo; \u0026ldquo;；说出的话中通常使用\u0026quot;\u0026ldquo;号括起来，现在需要匹配说话的内容，正则表达式可以表示为regex = \u0026ldquo;(?\u0026lt;=\\\u0026rdquo;)[^\\\u0026rdquo;]+(?=\\\u0026rdquo;)\u0026quot;;这其中的意思是：(?\u0026lt;=\\\u0026quot;)代表首先匹配 \u0026quot; ，但是不包含 \u0026quot; ，[^\\\u0026rdquo;]+代表其次匹配一次或者多次匹配不是 \u0026quot; 的字符，(?=\\\u0026quot;)代表再次匹配 \u0026quot; ，但是不包含 \u0026quot; 。这样子就能截取中间的句子了。这两个符号一般配合使用，表示不包含匹配字符，一个在前，一个在后 注：以上所有的单引号双引号都是英文，由于转义的问题，许多符号变成了中文，看本博客的时候需要注意 暂时学到的用到的就只有这些，后边如果再注意到新的点，之后再补充。\n正则表达式表\r","date":"2020-04-27T18:00:00+08:00","permalink":"https://zg-dd.github.io/stu/regular/","title":"正则表达式基础入门：常用符号解析([]、\\、|、(?\u003c=))"}]
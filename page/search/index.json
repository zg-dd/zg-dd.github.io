[{"content":"1. 闭包\r1.1 闭包的定义\r闭包函数（Closure）是函数式编程中的一个重要概念。在Go语言中，闭包函数是指一个函数与其引用的环境的组合。闭包函数可以访问并修改其外部函数中的变量，即使外部函数已经执行完毕。\n1.2 闭包的特点\r闭包函数可以访问其外部函数的局部变量。 闭包函数可以修改其外部函数的局部变量。 闭包函数可以保持其外部函数的局部变量在函数执行完毕后仍然存在。 1.3 闭包的示例\rpackage main import \u0026#34;fmt\u0026#34; /** * 闭包 * 一个函数和与其相关的引用环境组合而成的实体 */ func adder() func(int) int { sum := 0 // 返回一个函数，函数引用了sum变量 return func(x int) int { // 函数引用了sum变量 sum += x return sum } } func main() { // 调用adder函数，返回一个函数，这个函数引用了sum变量 pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { // 调用返回的函数，函数引用了sum变量 fmt.Println(pos(i), neg(-2*i)) } /** - `adder` 函数返回一个闭包。每个闭包都绑定了自己的 `sum` 变量。 - `pos` 和 `neg` 是两个独立的闭包，它们各自维护自己的 `sum`。 运行结果 0 0 1 -2 3 -6 6 -12 10 -20 15 -30 21 -42 28 -56 36 -72 45 -90 */ } 2. 类型(type)\r2.1 自定义类型\rGo 允许使用 type 关键字定义新的类型。\n2.2 类型示例\rpackage main import \u0026#34;fmt\u0026#34; // 自定义一个函数类型，类型名：addFun type addFun func(int) int // 自定义一个int类型，类型名：selfint type selfint int func adder2(x int) addFun { return func(y int) int { return x + y } } func main() { // 定义一个eg函数，其类型为addFun，是一个函数类型 var eg addFun = adder2(10) // 调用eg函数 ,eg函数是adder2函数的返回闭包函数，执行eg ==\u0026gt; adder2(10) + y ==\u0026gt; 10 + 15 = 25 fmt.Println(eg(15)) var num1 selfint = 10 var num2 int = 20 // 自定义类型selfint，不能直接与int类型进行运算，需要转换 fmt.Println(num1 + selfint(num2)) // 或者使用类型转换 fmt.Println(int(num1) + num2) /** * 运行结果： * 25 * 30 * 30 */ } 3. 延迟执行（Defer）\r3.1 defer 的用法\rdefer 语句会将其后面的函数调用推迟到外层函数返回之后执行。\n3.2 defer 示例\rpackage main import \u0026#34;fmt\u0026#34; func main() { // defer 是一个关键字，用于延迟执行一个函数调用，直到包含该 defer 语句的函数执行完毕。 defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) /* * 运行结果： * hello * world */ } 4. 恐慌（Panic）和恢复（Recover）\rPanic相当与抛出异常，Recover相当于捕获异常，Golang中没有try..catch\n4.1 panic 和 recover 的用法\rpanic 用于表示程序遇到了无法处理的错误。 recover 用于从 panic 中恢复。 4.2 panic 和 recover 示例\rpackage main import \u0026#34;fmt\u0026#34; func main() { // 定义一个延时函数并执行 defer func() { // 延时函数，等待主线程执行结束，捕获panic if r := recover(); r != nil { // 打印panic信息 fmt.Println(\u0026#34;Recovered from\u0026#34;, r) } }() // 执行语句 Starting the program fmt.Println(\u0026#34;Starting the program\u0026#34;) // 触发panic 相当于触发java的throw new Exception() panic(\u0026#34;Something went wrong!\u0026#34;) // 下面语句不会被执行 fmt.Println(\u0026#34;This line will not be executed\u0026#34;) /* * 运行结果： * - `panic` 触发了一个恐慌，程序会中止执行。 - `recover` 捕获了恐慌，程序继续执行。 * Starting the program * Recovered from Something went wrong! */ } 5. time包\rtime包是Go语言标准库中提供的一个用于处理时间的包，它提供了时间相关的函数和数据类型，可以用于获取当前时间、格式化时间、解析时间等操作。 time包中的Now函数可以获取当前时间，它返回一个Time类型的值，表示当前时间。下面是一个简单的示例：\n// 1. 获取当前时间 currentTime := time.Now() fmt.Println(\u0026#34;当前时间：\u0026#34;, currentTime) // 2. 获取当前时间的年、月、日、时、分、秒等信息 year := currentTime.Year() month := currentTime.Month() day := currentTime.Day() hour := currentTime.Hour() minute := currentTime.Minute() second := currentTime.Second() fmt.Printf(\u0026#34;当前时间：%d年%d月%d日 %d时%d分%d秒\\n\u0026#34;, year, month, day, hour, minute, second) // 3. 格式化时间 // time包提供了Format函数用于格式化时间，它接受一个格式字符串作为参数，返回一个字符串表示格式化后的时间。下面是一个简单的示例： fmt.Println(\u0026#34;格式化时间：\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) // 4. 解析时间 // time包提供了Parse函数用于解析时间，它接受一个格式字符串和一个时间字符串作为参数，返回一个Time类型的值表示解析后的时间。下面是一个简单的示例： timeStr := \u0026#34;2023-01-01 12:00:00\u0026#34; parsedTime, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) if err != nil { fmt.Println(\u0026#34;解析时间失败：\u0026#34;, err) return } fmt.Println(\u0026#34;解析时间：\u0026#34;, parsedTime) // 5. 时间间隔 // time包提供了Duration类型表示时间间隔，它表示两个时间点之间的时间差。下面是一个简单的示例： duration := time.Duration(10) * time.Second fmt.Println(\u0026#34;时间间隔：\u0026#34;, duration) // 6. 时间操作 // time包提供了Add函数用于将时间间隔添加到时间上，返回一个新的时间。下面是一个简单的示例： newTime := currentTime.Add(duration) fmt.Println(\u0026#34;新时间：\u0026#34;, newTime) // 7. 时间比较 // time包提供了Before、After和Equal函数用于比较两个时间的大小关系。下面是一个简单的示例： if currentTime.Before(parsedTime) { fmt.Println(\u0026#34;当前时间在解析时间之前\u0026#34;) } else if currentTime.After(parsedTime) { fmt.Println(\u0026#34;当前时间在解析时间之后\u0026#34;) } else { fmt.Println(\u0026#34;当前时间与解析时间相等\u0026#34;) } if currentTime.Equal(parsedTime) { fmt.Println(\u0026#34;当前时间与解析时间相等\u0026#34;) } /** * 以上运行结果： * 当前时间： 2023-10-13 10:18:00.0000007 +0800 CST m=+0.000014679 * 当前时间： 2023年10月13日 10时18分0秒 * 格式化时间： 2023-10-13 10:18:00 * 解析时间： 2023-01-01 12:00:00 +0000 UTC * 时间间隔： 10s * 新时间： 2023-10-13 10:28:00.0000007 +0800 CST m=+10.000014679 * 当前时间在解析时间之前 * 当前时间与解析时间不相等 */ 总结：\n获取当前时间：\ttime.Now() 获取时间的详细信息： currentTime.Year() | currentTime.Month() | currentTime.Day() | currentTime.Hour() | currentTime.Minute() | currentTime.Second() 格式化时间： currentTime.Format(\u0026ldquo;2006-01-02 15:04:05\u0026rdquo;) 解析时间： time.Parse(\u0026ldquo;2006-01-02 15:04:05\u0026rdquo;, timeStr) 时间间隔： time.Duration(10) * time.Second 时间操作： currentTime.Add(duration) 时间比较： currentTime.Before(parsedTime) | currentTime.After(parsedTime) | currentTime.Equal(parsedTime) ","date":"2025-02-13T17:45:37+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_07/","title":"Golang学习历程【第七篇 闭包\u0026type defer panic recover了解\u0026time包】"},{"content":"1. Map数据类型\rMap结构是键值对的集合，其中每个键都是唯一的，并且每个键都映射到一个值。 Map是无序的，即元素的顺序是不确定的。 Map的初始值是nil，不能直接使用，需要使用make函数来创建一个Map。 Map结构为引用数据类型\n1.1. Map声明和初始化\r// Map的声明,其中keyType是键的类型，valueType是值的类型 // 1. 先声明 var 变量名 map[keyType]valueType var map1 map[string]int // 2. 使用make函数来创建一个Map map1 = make(map[string]int) map1[\u0026#34;a\u0026#34;] = 1 map1[\u0026#34;b\u0026#34;] = 2 map1[\u0026#34;c\u0026#34;] = 3 // 2. 声明即创建 ,并赋值 var 变量名 = make(map[keyType]valueType) var map2 = make(map[string]int) map2[\u0026#34;a\u0026#34;] = 4 map2[\u0026#34;b\u0026#34;] = 5 map2[\u0026#34;c\u0026#34;] = 6 // 3. 简短声明 变量名 := map[keyType]valueType map3 := map[string]int{} map3[\u0026#34;a\u0026#34;] = 7 map3[\u0026#34;b\u0026#34;] = 8 map3[\u0026#34;c\u0026#34;] = 9 // 4. 声明即创建,并赋值 var map4 = map[string]int{\u0026#34;a\u0026#34;: 10, \u0026#34;b\u0026#34;: 11, \u0026#34;c\u0026#34;: 12} // 5. 简短声明,并赋值 map5 := map[string]int{\u0026#34;a\u0026#34;: 13, \u0026#34;b\u0026#34;: 14, \u0026#34;c\u0026#34;: 15} // 6. 声明一个map和定义一个map,其值的区别 var map6 map[string]int var map7 = map[string]int{} fmt.Printf(\u0026#34;map1 类型：%T 值：%v map1 是否为 nil %v \\n\u0026#34;, map1, map1, map1 == nil) fmt.Printf(\u0026#34;map2 类型：%T 值：%v map2 是否为 nil %v \\n\u0026#34;, map2, map2, map2 == nil) fmt.Printf(\u0026#34;map3 类型：%T 值：%v map3 是否为 nil %v \\n\u0026#34;, map3, map3, map3 == nil) fmt.Printf(\u0026#34;map4 类型：%T 值：%v map4 是否为 nil %v \\n\u0026#34;, map4, map4, map4 == nil) fmt.Printf(\u0026#34;map5 类型：%T 值：%v map5 是否为 nil %v \\n\u0026#34;, map5, map5, map5 == nil) fmt.Printf(\u0026#34;map6 类型：%T 值：%v map6 是否为 nil %v \\n\u0026#34;, map6, map6, map6 == nil) // map6 是 nil，不能使用，因为仅做了声明，没有初始化 fmt.Printf(\u0026#34;map7 类型：%T 值：%v map7 是否为 nil %v \\n\u0026#34;, map7, map7, map7 == nil) // map7 是一个空的map，可以正常使用 /** * Map获取长度函数 len()，结果为键值对个数 */ map8 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;, } fmt.Println(len(map1)) /** * 以上运行结果 * map1 类型：map[string]int 值：map[a:1 b:2 c:3] map1 是否为 nil false * map2 类型：map[string]int 值：map[a:4 b:5 c:6] map2 是否为 nil false * map3 类型：map[string]int 值：map[a:7 b:8 c:9] map3 是否为 nil false * map4 类型：map[string]int 值：map[a:10 b:11 c:12] map4 是否为 nil false * map5 类型：map[string]int 值：map[a:13 b:14 c:15] map5 是否为 nil false * map6 类型：map[string]int 值：\u0026lt;nil\u0026gt; map6 是否为 nil true * map7 类型：map[string]int 值：map[] map7 是否为 nil false * 3 */ 1.2. Map 遍历\r/** * Map的遍历 */ map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;, } // 1. fori遍历方式 fmt.Println(\u0026#34;1. fori遍历方式\u0026#34;) keys := make([]string, 0, len(map1)) for k := range map1 { keys = append(keys, k) } for i := 0; i \u0026lt; len(keys); i++ { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, keys[i], map1[keys[i]]) } // 2. forrange遍历方式 fmt.Println(\u0026#34;2. forrange遍历方式\u0026#34;) for k, v := range map1 { fmt.Printf(\u0026#34;key=%v value=%v\\n\u0026#34;, k, v) } /** * 结果： * 1. fori遍历方式 * key=one value=java * key=two value=python * key=three value=go * 2. forrange遍历方式 * key=one value=java * key=two value=python * key=three value=go */ 1.3 Map增删改查\rmap1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;go\u0026#34;, } // map的增删改查 // 增 map1[\u0026#34;four\u0026#34;] = \u0026#34;php\u0026#34; fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) // 删 delete(map1, \u0026#34;one\u0026#34;) fmt.Printf(\u0026#34;map1: %v\\n\u0026#34;, map1) // 改 map1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; // 查 value, ok := map1[\u0026#34;two\u0026#34;] // ok为true表示存在,为false表示不存在 if ok { fmt.Println(value) } value1, ok1 := map1[\u0026#34;five\u0026#34;] // ok为true表示存在,为false表示不存在 if ok1 { fmt.Println(value1) } else { fmt.Println(\u0026#34;five不存在\u0026#34;) } /* * 结果 * map1: map[four:php three:go two:python] * map1: map[three:go two:python] * c++ * five不存在 */ 2. function (函数)\r函数是一段可重复使用的代码块，用来完成特定的功能\n函数的特点有下：\n函数的作用：提高代码的复用性，提高代码的可读性，提高代码的维护性 .】函数的返回值：函数的返回值是通过return语句来实现的，return语句可以返回一个值，也可以返回多个值 函数的参数：函数的参数是通过函数的参数列表来实现的，参数列表中的参数可以是任意类型，参数列表中的参数可以是任意个数 函数变量作用域：函数变量作用域是指在函数内部定义的变量，该变量只能在函数内部使用，函数外部无法访问该变量 函数的返回值和参数列表：函数的返回值和参数列表是函数的组成部分，函数的返回值和参数列表是函数的输出和输入，函数的返回值和参数列表是函数的接口，函数的返回值和参数列表是函数的契约 2.1 函数各种定义方式\rpackage main import \u0026#34;fmt\u0026#34; /* * 函数初识 什么是函数：函数是一段可重复使用的代码块，用来完成特定的功能 函数的作用：提高代码的复用性，提高代码的可读性，提高代码的维护性 函数的定义：func 函数名(参数列表) 返回值列表 {函数体} 函数的调用：函数名(参数列表) 函数的返回值：函数的返回值是通过return语句来实现的，return语句可以返回一个值，也可以返回多个值 函数的参数：函数的参数是通过函数的参数列表来实现的，参数列表中的参数可以是任意类型，参数列表中的参数可以是任意个数 函数的返回值和参数列表：函数的返回值和参数列表是函数的组成部分，函数的返回值和参数列表是函数的输出和输入，函数的返回值和参数列表是函数的接口，函数的返回值和参数列表是函数的契约 * */ // 函数定义 // func 函数名(参数列表) 返回值列表 { // 函数体 // } /* * 1. 无参数无返回值 */ func sayHello() { fmt.Println(\u0026#34;hello world\u0026#34;) } /* * 2. 有参数无返回值 * @param name string */ func sayHello2(name string) { fmt.Println(\u0026#34;hello\u0026#34;, name) } /** * 2. 有参数有返回值 * @param a int * @param b int * @return int */ func add(a int, b int) int { return a + b } /* * 3. 省略参数类型，此时a的类型与b的类型保持一致 * @param a int * @param b int * @return int */ func add2(a, b int) int { return a + b } /** * 4. 省略返回值，此时函数的返回值类型为int * @param a int * @param b int * @return int */ func add3(a, b int) (c int) { // c := a + b c = a + b return // return c } /** * 5. 多个返回值 * @param a int * @param b int * @return int 之和 * @return int 之差 */ func add4(a, b int) (int, int) { return a + b, a - b } /** * 6. 命名返回值 * @param a int * @param b int * @return int 之和 * @return int 之差 */ func add5(a, b int) (sum, diff int) { sum = a + b diff = a - b return } /** * 7. 可变参数 * @param a ...int * @return int */ func add6(a ...int) int { sum := 0 for _, v := range a { sum += v } return sum } /** * 8. 函数做形参 * @param a int * @param b int * @param op func(int, int) int 表示参数为一个函数，该函数接收两个int类型的参数，返回一个int类型的值 */ func opreate(a, b int, op func(int, int) int) int { return op(a, b) // 调用函数 } /** * 9. 函数做返回值 * @param a int * @param b int * @return func() string */ func add7(a, b int) func() string { // 内部定义一个函数 f := func() string { return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) // 返回一个字符串 } // 这里只是定义函数，没有调用函数，调用函数需要使用f() return f // 返回函数 } /** * 10. 匿名函数 * 解释：匿名函数是没有名字的函数，匿名函数可以赋值给变量，也可以直接调用 * * @param a int 数值1 * @param b int 数值2 * @return func() string 返回类型为一个函数，该函数返回类型为string */ func add8(a, b int) func() string { return func() string { // 匿名函数的定义，没有函数名 return fmt.Sprintf(\u0026#34;%d + %d = %d\u0026#34;, a, b, a+b) // 返回一个字符串 } // 匿名函数的调用 } // main函数 入口函数 func main() { sayHello() sayHello2(\u0026#34;张三\u0026#34;) fmt.Printf(\u0026#34;add %d\\n\u0026#34;, add(1, 2)) fmt.Printf(\u0026#34;add2 %d\\n\u0026#34;, add2(3, 4)) fmt.Printf(\u0026#34;add3 %d\\n\u0026#34;, add3(5, 6)) sum1, diff1 := add4(7, 8) fmt.Printf(\u0026#34;add4 %d %d\\n\u0026#34;, sum1, diff1) sum2, diff2 := add5(9, 10) fmt.Printf(\u0026#34;add5 %d %d\\n\u0026#34;, sum2, diff2) fmt.Printf(\u0026#34;add6 %d\\n\u0026#34;, add6(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(1, 2, add)) fmt.Printf(\u0026#34;opreate %d\\n\u0026#34;, opreate(2, 4, func(i1, i2 int) int { // 自定义匿名函数做参数 return i1 * i2 // 返回两个数的乘积 })) fmt.Printf(\u0026#34;add7 %s\\n\u0026#34;, add7(1, 2)()) fmt.Printf(\u0026#34;add8 %s\\n\u0026#34;, add8(3, 4)()) /** * 以上运行结果： * hello world * hello 张三 * add 3 * add2 7 * add3 11 * add4 15 -3 * add5 19 -1 * add6 55 * opreate 3 * opreate 8 * add7 1 + 2 = 3 * add8 3 + 4 = 7 */ } ","date":"2025-02-11T20:05:09+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_06/","title":"Golang学习历程【第六篇 复合数据类型map\u0026函数初识】"},{"content":"1. 数组（Array）\r数组: 一系列固定长度、同一类型数据的集合。数组为值类型\n1.1 数组的定义\rvar 变量名 = [元素个数]\u0026lt;数据类型\u0026gt; // 声明 + 初始化，此时可将[元素个数]替换为[...]，表示初始化任意多个数据 var 变量名 = [元素个数]\u0026lt;数据类型\u0026gt;{} 变量名:= [元素个数]\u0026lt;数据类型\u0026gt;{} 示例：\n// 数组的定义 var arr1 [4]int // len获取数据长度 fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) 结果：\n类型：[4]int; 数组长度：4; 数据：[0 0 0 0] 1.2 初始化数组\r// 数组的定义 var arr1 [4]int // len获取数据长度 fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) /* 数组初始化 */ // 1.方式一 arr1[0] = 1 arr1[3] = 4 fmt.Printf(\u0026#34;方式一: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) // 2. 方式二 var 变量名 = [元素个数]\u0026lt;数据类型\u0026gt;{} var arr2 = [3]float64{1, 2, 4.6} fmt.Printf(\u0026#34;方式二: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr2, len(arr2), arr2) // 3. 方式三 变量名:= [元素个数]\u0026lt;数据类型\u0026gt;{} arr3 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;方式三: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr3, len(arr3), arr3) // 4. 方式四 var 变量名 = [...]\u0026lt;数据类型\u0026gt;{} 或 变量名:= [...]\u0026lt;数据类型\u0026gt;{} arr4 := [...]int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;方式四: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr4, len(arr4), arr4) // 5. 方式五 指定下标索引初始化索引 arr5 := [...]float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;方式五: 类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr5, len(arr5), arr5) 结果：\n类型：[4]int; 数组长度：4; 数据：[0 0 0 0] 方式一: 类型：[4]int; 数组长度：4; 数据：[1 0 0 4] 方式二: 类型：[3]float64; 数组长度：3; 数据：[1 2 4.6] 方式三: 类型：[3]string; 数组长度：3; 数据：[java Golang Python] 方式四: 类型：[5]int; 数组长度：5; 数据：[2 4 6 7 8] 方式五: 类型：[8]float64; 数组长度：8; 数据：[2 0 3.5 0 0 4.6 0 9] 1.3 数据的循环遍历\r/* 数组的循环遍历 */ arr6 := [3]string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} // 1. 使用fori循环 fmt.Printf(\u0026#34;fori循环 \u0026#34;) for i := 0; i \u0026lt; len(arr6); i++ { fmt.Printf(\u0026#34;下标%v: 值：%v; \\t\u0026#34;, i, arr6[i]) } fmt.Println() // 2. 使用for range fmt.Printf(\u0026#34;for range循环 \u0026#34;) for index, value := range arr6 { fmt.Printf(\u0026#34;下标%v: 值：%v; \\t\u0026#34;, index, value) } 结果：\nfori循环 下标0: 值：java; 下标1: 值：Golang; 下标2: 值：Python; for range循环 下标0: 值：java; 下标1: 值：Golang; 下标2: 值：Python; 1.4 多维数组\r// 2维数组为例 var 变量名 = [行个数][列个数]数据类型{{}} var arr7 = [3][3]int{ {1, 2, 3}, // 每一行数据 {4, 5, 6}, {7, 8, 9}, } fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr7, len(arr7), arr7) // 可以忽略行的数据个数，列的数据个数不允许忽略 var arr8 = [...][2]string{ {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}, } fmt.Printf(\u0026#34;类型：%T; \\t数组长度：%v; \\t数据：%v\\n\u0026#34;, arr8, len(arr8), arr8) // 二维数组循环 for i := 0; i \u0026lt; len(arr7); i++ { for j := 0; j \u0026lt; len(arr7[i]); j++ { fmt.Printf(\u0026#34;%v行%v列: 值：%v; \\t\u0026#34;, i+1, j+1, arr7[i][j]) } fmt.Println() } for row, rowValue := range arr8 { for col, value := range rowValue { fmt.Printf(\u0026#34;%v行%v列: 值：%v; \\t\u0026#34;, row+1, col+1, value) } fmt.Println() } 结果：\n类型：[3][3]int; 数组长度：3; 数据：[[1 2 3] [4 5 6] [7 8 9]] 类型：[2][2]string; 数组长度：2; 数据：[[a b] [c d]] 1行1列: 值：1; 1行2列: 值：2; 1行3列: 值：3; 2行1列: 值：4; 2行2列: 值：5; 2行3列: 值：6; 3行1列: 值：7; 3行2列: 值：8; 3行3列: 值：9; 1行1列: 值：a; 1行2列: 值：b; 2行1列: 值：c; 2行2列: 值：d; 2. 切片（Slice）\r切片：基于数组实现的一层封装，可变长度的序列，可自动扩容。切片为引用类型\n2.1 切片声明、初始化\rvar 变量名 = []\u0026lt;数据类型\u0026gt; // 声明 + 初始化 var 变量名 = []\u0026lt;数据类型\u0026gt;{} 变量名:= []\u0026lt;数据类型\u0026gt;{} 示例：\n// 切片的定义 var arr1 []int // len获取数据长度 fmt.Printf(\u0026#34;类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) /* 切片初始化 */ // 1. 方式一 var 变量名 = []\u0026lt;数据类型\u0026gt;{} var arr2 = []float64{1, 2, 4.6} fmt.Printf(\u0026#34;方式一: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr2, len(arr2), arr2) // 2. 方式二 变量名:= []\u0026lt;数据类型\u0026gt;{} arr3 := []string{\u0026#34;java\u0026#34;, \u0026#34;Golang\u0026#34;, \u0026#34;Python\u0026#34;} fmt.Printf(\u0026#34;方式二: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr3, len(arr3), arr3) // 3. 方式三 var 变量名 = []\u0026lt;数据类型\u0026gt;{} 或 变量名:= []\u0026lt;数据类型\u0026gt;{} arr4 := []int{2, 4, 6, 7, 8} fmt.Printf(\u0026#34;方式三: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr4, len(arr4), arr4) // 4. 方式四 指定下标索引初始化索引 arr5 := []float64{0: 2, 2: 3.5, 5: 4.6, 7: 9} fmt.Printf(\u0026#34;方式四: 类型：%T; \\t切片长度：%v; \\t数据：%v\\n\u0026#34;, arr5, len(arr5), arr5) // 5. 切片的循环和数组一致，这里不例举 结果：\n类型：[]int; 切片长度：0; 数据：[] 方式一: 类型：[]float64; 切片长度：3; 数据：[1 2 4.6] 方式二: 类型：[]string; 切片长度：3; 数据：[java Golang Python] 方式三: 类型：[]int; 切片长度：5; 数据：[2 4 6 7 8] 方式四: 类型：[]float64; 切片长度：8; 数据：[2 0 3.5 0 0 4.6 0 9] 2.2 基于数组创建切片\r示例：\n// 基于数组定义切片 var arr1 = [5]int{10, 29, 49, 58, 32} fmt.Printf(\u0026#34;类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, arr1, len(arr1), arr1) // 1. 切片获取，arr1[:]获取arr1中所有的数据 s1 := arr1[:] // 切片数据类型为[]int,数组数据类型为[5]int fmt.Printf(\u0026#34;获取所有数据--类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, s1, len(s1), s1) // 2. 切片获取，arr1[2:]获取arr1中从下标为2开始之后所有的数据【包含下标2】 s2 := arr1[2:] fmt.Printf(\u0026#34;获取下标为2开始之后所有的数据--类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, s1, len(s2), s2) // 3. 切片获取，arr1[:2]获取arr1中从下标为2之前所有的数据【不包含下标2】 s3 := arr1[:2] fmt.Printf(\u0026#34;获取下标为2之前所有的数据--类型：%T; \\t长度：%v; \\t数据：%v\\n\u0026#34;, s3, len(s3), s3) 结果：\n类型：[5]int; 长度：5; 数据：[10 29 49 58 32] 获取所有数据--类型：[]int; 长度：5; 数据：[10 29 49 58 32] 获取下标为2开始之后所有的数据--类型：[]int; 长度：3; 数据：[49 58 32] 获取下标为2之前所有的数据--类型：[]int; 长度：2; 数据：[10 29] 总结：数据的拆分：arr[start:end] 中，含义为：获取arr对应下标区间[start,end)的值，start,end可省略，表示其前或后的所有值。\n2.2 切片的长度(len)和容量(cap)*\r切片拥有自己的长度和容量： 长度：切片的长度是切片所包含的元素个数。用**len()函数获取 容量：切片的容量从他第一个元素开始，到底层数组元素末尾的个数。用cap()**函数获取\na := []int{2, 3, 4, 5, 6, 7} fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, a, len(a), cap(a), a) b := a[3:] fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, b, len(b), cap(b), b) c := a[:3] fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, c, len(c), cap(c), c) 结果：\n类型：[]int, 长度：6, 容量：6, 数据：[2 3 4 5 6 7] 类型：[]int, 长度：3, 容量：3, 数据：[5 6 7] 类型：[]int, 长度：3, 容量：6, 数据：[2 3 4] 3. nil值\rnil是一个预先声明的标识符，表示指针、通道、函数、接口、集合或切片类型的零值。\n数据类型 声明默认值 bool int,float 0 string \u0026quot;\u0026quot; 指针（pointers） nil 数组（array） 基本类型默认值的数组 切片（slices） nil 集合（maps） nil 通道（channels） nil 函数（function） nil // 数组默认值 var arr [3]int fmt.Println(arr) // 切片默认值 var slices1 []int var slices2 = []int{1} fmt.Println(slices1, slices1 == nil, slices2 == nil) 结果：\n[0 0 0] [] true false 4. 值类型和引用数据类型\r值类型: 值类型赋值的两个变量为独立个体，A变化不会引起B的同步更新 引用数据类型：引用数据类型赋值的两个变量为引用同一个变量，A变化会引起B的变化。实际上是因为指向同一片内存空间。典型的示例即：切片 示例：\na1 := [...]int{2, 3, 4, 5} // 数组 值复制 a2 := []int{2, 3, 4, 5} // 切片 引用赋值 b1 := a1 // 赋值给b1 b2 := a2 // 赋值给b2 b1[0] = 6 // 同样修改第一个元素值为6 b2[0] = 6 // 同样修改第一个元素值为6 fmt.Printf(\u0026#34;a1=%v,b1=%v \\n\u0026#34;, a1, b1) // 值类型赋值：b1的修改不会影响a1 fmt.Printf(\u0026#34;a2=%v,b2=%v \\n\u0026#34;, a2, b2) // 引用类型赋值：b2的修改影响了a2 结果：\na1=[2 3 4 5],b1=[6 3 4 5] a2=[6 3 4 5],b2=[6 3 4 5] 5. 切片常用函数\r5.1 创建切片：make\rmake创建切片，make([]int, 10, 11) 分配一个底层数组大小为10，返回长度为11、容量为10的切片int类型切片\nvar slice1 = make([]int, 10, 11) slice1[2] = 6 slice1[9] = 20 fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice1, len(slice1), cap(slice1), slice1) /* 结果： 类型：[]int, 长度：10, 容量：11, 数据：[0 0 6 0 0 0 0 0 0 20] */ 5.2 扩容切片：append\r切片扩容： append(slice, elem1, elem2)或者append(slice, anotherSlice...)，slice表示需要扩容的切片，elem*表示添加的元素，anotherSlice表示其他切片\n// 切片的扩容不能通过slice[2]下标越界方式，会报错下标越界：index out of range [2] with length 0 var slice2 = make([]int, 0, 0) // 切片中追加一个元素，并返回最终元素 slice2 = append(slice2, 12, 14, 24) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice2), cap(slice2), slice2) slice3 := []int{3, 4, 5} // 切片的合并，slice3...代表slice3中所有的元素列举 var slice4 = append(slice2, slice3...) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice4), cap(slice4), slice4) /* 结果： 类型：[]int, 长度：3, 容量：3, 数据：[12 14 24] 类型：[]int, 长度：6, 容量：6, 数据：[12 14 24 3 4 5] */ 5.3 复制切片【深克隆】：copy\r深克隆：指的是克隆前后的对象为两个独立的个体，后续修改变更互不影响 浅克隆：指的是克隆前后的对象为同一个引用类型，后续修改A同样影响B的值 copy(dst, src []Type)，dst是destination，表示目的变量，src是source，表示对象源，即将src复制给dst\n// 切片的扩容不能通过slice[2]下标越界方式，会报错下标越界：index out of range [2] with length 0 var slice2 = make([]int, 0, 0) // 切片中追加一个元素，并返回最终元素 slice2 = append(slice2, 12, 14, 24) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice2), cap(slice2), slice2) slice3 := []int{3, 4, 5} // 切片的合并，slice3...代表slice3中所有的元素列举 var slice4 = append(slice2, slice3...) fmt.Printf(\u0026#34;类型：%T, 长度：%v, 容量：%v, 数据：%v\\n\u0026#34;, slice2, len(slice4), cap(slice4), slice4) // 切片的复制深克隆 slice4Copy := make([]int, len(slice4)) copy(slice4Copy, slice4) slice4Copy[0] = 6666 fmt.Println(slice4, slice4Copy) /* 结果： 类型：[]int, 长度：3, 容量：3, 数据：[12 14 24] 类型：[]int, 长度：6, 容量：6, 数据：[12 14 24 3 4 5] [12 14 24 3 4 5] [6666 14 24 3 4 5] */ 5.4 切片的删除\rGo语言中没有内置删除切片方法，可以使用append方法，与切片再切片结合实现\n// 切片的删除 s1 := []int{1, 2, 3, 4, 5, 6} // 删除元素的索引下标 delIndx := 3 // 通过切片append方法，与切片再切片结合实现，即截取[0,3)和[4,5]的切片数据再合并达到删除效果 s1 = append(s1[:delIndx], s1[delIndx+1:]...) fmt.Println(s1) /* 结果： [1 2 3 5 6] */ 5.5 sort排序\r5.5.1 升序排序\r使用sort.Ints、sort.Float64s、sort.Strings进行排序\nintList := []int{3, 4, 32, 32, 423, 12} float64List := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} // 升序排序 sort.Ints(intList) sort.Float64s(float64List) sort.Strings(stringList) fmt.Println(intList) fmt.Println(float64List) fmt.Println(stringList) /* 结果： [3 4 12 32 32 423] [1.1 3.13 4.2 5.3] [A C D S] */ 5.5.2 降序排序\r结合sort.XXXSlice、sort.Reverse和sort.Sort实现\nintList := []int{3, 4, 32, 32, 423, 12} float64List := []float64{3.13, 4.2, 5.3, 1.1} stringList := []string{\u0026#34;D\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;} /* 降序排序 1. sort.IntSlice(intList)表示对intList转成interface，简单理解为将切片转为排序器接口,返回结果类型：data sort.Interface 2. sort.Reverse(data sort.Interface)表示翻转切片，返回结果类型：data sort.Interface 3. sort.Sort(data sort.Interface) 表示将结果排序返回数据 默认当做固定写法：sort.Sort(sort.Reverse(sort.XXXSlice(intList))) 另外也可以自定义排序算法实现降序排序 */ sort.Sort(sort.Reverse(sort.IntSlice(intList))) sort.Sort(sort.Reverse(sort.Float64Slice(float64List))) sort.Sort(sort.Reverse(sort.StringSlice(stringList))) fmt.Println(intList) fmt.Println(float64List) fmt.Println(stringList) /* 结果: [423 32 32 12 4 3] [5.3 4.2 3.13 1.1] [S D C A] */ 6. 扩展技巧\r6.1 语法提示\r对一个变量输入“.”符号时，编译器自动提示语法命令，后缀携带!的表示为功能快捷提示，并生成对应的半成品代码\n截图中提示语功能\n功能提示语句 含义 append! 切片追加数据 copy! copy克隆切片 for! fori循环 forr! for range循环 ifnotnil! if not nil 条件判断 last! 等价于a[len(a -1)]获取最后一个元素 len! 等价于len(a)获取长度 print! 打印变量 range! 等价于forr! reverse! 翻转切片 sort! 自定定排序 var! 将a赋值于新的变量 6.2 方法参数、含义使用探究\r鼠标移动至方法名1s以上，显示方法名参数、返回值，含义，描述详情等信息 用ctrl按键+鼠标左键，点击方法名，即可进入方法名参数、返回值，含义，描述详情等信息，如果不懂英文，可以通过翻译工具认识逐步了解学习 ","date":"2025-01-08T22:05:33+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_05/","title":"Golang学习历程【第五篇 复合数据类型：数组\u0026切片】"},{"content":"1. 运算符\r1.1 算术运算符\r符号 描述 + 加法 - 减法 * 乘法 / 除法 % 取余 示例：\n/* 1. 算术运算符 */ num1 := 5 num2 := 3 fmt.Printf(\u0026#34;%v + %v = %v\\n\u0026#34;, num1, num2, num1+num2) // 加法运算 fmt.Printf(\u0026#34;%v - %v = %v\\n\u0026#34;, num1, num2, num1-num2) // 减法运算 fmt.Printf(\u0026#34;%v * %v = %v\\n\u0026#34;, num1, num2, num1*num2) // 乘法运算 fmt.Printf(\u0026#34;%v / %v = %v\\n\u0026#34;, num1, num2, num1/num2) // 除法运算：除法运算，取整数部分，float类型运算取全部值 // %% 转义，输出% fmt.Printf(\u0026#34;%v %% %v = %v\\n\u0026#34;, num1, num2, num1%num2) // 取余运算：取余数 /* Go中自增，自减运算为语句，不属于运算符，不能赋值，这一点不同于其他语言 ++ 自增 -- 自减 */ num2++ fmt.Printf(\u0026#34;num2自增后：%v \\n\u0026#34;, num2) num2-- fmt.Printf(\u0026#34;num2自减后：%v \\n\u0026#34;, num2) 结果：\n5 + 3 = 8 5 - 3 = 2 5 * 3 = 15 5 / 3 = 1 5 % 3 = 2 num2自增后：4 num2自减后：3 1.2 关系运算符\r符号 描述 == 等于 != 不等于 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 示例：\n/* 2. 关系运算符 */ num3, num4 := 8, 6 fmt.Printf(\u0026#34;%v == %v = %v\\n\u0026#34;, num3, num4, num3 == num4) // false fmt.Printf(\u0026#34;%v != %v = %v\\n\u0026#34;, num3, num4, num3 != num4) // true fmt.Printf(\u0026#34;%v \u0026gt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt; num4) // true fmt.Printf(\u0026#34;%v \u0026gt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026gt;= num4) // true fmt.Printf(\u0026#34;%v \u0026lt; %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt; num4) // false fmt.Printf(\u0026#34;%v \u0026lt;= %v = %v\\n\u0026#34;, num3, num4, num3 \u0026lt;= num4) // false 结果：\n8 == 6 = false 8 != 6 = true 8 \u0026gt; 6 = true 8 \u0026gt;= 6 = true 8 \u0026lt; 6 = false 8 \u0026lt;= 6 = false 1.3 逻辑运算符\r符号 描述 \u0026amp;\u0026amp; 逻辑与 || 逻辑或 ! 取非 示例：\n/* 3. 逻辑运算符 \u0026amp;\u0026amp;: 真 \u0026amp;\u0026amp; 假 = false 假 \u0026amp;\u0026amp; 真 = false 假 \u0026amp;\u0026amp; 假 = false 真 \u0026amp;\u0026amp; 真 = true ||: 真 || 假 = true 假 || 真 = true 真 || 真 = true 假 || 假 = false !: !真 = false !假 = true */ num5, num6 := 16, 20 fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 \u0026lt; 20) // false fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026lt; 15 \u0026amp;\u0026amp; num6 == 20) // false fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 \u0026amp;\u0026amp; num6 == 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 || num6 \u0026lt; 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026lt; 15 || num6 == 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026gt; 15 || num6 == 20) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, num5 \u0026lt; 15 || num6 \u0026gt; 20) // false fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, !(num5 \u0026lt; 15)) // true fmt.Printf(\u0026#34;值 = %v\\n\u0026#34;, !(num6 == 20)) // false 结果：\n值 = false 值 = false 值 = true 值 = true 值 = true 值 = true 值 = false 值 = true 值 = false 1.4 赋值运算符\r符号 描述 = 赋值，表达式右变赋值给左边 += 先加后赋值 -= 先减后赋值 *= 先乘后赋值 /= 先除后赋值 %= 先取余后赋值 \u0026laquo;= 先左移后赋值(高级用法) \u0026raquo;= 先右移后赋值(高级用法) \u0026amp;= 先按位与后赋值(高级用法) |= 先按位或后赋值(高级用法) ^= 先按位异或后赋值(高级用法) 示例：\n/* 1.4 赋值运算符 */ num6, num7 := 3, 6 num7 += num6 // 等价于 num7 := num7 + num6 fmt.Printf(\u0026#34;num7 += num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 -= num6 // 等价于 num7 := num7 - num6 fmt.Printf(\u0026#34;num7 -= num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 *= num6 // 等价于 num7 := num7 * num6 fmt.Printf(\u0026#34;num7 *= num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 /= num6 // 等价于 num7 := num7 / num6 fmt.Printf(\u0026#34;num7 /= num6 结果为： %v\\n\u0026#34;, num7) num7 = 6 // 赋值初始值 num7 %= num6 // 等价于 num7 := num7 % num6 fmt.Printf(\u0026#34;num7 %%= num6 结果为： %v\\n\u0026#34;, num7) 结果：\nnum7 += num6 结果为： 9 num7 -= num6 结果为： 3 num7 *= num6 结果为： 18 num7 /= num6 结果为： 2 num7 %= num6 结果为： 0 高级用法在二进制运算中举例，点击此处跳转\n1.5 其他运算符\r符号 描述 \u0026amp; 返回变量存储地址 * 指针变量 计算机上是通过地址空间存储变量。 地址是指存储变量的内存位置，即变量的地址，一般由16进制数值表示； 指针是指向变量地址的变量； 变量的值：在当前内存空间位置上存储了变量表示的值。\n示例\n/* 1.5 其他运算符 \u0026amp;：用于获取变量的地址值 *: 用户获取地址上存储的值 */ // var p *int num8 := 100 p = \u0026amp;num8 // 将num8的地址赋值于p ,获取指针的值用*p fmt.Printf(\u0026#34;p地址值=%v,p的值=%v\u0026#34;, p, *p) 结果：\np地址值=0xc00000a0d8,p的值=100 2. 二进制运算\r以下所有的操作运算都是以二进制数值操作\n符号 描述 \u0026amp; 按位与 | 按位或 ^ 异或 \u0026laquo; 左移 \u0026raquo; 右移 运算逻辑：\np q p\u0026amp;q p|q p^q 0 0 0 0 0 1 0 0 1 1 0 1 0 1 1 1 1 1 1 0 \u0026amp;运算：运算两边全为1时值为1，其余位0 |运算：运算两边全为0时值为0，其余为1 ^运算：运算两边数值不同为1，相同为0 \u0026laquo;运算：例如 p\u0026laquo;q ，p的二进制值左移q位。右边空位补0 \u0026gt;\u0026gt;运算：例如 p\u0026raquo;q ，p的二进制值右移q位。删除左边空位0 二进制运算在操作地址运算，IP运算等偏向于硬件有着效率高，运算快的特点\n示例：\n/* 1.6 二进制运算 \u0026amp;运算：运算两边全为1时值为1，其余位0 |运算：运算两边全为0时值为0，其余为1 ^运算：运算两边数值不同为1，相同为0 \u0026lt;\u0026lt;运算：例如 p\u0026lt;\u0026lt;q ，p的二进制值左移q位。右边空位补0 \u0026gt;\u0026gt;运算：例如 p\u0026gt;\u0026gt;q ，p的二进制值右移q位。删除左边空位0 */ var num1 = 0b101011 var num2 = 0b110001 fmt.Printf(\u0026#34;%b \u0026amp; %b = %b \\n\u0026#34;, num1, num2, num1\u0026amp;num2) fmt.Printf(\u0026#34;%b | %b = %b \\n\u0026#34;, num1, num2, num1|num2) fmt.Printf(\u0026#34;%b ^ %b = %b \\n\u0026#34;, num1, num2, num1^num2) fmt.Printf(\u0026#34;%b \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, num1, 2, num1\u0026lt;\u0026lt;2) fmt.Printf(\u0026#34;%b \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, num2, 2, num2\u0026gt;\u0026gt;2) // 使用高级赋值运算符计算 num2 = 0b110001 // 初始化 num2 \u0026amp;= num1 fmt.Printf(\u0026#34;用\u0026amp;= 计算：%b \u0026amp; 110001 = %b \\n\u0026#34;, num1, num2) num2 = 0b110001 // 初始化 num2 |= num1 fmt.Printf(\u0026#34;用|= 计算：%b | 110001 = %b \\n\u0026#34;, num1, num2) num2 = 0b110001 // 初始化 num2 ^= num1 fmt.Printf(\u0026#34;用^= 计算：%b ^ 110001 = %b \\n\u0026#34;, num1, num2) num1 = 0b110001 // 初始化 num1 \u0026lt;\u0026lt;= 2 fmt.Printf(\u0026#34;用\u0026lt;\u0026lt;= 计算：110001 \u0026lt;\u0026lt; %d = %b \\n\u0026#34;, 2, num1) num2 = 0b110001 // 初始化 num2 \u0026gt;\u0026gt;= 2 fmt.Printf(\u0026#34;用\u0026gt;\u0026gt;= 计算：110001 \u0026gt;\u0026gt; %d = %b \\n\u0026#34;, 2, num2) 结果：\n101011 \u0026amp; 110001 = 100001 101011 | 110001 = 111011 101011 ^ 110001 = 11010 101011 \u0026lt;\u0026lt; 2 = 10101100 110001 \u0026gt;\u0026gt; 2 = 1100 用\u0026amp;= 计算：101011 \u0026amp; 110001 = 100001 用|= 计算：101011 | 110001 = 111011 用^= 计算：101011 ^ 110001 = 11010 用\u0026lt;\u0026lt;= 计算：110001 \u0026lt;\u0026lt; 2 = 11000100 用\u0026gt;\u0026gt;= 计算：110001 \u0026gt;\u0026gt; 2 = 1100 \u0026amp;和|妙用\n例：假设，用5位二进制表示座位的空闲和占用，那么全部空闲为：00000，全部占用为：11111。那么有两种场景：1. 指定第1,3,5为空闲状态；2.指定第2,4座位为占用状态的实现方式如下：\n// 默认座位代表：占用，空闲，空闲，占用，占用 var seat = 0b10011 // 将1,3,5的位置置为空闲0，即目标结果：空闲，空闲，空闲，占用，空闲 var initValue1 = 0b01010 // 解释：不管原值是0或者1，只要initValue1第1,3,5位置为0,\u0026amp;的最终结果都为0，而initValue1第2,4位置为1,保证\u0026amp;结果保留原来的值不变 fmt.Printf(\u0026#34;将1,3,5的位置置为0:%b \\n\u0026#34;, seat\u0026amp;initValue1) // 结果10，即00010，前缀0省略 // 将2,4的位置置为占用1，即目标结果：占用，占用，空闲，占用，占用 var initValue2 = 0b01010 // 解释：不管原值是0或者1，只要initValue2第2,4位置为1,|的最终结果都为1，而initValue1第1,3,5位置为0,保证|结果保留原来的值不变 fmt.Printf(\u0026#34;将2,4的位置置为1:%b \\n\u0026#34;, seat|initValue2) // 结果11011 将1,3,5的位置置为0:10 将2,4的位置置为1:11011 由上述示例可见，使用同一个二进制01010值，就能操作两种不同的场景运算，这在信号灯控制、开关控制等两种取反操作场景中非常适用\n3. 流程控制\r3.1 条件表达式if\r条件判断：按照程序顺序执行，仅可执行满足一个条件的语句内容。\n示例：\n/* 下列格式严格按照书写规范，否则报错 1. 条件判断： if 条件判断1 { } else if 条件判断2 { } else if ... { } else { } */ // 写法1 , 此时score作用于在当前范围作用域 score := 60 if score \u0026gt;= 90 { // \u0026gt;= 90 fmt.Println(\u0026#34;成绩卓越\u0026#34;) } else if score \u0026gt;= 80 { // \u0026gt;= 80 \u0026amp;\u0026amp; \u0026lt; 90 fmt.Println(\u0026#34;成绩优秀\u0026#34;) } else if score \u0026gt;= 70 { // \u0026gt;= 70 \u0026amp;\u0026amp; \u0026lt; 80 fmt.Println(\u0026#34;成绩良好\u0026#34;) } else if score \u0026gt;= 60 { // \u0026gt;= 60 \u0026amp;\u0026amp; \u0026lt; 70 fmt.Println(\u0026#34;成绩合格\u0026#34;) } else { // \u0026lt; 60 fmt.Println(\u0026#34;成绩不合格\u0026#34;) } // 写法2： 此时score1作用于在当前if内部作用域 if score1 := 80; score1 \u0026gt;= 90 { // \u0026gt;= 90 fmt.Println(\u0026#34;成绩卓越\u0026#34;) } else if score1 \u0026gt;= 80 { // \u0026gt;= 80 \u0026amp;\u0026amp; \u0026lt; 90 fmt.Println(\u0026#34;成绩优秀\u0026#34;) } else if score1 \u0026gt;= 70 { // \u0026gt;= 70 \u0026amp;\u0026amp; \u0026lt; 80 fmt.Println(\u0026#34;成绩良好\u0026#34;) } else if score1 \u0026gt;= 60 { // \u0026gt;= 60 \u0026amp;\u0026amp; \u0026lt; 70 fmt.Println(\u0026#34;成绩合格\u0026#34;) } else { // \u0026lt; 60 fmt.Println(\u0026#34;成绩不合格\u0026#34;) } // 此时使用score1会报错 fmt.Println(strconv.Itoa(score)) 结果：\n成绩合格 成绩优秀 80 在这里插入代码片 3.2 for循环\r/* ()内容可以省略 for (初始语句;)(条件表达式;)(结束语句) { 循环体 } 执行顺序： 1. 执行初始语句 2. 条件表达式 3. 循环体 4. 结束语句 5. 条件表达式,判断是否满足条件 6. 如果满足条件为true：第3,4,5步循环执行，直到条件表达式为false结束 */ var str = \u0026#34;hello world\u0026#34; // 写法1 for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) } fmt.Println() // 写法2 i := 0 for i \u0026lt; len(str) { fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } fmt.Println() // 写法3 Go中没有while控制语句，该写法可替代 i = 0 for { if i \u0026gt;= len(str) { break } fmt.Printf(\u0026#34;%c \u0026#34;, str[i]) i++ } 结果：\nh e l l o w o r l d h e l l o w o r l d h e l l o w o r l d 3.3 for range(键值循环)\r示例：\n/* for ...range 格式 for 键,值 := range 变量{ 循环体 } */ text := \u0026#34;你好,program\u0026#34; for k, v := range text { fmt.Printf(\u0026#34;k=%v,v=%c\\n\u0026#34;, k, v) } 结果：\nk=0,v=你 k=3,v=好 k=6,v=, k=7,v=p k=8,v=r k=9,v=o k=10,v=g k=11,v=r k=12,v=a k=13,v=m 3.4 switch\u0026hellip;case\r与if条件判断类型，switch\u0026hellip;case更多用于判断枚举类型\n/* switch 枚举值{ case 固定值1: (break) case 固定值2: (break) case 固定值3: (break) ... default: } 执行顺序：1. 枚举值 2. case 命中，哪一个case命中，执行哪个case下的语句 */ // 写法1 var week = 3 switch week { case 1: fmt.Println(\u0026#34;周一\u0026#34;) case 2: fmt.Println(\u0026#34;周二\u0026#34;) case 3: fmt.Println(\u0026#34;周三\u0026#34;) case 4: fmt.Println(\u0026#34;周四\u0026#34;) case 5: fmt.Println(\u0026#34;周五\u0026#34;) case 6: fmt.Println(\u0026#34;周六\u0026#34;) case 7: fmt.Println(\u0026#34;周日\u0026#34;) default: fmt.Println(\u0026#34;不存在\u0026#34;) } // 写法2，同样week1仅作用域在switch内部 switch week1 := 0; week1 { case 1: fmt.Println(\u0026#34;周一\u0026#34;) case 2: fmt.Println(\u0026#34;周二\u0026#34;) case 3: fmt.Println(\u0026#34;周三\u0026#34;) case 4: fmt.Println(\u0026#34;周四\u0026#34;) case 5: fmt.Println(\u0026#34;周五\u0026#34;) case 6: fmt.Println(\u0026#34;周六\u0026#34;) case 7: fmt.Println(\u0026#34;周日\u0026#34;) default: fmt.Println(\u0026#34;不存在\u0026#34;) } // 写法3, case 可以写多个枚举值 switch num := 10; num { case 0, 2, 4, 6, 8, 10: fmt.Println(\u0026#34;偶数\u0026#34;) case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;奇数\u0026#34;) } // 写法4，case 中可以写条件表达式 score := 80 switch { case score \u0026gt;= 90: fmt.Println(\u0026#34;卓越\u0026#34;) case score \u0026gt;= 80: fmt.Println(\u0026#34;优秀\u0026#34;) case score \u0026gt;= 70: fmt.Println(\u0026#34;良好\u0026#34;) case score \u0026gt;= 60: fmt.Println(\u0026#34;及格\u0026#34;) default: fmt.Println(\u0026#34;不及格\u0026#34;) } 结果：\n周三 不存在 偶数 优秀 Go语言的switch..case中，break默认存在的，即仅能执行case，不能语句穿透。如果需要语句穿透，可使用fallthrough语句，一次使用仅能穿透一层 例：\nswitch week1 := 5; week1 { case 1: fmt.Println(\u0026#34;周一\u0026#34;) case 2: fmt.Println(\u0026#34;周二\u0026#34;) case 3: fmt.Println(\u0026#34;周三\u0026#34;) case 4: fmt.Println(\u0026#34;周四\u0026#34;) case 5: fmt.Println(\u0026#34;周五\u0026#34;) fallthrough case 6: fmt.Println(\u0026#34;周六\u0026#34;) case 7: fmt.Println(\u0026#34;周日\u0026#34;) default: fmt.Println(\u0026#34;不存在\u0026#34;) } 结果：\n周五 周六 3.5 break,continue,goto\rbreak表示跳出当前循环 continue表示跳过档次循环执行 goto 表示跳至指定语句执行 示例：\nlable1: // 固定写法 \u0026lt;随意标签名\u0026gt;: for i := 0; i \u0026lt;= 3; i++ { if i == 0 { continue // 跳过当次循环 0跳过 } if i == 1 { continue lable1 // 跳至lable1位置 ,1跳过, 继续执行 } fmt.Printf(\u0026#34;i=%d \\n\u0026#34;, i) } lable2: for j := 0; j \u0026lt;= 3; j++ { if j == 3 { fmt.Printf(\u0026#34;跳出 \\n\u0026#34;) break // 3跳出循环 } if j == 1 { break lable2 // 跳至lable2位置, 1跳过，不执行当前循环体 } fmt.Printf(\u0026#34;j=%d \\n\u0026#34;, j) } /* goto可以任意指定标签位置，跳至指定位置执行 解释： 1. 执行语句1, 2. i 自增为1 2. goto跳至lable4，执行语句3 3. goto跳至lable3，执行语句1 4. i 自增为2 5. goto跳至lable5，执行语句4 最终跳过了执行语句2 */ i := 0 lable3: fmt.Println(\u0026#34;执行语句1\u0026#34;) i++ if i == 2 { // 执行2次之后 goto lable5 } goto lable4 fmt.Println(\u0026#34;执行语句2\u0026#34;) // 被跳过 lable4: fmt.Println(\u0026#34;执行语句3\u0026#34;) goto lable3 lable5: fmt.Println(\u0026#34;执行语句4\u0026#34;) 结果：\ni=2 i=3 j=0 执行语句1 执行语句3 执行语句1 执行语句4 ","date":"2025-01-01T11:03:08+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_04/","title":"Golang学习历程【第四篇 运算符\u0026流程控制】"},{"content":"1. 总览\rGo语言中数据类型分为：基本数据类型和复合数据类型\n基本数据类型：整型，浮点型，布尔型，字符串 复合数据类型：数组，切片，结构体，函数，map，通道（channel）、接口等\n2. 基本数据类型\r2.1 整型\r类型 范围 占用空间 有无符号 int8 $-2^7$~$2^7-1$ 1个字节 有 int16 $-2^{15}$~$2^{15}-1$ 2个字节 有 int32 $-2^{31}$~$2^{31}-1$ 4个字节 有 int64 $-2^{63}$~$2^{63}-1$ 8个字节 有 uint8 $0$~$2^8-1$ 1个字节 无 uint16 $0$~$2^{16}-1$ 2个字节 无 uint32 $0$~$2^{32}-1$ 4个字节 无 uint64 $0$~$2^{64}-1$ 8个字节 无 特殊类型：\n类型 描述 uint 32位操作系统上为uint32,64位操作系统上为uint64 int 32位操作系统上为int32,64位操作系统上为int64 uintptr 无符号整型，用于存放一个指针 简单示例：\nvar ( num1 int = 666 num2 uint = 666 // 以下赋值可选最大值，math 为math包，使用即自动引入 num1 int = 666 num2 uint = 666 // 以下赋值可选最大值 num3 int8 = math.MaxInt8 num4 int16 = math.MaxInt16 num5 int32 = math.MaxInt32 num6 int64 = math.MaxInt64 num7 uint8 = math.MaxUint8 num8 uint16 = math.MaxUint16 num9 uint32 = math.MaxUint32 num10 uint64 = math.MaxUint64 ) fmt.Println(num1, num2, num3, num4, num5, num6, num7, num8, num9, num10) 结果：\n666 666 127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615 2.2 浮点型\rGo语言支持两种浮点数：float32和float64，遵循IEEE 745标准。32位操作系统中，默认为float32；64位操作系统中默认为float64。\nfloat32：-3.4e38~3.4e38 ，占用4个字节 float64：-1.8e308~1.8e308，占用8个字节 // 1. 基本定义 var num1 float32 = 1.06 num2 := 3.1415926 // 保留小数据，可以使用%.nf或者%0.nf 指定保留n位小数， fmt.Printf(\u0026#34;原样输出：%v; 默认保留6位小数: %f; 指定保留3为小数: %0.3f \\n\u0026#34;, num1, num2, num2) // 2. 其他常用样例 var ( num3 float32 = 3.1415926 num4 float64 = 1.113 num5 = 3.14e2 // 使用科学计数法表示，3.14*10^2 的值：为314 num6 = 3.14e-2 // 使用科学计数法表示，3.14*10-2 的值：为0.0314 ) fmt.Println(num3, num4, num5, num6) 结果：\n原样输出：1.06; 默认保留6位小数: 3.141593; 指定保留3为小数: 3.142 3.1415925 1.113 314 0.0314 2.2 布尔型\rbool值仅有两个值：true和false。声明不赋值，默认为false\nvar ( bool1 bool bool2 = true ) fmt.Println(bool1, bool2) 结果：\nfalse true 2.3 字符\r字符是单个数值，属于int类型，Go语言中有两种表示：byte和rune\nbyte: int类型，代表ASCII码的值 rune: int类型，代表UTF-8编码 注：UTF-8的国际通用编码，是ASCII码的扩展，包括了各国的常用的语言文字\u0026lt;/font 常用示例：\nvar a = \u0026#39;A\u0026#39; var a = \u0026#39;A\u0026#39; // 使用%c输出字符 fmt.Printf(\u0026#34;字符ASCII值:%v; 原样编码:%c \\n\u0026#34;, a, a) var ( b = \u0026#39;B\u0026#39; c = \u0026#39;你\u0026#39; d = \u0026#34;this\u0026#34; // 可以获取字符串中的单个字符 ) fmt.Printf(\u0026#34;%c,%c,%c,%c,%c,%c\u0026#34;, b, c, d[0], d[1], d[2], d[3]) 结果：\n字符ASCII值:65; 原样编码:A B,你,t,h,i,s 2.4 字符串\r2.4.1 常用定义方式\r// 字符串定义 var val1 string = \u0026#34;hello world\u0026#34; var val2 = \u0026#34;你好 go\u0026#34; val3 := \u0026#34;Good\u0026#34; fmt.Println(val1, val2, val3) // 字符串val2中2个中文，3个英文(空格也算)；共2*3+3=9个字符，可通过len函数获取 fmt.Println(len(val2)) // 多行字符串：会原样输出 var info = `姓名：张三 年龄：18` fmt.Println(info) 结果：\nhello world 你好 go Good 9 姓名：张三 年龄：18 字符串中，英文字母占一个字节，中文占用3个字节。可使用len函数打印字符串字节长度\n2.4.2 转移字符\r转义符号使用\\表示 常用的转义字符有：\n\\r：回车符（返回行首） \\n：换行符（跳至下一行同列） \\t：制表符（可用于整齐输出一系列值） \\'：单引号，输出' \\\u0026quot;：双引号，输出\u0026quot; \\\\：反斜杠，输出\\ var val1 string = \u0026#34;hello\\r\u0026#34; var val2 string = \u0026#34;world\\n\u0026#34; var val3 string = \u0026#34;hello world\\t\u0026#34; var val4 string = \u0026#34;\u0026#39;hello\u0026#39; \\\\ \\\u0026#34;world\\\u0026#34;\u0026#34; /* var1：\\r 回车符，hello输出结束后回车，光标移动至当前行首，意味着清空hello值 val2: \\n 换行符，world输出之后换行 val3: \\t 制表符，hello world简易理解为一个大的空格，格式美观，自带对齐 val4: Go语言中\u0026#39;可以直接写在\u0026#34;内部，\\\\输出\\, \\\u0026#34; 转义字符，输出\u0026#34; */ fmt.Println(val1, val2, val3, val4) 结果：\nworld hello world \u0026#39;hello\u0026#39; \\ \u0026#34;world\u0026#34; 2.4.3 常用方法\r方法名基本上为常用英文名缩写，各语言基本通用，使用多了自然熟记\n方法 描述 len 获取字符串长度 +或fmt.Springf 拼接字符串 strings.Split 拆分字符串 strings.Contains 获取字符串长度 strings.HasPrefix,strings.HasSuffix 获取字符串长度 strings.Index,strings.LastIndex 获取字符串长度 strings.Join 获取字符串长度 strings.ToLower 字符串全转小写 strings.ToUpper 字符串全转大写 示例：\nvar val = \u0026#34;Hello World\u0026#34; // 1. len求长度 length := len(val) fmt.Printf(\u0026#34;%s长度: %d\\n\u0026#34;, val, length) // 2. + 拼接字符串，Sprint中S代表返回字符串，同理含有：Sprinf、Sprinln，与Prinf、Prinln类似，区别在于S开头函数代表返回字符串，可用变量接收 str1 := val + \u0026#34;小明\u0026#34; str2 := fmt.Sprint(val, \u0026#34;小红\u0026#34;) fmt.Printf(\u0026#34;+拼接：%s;\\tSprint函数拼接: %s \\n\u0026#34;, str1, str2) // 3. 字符串拆分结果为：切片（类似于数组）；参数为(\u0026lt;原字符串\u0026gt;, \u0026lt;切片字符串\u0026gt;)，示例中将Hello World以空格拆分为Hello和World splitVal := strings.Split(val, \u0026#34; \u0026#34;) // 切片结果为[Hello World] // 4. Join将切片拼接成新的字符串；参数为(\u0026lt;原字符串\u0026gt;, \u0026lt;连接符\u0026gt;) newStr := strings.Join(splitVal, \u0026#34;,\u0026#34;) // fmt.Printf(\u0026#34;切片值：%v;\\tJoin连接成新的字符串: %s \\n\u0026#34;, splitVal, newStr) // 5.字符串是否包含子串，Contains参数为(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;) bool1 := strings.Contains(val, \u0026#34;Hello\u0026#34;) bool2 := strings.Contains(val, \u0026#34;Hello\u0026#34;) fmt.Printf(\u0026#34;是否包含Hello：%v;\\t是否包含olleH: %v \\n\u0026#34;, bool1, bool2) // 6. 前缀判断：HasPrefix ,参数为(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;); 后缀判断：HasSuffix，参数(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;) bool3 := strings.HasPrefix(val, \u0026#34;He\u0026#34;) bool4 := strings.HasPrefix(val, \u0026#34;llo\u0026#34;) bool5 := strings.HasSuffix(val, \u0026#34;World\u0026#34;) bool6 := strings.HasSuffix(val, \u0026#34;Wor\u0026#34;) fmt.Printf(\u0026#34;前缀包含He：%v;\\t前缀包含llo: %v\\t后缀包含World：%v;\\t后缀包含Wor: %v \\n\u0026#34;, bool3, bool4, bool5, bool6) // 7. 返回子串在原字符串首次出现的位置，Index，从前向后查找；LastIndex，从后向前查找，参数都为(\u0026lt;原字符串\u0026gt;,\u0026lt;子串\u0026gt;)。结果：查询到，返回下标值，查询不到，返回-1。注：下标从0开始 index1 := strings.Index(val, \u0026#34;o\u0026#34;) index2 := strings.LastIndex(val, \u0026#34;o\u0026#34;) index3 := strings.Index(val, \u0026#34;a\u0026#34;) fmt.Printf(\u0026#34;o从前到后查询在第%v位;\\to从后到前查询在第%v位\\ta从前到后查询在第%v位\\n\u0026#34;, index1, index2, index3) // 8. strings.ToLower和strings.ToUpper str3 := strings.ToLower(val) str4 := strings.ToUpper(val) fmt.Printf(\u0026#34;全小写： %v;\\t全大写：%v\\n\u0026#34;, str3, str4) 运行结果\nHello World长度: 11 +拼接：Hello World小明; Sprint函数拼接: Hello World小红 切片值：[Hello World]; Join连接成新的字符串: Hello,World 是否包含Hello：true; 是否包含olleH: true 前缀包含He：true; 前缀包含llo: false 后缀包含World：true; 后缀包含Wor: false o从前到后查询在第4位; o从后到前查询在第7位 a从前到后查询在第-1位 全小写hello world; 全大写HELLO WORLD 温馨提示：这里的len、split、contains、prefix、suffix、index、join、lower、upper等所表示的含义在各个编程语言大同小异，只要通一门语言，其他也就简单了\n2.4.3 字符串中字符替换\r// 字符串中替换字符 var val1 = \u0026#34;hello xioaming\u0026#34; byteStr := []byte(val1) // 英文字符 转成byte数组类型即可，然后替换值 byteStr[0] = \u0026#39;a\u0026#39; fmt.Println(string(byteStr)) // string(byteStr)为将数组转成字符串返回，fmt.Println再打印输出结果 var val2 = \u0026#34;你好小明\u0026#34; runeStr := []rune(val2) // 包含中文字符 需要转成rune数组类型即可，然后替换值 runeStr[0] = \u0026#39;我\u0026#39; fmt.Println(string(runeStr)) 结果：\naello xioaming 我好小明 3. 类型转换\r数字类型装换有两种：低精度转高精度，高精度转低精度 注：高精度转低精度，慎用，由于类型表示范围不同，可能造成精度丢失\n3.1 整型与整型转化\r示例：\n// 进度转换可通过 int8(\u0026lt;整型\u0026gt;),int16(\u0026lt;整型\u0026gt;),int32(\u0026lt;整型\u0026gt;),int64(\u0026lt;整型\u0026gt;)转换 // 1. 低精度转高精度 var a int8 = 127 b := int64(a) fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, a, a, b, b) // 2. 高精度转低精度 var c int64 = 127 d := int16(c) fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, c, c, d, d) 结果：\na=127,类型：int8 b=127,类型：int64 a=127,类型：int64 b=127,类型：int16 3.2 浮点数与整型转换\r示例：\n// 3. 整型转浮点型，可通过 float32(\u0026lt;整型\u0026gt;),float64(\u0026lt;整型\u0026gt;)，浮点数转浮点数据也可以这样操作 var e int16 = 256 f := float32(e) fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, e, e, f, f) // 4. 浮点型转整型 var g float64 = 3.145 h := int16(g) // 注：类型会丢失，不是四舍五入，直接截取整数部分 fmt.Printf(\u0026#34;a=%v,类型：%T\\tb=%v,类型：%T \\n\u0026#34;, g, g, h, h) 结果：\na=256,类型：int16 b=256,类型：float32 a=3.145,类型：float64 b=3,类型：int16 3.3 其他类型与string类型转换\rvar ( intV = 123 folatV = 3.145 boolV = true charV = \u0026#39;A\u0026#39; ) // 1. 通过 fmt.Sprintf进行转换 str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, intV) // 转换int str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, folatV) // 转换float str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, boolV) // 转换 bool str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, charV) // 转换 字符 fmt.Println(str1, str2, str3, str4) 结果：\n123 3.145000 true A 3.4 strconv 字符串类型转换工具\r3.4.1 strconv.Atoi(字符串转int) 和 strconv.Itoa(int转字符串)\r简单记忆：i(int) ，itoa中i在首字母，表示int转string。atoi中i在末尾，表示string转int\nvar str = \u0026#34;123\u0026#34; // 1. 将string转换为int类型，strconv.Atoi(\u0026lt;string\u0026gt;)， 返回类型有两个：\u0026lt;转换数据,异常err\u0026gt; num1, _ := strconv.Atoi(str) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, num1, num1) // 2. 将int类型转换为string, strconv.Itoa(\u0026lt;int\u0026gt;),类型必须int，返回类型有一个：\u0026lt;string\u0026gt; var num2 int64 = 456 str2 := strconv.Itoa(int(num2)) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str2, str2) 结果：\n转化值：123 类型：int 转化值：456 类型：string 3.4.2 strconv.Parse 字符串解析为其他类型\rstrconv.Parse能将将字符串解析为指定类型，前提：允许转换\nvar ( str1 = \u0026#34;256\u0026#34; str2 = \u0026#34;3.145\u0026#34; str3 = \u0026#34;true\u0026#34; ) // 以下的bitSize参数感觉意义不大，返回值有特定的返回类型 /* 1. ParseInt params 参数1: string数据 参数2：base 指定进制，取值范围是 2 到 36。如果 base 为 0 参数3：bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64 return int64: 返回始终为int64数值 err: 转换失败后返回的失败信息 */ num1, _ := strconv.ParseInt(str1, 10, 0) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, num1, num1) /* 2. ParseFloat params 参数1: string数据 参数2：bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； return float64: 返回始终为float64数值 err: 转换失败后返回的失败信息 */ num2, _ := strconv.ParseFloat(str2, 32) fmt.Printf(\u0026#34;转化值：%0.3f\\t类型：%T\\n\u0026#34;, num2, num2) /* 3. ParseBool params 参数1: string数据 return bool: 返回始终为bool数值 err: 转换失败后返回的失败信息 */ boo, _ := strconv.ParseBool(str3) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, boo, boo) 结果：\n转化值：256 类型：int64 转化值：3.145 类型：float64 转化值：true 类型：bool 3.4.3 strconv.Format 数字格式化为string\rvar ( intV = 123 floatV = 3.145e2 booV = true ) // 以下的bitSize参数感觉意义不大，返回值有特定的返回类型 /* 1. FormatInt params 参数1: int64数据 参数2：base 指定进制，取值范围是 2 到 36。如果 base 为 0 return string: 返回始终为string数值 */ str1 := strconv.FormatInt(int64(intV), 10) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str1, str1) /* 2. FormatFloat params 参数1: float64数据 参数2：格式化类型 \u0026#39;b\u0026#39; (-ddddp±ddd, 二进制指数), \u0026#39;e\u0026#39; (-d.dddde±dd, 十进制e指数), \u0026#39;E\u0026#39; (-d.ddddE±dd, 十进制E指数), \u0026#39;f\u0026#39; (-ddd.dddd, 无指数), \u0026#39;g\u0026#39; (\u0026#39;e\u0026#39;表示大指数，\u0026#39;f\u0026#39;表示其他指数), \u0026#39;G\u0026#39; (\u0026#39;E\u0026#39;表示大指数，\u0026#39;F\u0026#39;表示其他指数), \u0026#39;x\u0026#39; (-0xd.ddddp±ddd, 十六进制分数和二进制指数 小写), \u0026#39;X\u0026#39; (-0Xd.ddddP±ddd, 十六进制分数和二进制指数 大写). 参数3：保留的小数点位数，四舍五入。-1代表不对小数点格式化处理 参数4：bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； return string: 返回始终为string数值 */ str2 := strconv.FormatFloat(floatV, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str2, str2) /* 3. FormatFloat params 参数1: bool数据 return string: 返回始终为string数值 */ str3 := strconv.FormatBool(booV) fmt.Printf(\u0026#34;转化值：%v\\t类型：%T\\n\u0026#34;, str3, str3) 结果：\n转化值：123 类型：string 转化值：314.5 类型：string 转化值：true 类型：string 3.4.4 其他方法\r其他还包含strconv.Append(字符换追加)、strconv.IsPrint（是否可打印） 和 strconv.IsGraphic（是否图形字符）、strconv.Quote（字符串转义） 和 strconv.Unquote（取出转义）、strconv.CanBackquote（判断是否可以表示为单行反引号字符串）等。 这里学习到这，不做详细示例分析，有印象即可，需要时再学习；可参考链接\n","date":"2024-12-21T19:37:51+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_03/","title":"Golang学习历程【第三篇 基本数据类型\u0026类型转换】"},{"content":" 前言：包是指由官方或者自定义的一系列功能集合体。使用前需要先引入，例如今日所讲的fmt包。引入方式如下： import \u0026quot;fmt\u0026quot;\n1. fmt 包\rfmt 包是一个非常重要且广泛使用的标准库包，它提供了格式化I/O（输入/输出）功能，类似于C语言中的 printf 和 scanf。通过这个包，你可以读取输入并将数据格式化输出到标准输出或其他写入器（writers）\n1.1 打印（print）\r打印功能，简单来说就是系统输出功能，英文简义为Print，驼峰命名，首字母大写，后缀ln换行含义。后缀f表示可格式化打印\n1.1.1 Print 打印\r// package 包声明： 可以理解为一个文件夹 package main // import 导入：一般指导入官方或自定义功能包 import \u0026#34;fmt\u0026#34; // main函数 入口函数 func main() { /** * 打印输出功能 */ fmt.Print(\u0026#39;C\u0026#39;) // 打印字符，单引号，语法灵活易学 fmt.Print(\u0026#34;a\u0026#34;) // 打印字符串 fmt.Print(\u0026#34;Hello World\u0026#34;) // 打印字符串，双引号 fmt.Print(123) // 打印整数 fmt.Print(3.1415926) // 打印小数 fmt.Print(true) // 打印布尔值 } 上述结果：\n67aHello World1233.1415926true 总结：Print仅打印功能，可打印任意类型，细心的朋友可能发现，单引号字符串'C'输出结果为67，单引号代表单个字符，输出的结果是ASCII值，双引号表示打印字符串。如果使用'ABC'。运行结果会报错more than one character in rune literal。中文意思是：符文文字中有多个字符。\n1.1.2 Println 打印后换行\r上述代码如果使用Println 打印，代码如下： 注：以下代码以后只显示关键代码段，main函数不予展示。\nfmt.Println(\u0026#39;C\u0026#39;) // 打印字符，单引号，语法灵活易学 fmt.Println(\u0026#34;a\u0026#34;) // 打印字符串 fmt.Println(\u0026#34;Hello World\u0026#34;,\u0026#34;你好\u0026#34;) // 打印字符串，双引号 fmt.Println(123) // 打印整数 fmt.Println(3.1415926) // 打印小数 fmt.Println(true) // 打印布尔值 效果清晰明了，如下：\n67 a Hello World 你好 123 3.1415926 true 1.1.3 Printf 打印格式化参数\r可指定格式打印。常用格式类型如下：\n格式化符号 描述 重要程度(个人观点) %T 打印变量类型 高 %v 以默认格式输出变量 高 %t 输出 true 或 false 高 %b 二进制表示 高 %c Unicode 对应字符 低 %d 十进制表示 高 %o 八进制表示 高 %x 十六进制表示（小写字母） 高 %X 十六进制表示（大写字母） 低 %U Unicode 格式输出 低 %f 十进制浮点数 高 %e 科学计数法（小写 e） 低 %E 科学计数法（大写 E） 低 %g 自动选择 %f 或 %e 的简洁表示 高 %s 普通字符串 高 %q 带双引号的字符串或字符 低 %p 指针地址 低 示例代码：\nfmt.Printf(\u0026#34;布尔值：%t \\n\u0026#34;, false) // 打印布尔值 fmt.Printf(\u0026#34;Unicode 65对应字符：%c \\n\u0026#34;, 65) // Unicode 对应字符 fmt.Printf(\u0026#34;默认格式65：%v \\n\u0026#34;, 65) // 二进制打印 fmt.Printf(\u0026#34;二进制65：%b \\n\u0026#34;, 65) // 二进制打印 fmt.Printf(\u0026#34;十进制65：%d \\n\u0026#34;, 65) // 十进制打印 fmt.Printf(\u0026#34;八进制65：%o \\n\u0026#34;, 65) // 八进制打印 fmt.Printf(\u0026#34;十六进制1024（小）：%x \\n\u0026#34;, 1024) // 十六进制小写打印 fmt.Printf(\u0026#34;十六进制1024（大）：%X \\n\u0026#34;, 1024) // 十六进制大写打印 fmt.Printf(\u0026#34;\u0026#39;C\u0026#39; Unicode值：%U \\n\u0026#34;, \u0026#39;C\u0026#39;) // Unicode输出 fmt.Printf(\u0026#34;浮点数：%f \\n\u0026#34;, 3.1415926) // 十进制浮点数 fmt.Printf(\u0026#34;科学计数法（小）：%e \\n\u0026#34;, 3.1415926) // 科学计数法（小写 e） fmt.Printf(\u0026#34;科学计数法（大）：%E \\n\u0026#34;, 3.1415926) // 科学计数法（大写 e） 运行结果：\n布尔值：false Unicode 65对应字符：A 默认格式65：65 二进制65：1000001 十进制65：65 八进制65：101 十六进制1024（小）：400 十六进制1024（大）：400 \u0026#39;C\u0026#39; Unicode值：U+0043 浮点数：3.141593 科学计数法（小）：3.141593e+00 科学计数法（大）：3.141593E+00 1.2 输入(Scan)\r输入用Scan表示，后缀f表示格式化输入\n1.2.1 Scan 输入\r示例：\n// 基本变量声明：var \u0026lt;变量名\u0026gt; \u0026lt;类型\u0026gt; var name string // 声明字符串类型 var age int // 声明整数类型 fmt.Print(\u0026#34;请输入姓名和年龄：\u0026#34;) fmt.Scan(\u0026amp;name, \u0026amp;age) // 录入姓名和年龄 fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) // 格式化输出姓名和年龄 运行结果：\n请输入姓名和年龄：张三 18 name=张三,age=18 1.2.2 Scanf 格式化输入\r示例：\n// 基本变量声明：var \u0026lt;变量名\u0026gt; \u0026lt;类型\u0026gt; var name string // 声明字符串类型 var age int // 声明整数类型 fmt.Print(\u0026#34;请输入姓名和年龄：\u0026#34;) fmt.Scanf(\u0026#34;%s %d\u0026#34;, \u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;name=%s,age=%d \\n\u0026#34;, name, age) 运行如下示例，体验到：Go语言灵活多变，适合0基础学习\nPS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 18 name=张三,age=18 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 李四 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 李四 18 name=张三,age=0 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：张三 18 李四 name=张三,age=18 PS F:\\go_project\u0026gt; go run main.go 请输入姓名和年龄：18 张三 name=18,age=0 PS F:\\go_project\u0026gt; 2. 变量\r变量，存储数据的容器，可以存放任何数据值。变量名由字母、数字、下划线组成，数字不能开头。Go中的关键字和保留字不能作为变量名\n2.1 变量的声明\r声明变量，指的是定义变量 总共有以下几种方式：\n// var \u0026lt;变量名\u0026gt; \u0026lt;数据类型\u0026gt; var a string // var \u0026lt;变量名\u0026gt;=\u0026lt;值\u0026gt; var b = \u0026#34;张三\u0026#34; fmt.Printf(\u0026#34;a=%v,b=%v\u0026#34;, a, b) // a没有赋值，默认为空 结果：\na=,b=张三 默认初始值测试：\nvar a string // 字符串，默认为空 var b int // 整型，默认为0 var c bool // 布尔值，默认为false var d float32 // 浮点类型，默认为0 fmt.Printf(\u0026#34;a=%v, b=%v, c=%v, d=%v\u0026#34;, a, b, c, d) // a没有赋值，默认为空 结果\na=, b=0, c=false, d=0 提示：Go语言中变量声明必须使用，否则会报错提示 declared and not used，意思是声明了并没有使用\n2.2 变量初始化，赋值\r// 变量初始化声明的三种方式 // 1.1 先声明变量 格式： var \u0026lt;变量名\u0026gt; \u0026lt;变量类型\u0026gt; var name string // 1.2 后赋值 格式：\u0026lt;变量名\u0026gt; = \u0026lt;值\u0026gt; name = \u0026#34;张三\u0026#34; // 2. 声明的同时进行赋值 格式：var \u0026lt;变量名\u0026gt; = \u0026lt;值\u0026gt; var age = 18 // 3.短变量声明法 格式：\u0026lt;变量名\u0026gt; := \u0026lt;值\u0026gt; sex := \u0026#34;男\u0026#34; score := 80 fmt.Print(name, age, sex, score) 结果：\n张三18男80 2.2 声明多个变量\r// 1. 一次声明相同类型 var \u0026lt;变量名1\u0026gt;,\u0026lt;变量名2\u0026gt;... \u0026lt;数据类型\u0026gt; var a1, a2, a3 string a1 = \u0026#34;张三\u0026#34; a2 = \u0026#34;李四\u0026#34; a3 = \u0026#34;王五\u0026#34; fmt.Println(a1, a2, a3) /* * 2. 先声明，后赋值 var ( \u0026lt;变量名1\u0026gt; \u0026lt;数据类型\u0026gt; \u0026lt;变量名2\u0026gt; \u0026lt;数据类型\u0026gt; ... ) */ var ( name string age int ) name = \u0026#34;赵六\u0026#34; age = 20 fmt.Println(name, age) /* 3. 声明即赋值 var ( \u0026lt;变量名1\u0026gt; = \u0026lt;值\u0026gt; \u0026lt;变量名2\u0026gt; = \u0026lt;值\u0026gt; ... ) */ var ( num1 = 1 num2 = 2 ) fmt.Println(num1, num2) // 4. 短变量声明法 \u0026lt;变量名1\u0026gt;,\u0026lt;变量名2\u0026gt;,\u0026lt;变量名3\u0026gt; := \u0026lt;值1\u0026gt;,\u0026lt;值2\u0026gt;,\u0026lt;值3\u0026gt; num3, num4, num5 := 3, 4, \u0026#34;Hello\u0026#34; fmt.Println(num3, num4, num5) 结果：提示：Println具有加空格及换行功能\n张三 李四 王五 赵六 20 1 2 3 4 Hello var声明可用于全局定义使用，短变量声明只能用于局部变量。\n2.3 匿名变量\r匿名变量顾名思义没有变量名，一次性接收，用_表示\n示例：\npackage main import \u0026#34;fmt\u0026#34; // 先举示例，函数的定义后续学习讲解 func getUserInfo() (string, int) { return \u0026#34;zhangsan\u0026#34;, 10 } // main函数 入口函数 func main() { // var声明接收 var name, age = getUserInfo() fmt.Println(name, age) // _匿名变量，用于丢弃赋值 var _, age1 = getUserInfo() fmt.Println(age1) var name1, _ = getUserInfo() fmt.Println(name1) } 结果：\nzhangsan 10 10 zhangsan 匿名变量不占用命名空间，可以重复使用，但是var，:=声明的变量名称不可重复\n3. 常量\r变量是可以修改，变更的值，而常量是不可改变的值，用const声明\n3.1 常量的声明\r// const 定义一个常量 * 最常用 const A = \u0026#34;TEST1\u0026#34; fmt.Println(A) // 定义多个常量 const ( B = \u0026#34;TEST2\u0026#34; C = \u0026#34;TEST3\u0026#34; D = \u0026#34;TEST4\u0026#34; ) fmt.Println(B, C, D) // 定义多个常量，给定一个值 const ( E = \u0026#34;TEST5\u0026#34; F G // 值默认与上一个相同 H = \u0026#34;TEST6\u0026#34; I // 值默认与上一个相同 ) fmt.Println(E, F, G, H, I) 结果：\nTEST1 TEST2 TEST3 TEST4 TEST5 TEST5 TEST5 TEST6 TEST6 3.2 iota 自增长\riota为Go中的计数器，常与const结合使用\n示例：\n// iota 计数器使用 const ( n1 = iota // 0 n2 // 1 _ // 匿名跳过计数 n3 // 3 n4 = iota // 4 n5 // 5 n6 = 100 // 100 插队赋值 n7 = iota // 7 n8, n9, n10 = iota, iota, iota + 1 // 8,8,9 多变量声明iota不会计数叠加， ) fmt.Println(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10) 结果：\n0 1 3 4 5 100 7 8 8 9 4. 总结：Go常量变量命名规则\r变量名必须由数字，字母，下划线_组成 标识符开头不能是数字 标识符不能是保留字和关键字(var、if、for等) 变量的名字是严格区分大小写的，name、Name、NAme以及NAME是不同的四个变量。Go语法支持，但不推荐这样写。 变量定义尽可能见名思意 变量名一般采用驼峰命名法。驼峰命名：首字母小写，后续每个单子首字母大写，例如：maxAge。如果是专属名词，例如DNS,IP等，可直接采用大写。 ","date":"2024-12-21T19:36:53+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_02/","title":"Golang学习历程【第二篇 fmt包\u0026变量、常量的定义】"},{"content":" 引言：Go（又称为Golang）是一种开源的编程语言，由Google开发，于2009年首次公开发布。它旨在提供简洁、高效、可靠的软件开发解决方案。Golang是一种静态强类型、编译型语言，Golang具有很强的表达能力，得益于其并发机制，用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。\n体验感悟：待学习完成后补充\u0026hellip;\n1. 学习文档\r中文文档地址：https://go.p2hp.com/ 【不推荐，落后于官方文档】\n官方文档：https://go.dev/ 【推荐，最新，学习使用英文】\n边学边练： 中文地址 | 英文地址\nB站学习视频地址\n2. Window 本地安装Go\r2.1 安装\r安装步骤依次见下列图示： 点击箭头位置下载安装包，点击安装。注：原则上来说，开发人员不建议安装最新版本，存在一定BUG，但这里学习使用足以。 双击下载的go1.23.4.windows-amd64.msi文件进行安装\n2.2 验证\rwindows找环境变量 另外也可以通过命令方式验证GO是否安装完成。\nwin + R 组合按键唤醒运行窗口。输入: cmd。点击确认或回车： 输入下面命令，验证go是否安装成功 # go 版本号 go version # go 环境变量 go env 友情提示：当不小心点击【鼠标左键】，显示如下信息【关键信息为左上角的选择】。这个情况下表示cmd命令当前窗口为选择窗口，此时命令窗口运行的一切程序处于暂停状态，点击【鼠标右键】可恢复。 3. 开发环境——VsCode\r3.1 VsCode 安装\r安装地址\n下载好的文件将文件解压，一定点击解压文件或者解压到\u0026quot;VsCode-win***\u0026quot;，否则内部文件平铺当前目录，凌乱不堪。将解压的文件夹随意放在自己喜欢的指定磁盘文件下。\n点击解压文件才会有这一步：\n软件快捷方式放于桌面。\n打开软件，功能简要介绍\n3.2 安装插件\r3.2.1 language 语言汉化插件安装\r3.2.2 Go插件安装\r同理将Go插件安装完成\n4. Hello World 入门\r4.1 建工程\rVsCode打开项目工程\n遇到下面界面，点击信任即可\n4.2 创建项目文件\r4.3 编写Hello World程序\r// package 包声明： 可以理解为一个文件夹 package main // import 导入：一般指导入官方或自定义功能包 import \u0026#34;fmt\u0026#34; // main函数 入口函数 func main() { // 打印Hello World字符串，可不写分号，语法灵活 fmt.Println(\u0026#34;Hello World\u0026#34;) } 4.4 VsCode无代码提示解决方案\r打开cmd控制终端，输入GO代理地址\ngo env -w GOPROXY=https://goproxy.io/ 然后重启VsCode，多试几次重启，等待安装，尝试点击即可解决\n4.5 运行程序\r打开终端(本质就是windows的cmd窗口)，运行go文件命令\n// 语法命令：go run \u0026lt;文件名\u0026gt;，运行指定go文件的程序 go run main.go // 运行结果 // Hello World 4.6 构建打包程序\r// 终端执行命令 go build \u0026lt;文件名\u0026gt;。将文件打包成可运行的exe文件。 go build main.go 构建完成之后文件可双击运行在windows上。 当前示例运行后无反应。原因是程序运行完成之后自动关闭了终端窗口。\n","date":"2024-12-21T10:51:49+08:00","permalink":"https://zg-dd.github.io/stu/golang_stu_01/","title":"Golang学习历程【第一篇 入门】"},{"content":"正则表达式部分理解\r[] 使用[]表示匹配[]中括号中的一个字符，比如[abc]，表示匹配a,b,c的任意一个字符，比如字符串中abcdabcdbd，会匹配到a,b,c,a,b,c,b，本意是只要出现一个字符就会匹配，不会合并到一起。 而[abc]+，代表的是匹配abc一次或出现多次，abcdabcdbd这个例子中会匹配到abc,abc,b，也就说匹配的是a,b,c中的任何字符，出现一次或多次都匹配，如果是连续出现的会当做一个字符串匹配到。 \\ \\表示转移符号，常用的转义字符有\\n(换行)、\\t(水平制表符，一个Tab键)、\\r(回车)、\\b(退格)、\\f(换页符)、\\n(换行符)、\\v(垂直制表符)、\\\u0026rsquo;(代表 \u0026rsquo; )、\\\u0026quot;(代表 \u0026ldquo;)、\\\\(代表 \\)等等。正则表达式中还有表示的很多符号，这里就不一一举例了，下面的图片中给出了所有符号。 这里要强调的是： 写正则表达式中，\\b、\\f、\\n、\\t、\\r、\\\u0026rsquo; 这些都可以直接写，例如regex=\u0026quot;\\n\u0026rdquo;;它就表示匹配一个换行符，而regex=\u0026quot;\\\\n\u0026quot;；也表示一个换行符，这两种写法都可以，但是对于一些符号就不能这样写了，例如：\\w、\\W、\\B、\\S、\\s等等这些表示含义就不能这样写了，必须写成regex=\u0026quot;\\\\w\u0026quot;,才能使用，否则会报错。可以尝试一下，再复制这些转义字符时，会将\\自动写成\\\\，所以在写正则表达式使用到带有\\符号的，我建议使用\\\\表示。 注意： 并不是说所有的转义字符都要写成\\\\，例如：匹配 \u0026quot; 字符，不能写成regex=\u0026quot;\\\\\u0026quot;\u0026quot;，系统会将 \u0026quot; 转义为本身 \u0026quot; 含义，那么再java中上述这句话就会多出一个 \u0026quot; 。所以应该写成regex=\u0026quot;\\\\\\\u0026quot;\u0026quot;，写成regex=\u0026quot;\\\u0026quot;\u0026quot;也是可以的。 如果要匹配的是 \\ 的话，java中的表示为regex= \u0026quot; \\\\\\\\ \u0026ldquo;，为四个 \\ ，其中两个的含义表示转义字符，前两个代表转义符号 \\ ，后两个代表另外一个符号 \\ ，使用第一个 \\ 再将第二个 \\ 转义为本身字符 (这是我自己的理解，也许不正确，但是表示方式是对的)，以此类推，如果要匹配\\\\,写法为regex=\u0026rdquo; \\\\\\\\\\\\\\\\ \u0026ldquo; | 这个符号在正则表达式中表示或的意思，对于正则表达式中的x|y，表示匹配x或者y，这里的 | 运算的优先级要高于x,y，也就是说，对于regex = \u0026ldquo;[a][b]|[c][d]\u0026rdquo;，来说，它匹配的是出现ab或者出现cd的字符串，不是匹配a(b或者c)d这样的字符串。 ?\u0026lt;=和?= 这两个符号很重要，这算是个组合符号吧，匹配该某符号但不包含此符号，举个例子就能明白了，比如说要截取双引号（\u0026rdquo; \u0026ldquo;）中说的话，比如String str = \u0026ldquo;he says,\\\u0026ldquo;Hello,Java!\\\u0026rdquo; \u0026ldquo;；说出的话中通常使用\u0026quot;\u0026ldquo;号括起来，现在需要匹配说话的内容，正则表达式可以表示为regex = \u0026ldquo;(?\u0026lt;=\\\u0026rdquo;)[^\\\u0026rdquo;]+(?=\\\u0026rdquo;)\u0026quot;;这其中的意思是：(?\u0026lt;=\\\u0026quot;)代表首先匹配 \u0026quot; ，但是不包含 \u0026quot; ，[^\\\u0026rdquo;]+代表其次匹配一次或者多次匹配不是 \u0026quot; 的字符，(?=\\\u0026quot;)代表再次匹配 \u0026quot; ，但是不包含 \u0026quot; 。这样子就能截取中间的句子了。这两个符号一般配合使用，表示不包含匹配字符，一个在前，一个在后 注：以上所有的单引号双引号都是英文，由于转义的问题，许多符号变成了中文，看本博客的时候需要注意 暂时学到的用到的就只有这些，后边如果再注意到新的点，之后再补充。\n正则表达式表\r","date":"2020-04-27T18:00:00+08:00","permalink":"https://zg-dd.github.io/stu/regular/","title":"正则表达式基础入门：常用符号解析([]、\\、|、(?\u003c=))"}]